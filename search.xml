<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ArrayList</title>
    <url>/posts/35230.html</url>
    <content><![CDATA[<p>hexo generate# ArrayList概述： </p>
<ol>
<li><p>ArrayList 基于数组实现，是一个动态数组，容量能自增，类似于C语言中的动态申请内存，动态增长内存.</p>
</li>
<li><p>ArrayList线程不安全，只能用在单线程环境下，</p>
<p>多线程环境下可以考虑用Collections.synchronizedList(List l)函数返回一个线程安全的ArrayList类，也可以使用concurrent并发包下的CopyOnWriteArrayList类。</p>
</li>
<li><p>ArrayList实现Serializable接口，支持序列化，能够通过序列化传输，实现了RandomAccess接口，支持快速随机访问，实际上就是通过下标序号进行快速访问，实现了Cloneable接口，能被克隆。</p>
</li>
<li><p>每个ArrayList实例都有一个容量，该容量是指用来存储列表元素的数组的大小。它总是至少等于列表的大小</p>
<p>随着向ArrayList中不断添加元素，其容量也自动增长。</p>
<p>自动增长会带来数据向新数组的重新拷贝，因此，如果可预知数据量的多少，可在构造ArrayList时指定其容量。</p>
<p>在添加大量元素前，应用程序也可以使用ensureCapacity操作来增加ArrayList实例的容量，这可以减少递增式再分配的数量。</p>
<p>注意，此实现不是同步的。如果多个线程同时访问一个ArrayList实例，而其中至少一个线程从结构上修改了列表，那么它必须保持外部同步。</p>
</li>
<li><p>关于ArrayList和Vector区别如下：</p>
<p>ArrayList在内存不够时默认是扩展50% + 1个，Vector是默认扩展1倍。</p>
<p>Vector提供indexOf(obj, start)接口，ArrayList没有。</p>
<p>Vector属于线程安全级别的，但是大多数情况下不使用Vector，因为线程安全需要更大的系统开销。</p>
</li>
<li><p>Fail-Fast机制：</p>
<p>ArrayList也采用了快速失败的机制，通过记录modCount参数来实现。</p>
<p>在面对并发的修改时，迭代器很快就会完全失败，而不是冒着在将来某个不确定时间发生任意不确定行为的风险。</p>
</li>
</ol>
<h1 id="ArrayList的实现"><a href="#ArrayList的实现" class="headerlink" title="ArrayList的实现"></a>ArrayList的实现</h1><p>对于ArrayList而言，它实现List接口、底层使用数组保存所有元素。其操作基本上是对数组的操作。下面我们来分析ArrayList的源代码：</p>
<h2 id="1-私有属性："><a href="#1-私有属性：" class="headerlink" title="1. 私有属性："></a>1. 私有属性：</h2><p> ArrayList 两个私有属性：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// elementData存储ArrayList内的元素 被标记为transient的属性在对象被序列化的时候不会被保存。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="comment">// size表示它包含的元素的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> size;</span><br></pre></td></tr></table></figure>
<h2 id="2-构造方法："><a href="#2-构造方法：" class="headerlink" title="2. 构造方法："></a>2. 构造方法：</h2><p>ArrayList 三种方式的构造器，</p>
<ol>
<li>默认初始容量为10的空列表、</li>
<li>指定初始容量的空列表</li>
<li>包含指定collection的元素的列表，这些元素按照该collection的迭代器返回它们的顺序排列的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ArrayList带容量大小的构造函数。  </span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(<span class="type">int</span> initialCapacity)</span> &#123;</span><br><span class="line">  <span class="built_in">super</span>();  </span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)  </span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Illegal Capacity: &quot;</span>+ initialCapacity);  </span><br><span class="line">  <span class="comment">// 新建一个数组  </span></span><br><span class="line">  <span class="built_in">this</span>.elementData = <span class="keyword">new</span> <span class="title class_">Object</span>[initialCapacity];  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ArrayList无参构造函数。默认容量是10。  </span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">()</span> &#123;  </span><br><span class="line">   <span class="built_in">this</span>(<span class="number">10</span>);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个包含collection的ArrayList  </span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;  </span><br><span class="line">  elementData = c.toArray();  </span><br><span class="line">  size = elementData.length;  </span><br><span class="line">  <span class="keyword">if</span> (elementData.getClass() != Object[].class)  </span><br><span class="line">    elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-元素存储"><a href="#3-元素存储" class="headerlink" title="3. 元素存储"></a>3. 元素存储</h2><p>ArrayList提供了set(int index, E element)、add(E e)、add(int index, E element)、</p>
<p>addAll(Collection&lt;? extends E&gt; c)、addAll(int index, Collection&lt;? extends E&gt; c)这些添加元素的方法。   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用指定的元素替代此列表中指定位置上的元素，并返回以前位于该位置上的元素。</span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">set</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    RangeCheck(index);</span><br><span class="line">    <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> (E) elementData[index];</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将指定的元素添加到此列表的尾部。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">add</span><span class="params">(E e)</span> &#123;</span><br><span class="line">    ensureCapacity(size + <span class="number">1</span>);</span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将指定的元素插入此列表中的指定位置。</span></span><br><span class="line"><span class="comment">// 如果当前位置有元素，则向右移动当前位于该位置的元素以及所有后续元素（将其索引加1）。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> index, E element)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index: &quot;</span> + index + <span class="string">&quot;, Size: &quot;</span> + size);</span><br><span class="line">    <span class="comment">// 如果数组长度不足，将进行扩容。</span></span><br><span class="line">    ensureCapacity(size + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 将 elementData中从Index位置开始、长度为size-index的元素，</span></span><br><span class="line">    <span class="comment">// 拷贝到从下标为index+1位置开始的新的elementData数组中。</span></span><br><span class="line">    <span class="comment">// 即将当前位于该位置的元素以及所有后续元素右移一个位置。</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照指定collection的迭代器所返回的元素顺序，将该collection中的所有元素添加到此列表的尾部。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">    ensureCapacity(size + numNew); <span class="comment">// Increments modCount</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从指定的位置开始，将指定collection中的所有元素插入到此列表中。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">addAll</span><span class="params">(<span class="type">int</span> index, Collection&lt;? extends E&gt; c)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(<span class="string">&quot;Index: &quot;</span> + index + <span class="string">&quot;, Size: &quot;</span> + size);</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="type">int</span> <span class="variable">numNew</span> <span class="operator">=</span> a.length;</span><br><span class="line">    ensureCapacity(size + numNew); <span class="comment">// Increments modCount</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew, numMoved);</span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="4-元素读取："><a href="#4-元素读取：" class="headerlink" title="4. 元素读取："></a>4. 元素读取：</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回此列表中指定位置上的元素。 </span></span><br><span class="line"><span class="keyword">public</span> E <span class="title function_">get</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">    RangeCheck(index);</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="5-元素删除："><a href="#5-元素删除：" class="headerlink" title="5. 元素删除："></a>5. 元素删除：</h2><p>ArrayList提供了根据下标或者指定对象两种方式的删除功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// remove(int index):移除此列表中指定位置上的元素。</span></span><br><span class="line">    <span class="keyword">public</span> E <span class="title function_">remove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        RangeCheck(index);</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">E</span> <span class="variable">oldValue</span> <span class="operator">=</span> (E) elementData[index];</span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">        elementData[--size] = <span class="literal">null</span>; <span class="comment">// Let gc do its work</span></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// remove(Object o)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先是检查范围，修改modCount，保留将要被移除的元素，将移除位置之后的元素向前挪动一个位置，</span></span><br><span class="line">    <span class="comment">// 将list末尾元素置空（null），返回被移除的元素。</span></span><br><span class="line">    <span class="comment">// 移除此列表中首次出现的指定元素（如果存在）。这是应为ArrayList中允许存放重复的元素。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">    <span class="comment">// 由于ArrayList中允许存放null，因此下面通过两种情况来分别处理。</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 类似remove(int index)，移除列表中指定位置上的元素。</span></span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>; index &lt; size; index++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当移除成功后返回true，否则返回false。</span></span><br><span class="line">    <span class="comment">// 不用remove(index),适用fastRemove</span></span><br><span class="line">    <span class="comment">// 因为fastRemove跳过了判断边界的处理，因为找到元素就相当于确定了index不会超过边界，</span></span><br><span class="line">    <span class="comment">// 而且fastRemove并不返回被移除的元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">fastRemove</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index, numMoved);</span><br><span class="line">        elementData[--size] = <span class="literal">null</span>; <span class="comment">// Let gc do its work</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// removeRange(int fromIndex,int toIndex)</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">removeRange</span><span class="params">(<span class="type">int</span> fromIndex, <span class="type">int</span> toIndex)</span> &#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">numMoved</span> <span class="operator">=</span> size - toIndex;</span><br><span class="line">        System.arraycopy(elementData, toIndex, elementData, fromIndex, numMoved);</span><br><span class="line">        <span class="comment">// Let gc do its work</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newSize</span> <span class="operator">=</span> size - (toIndex-fromIndex);</span><br><span class="line">        <span class="keyword">while</span> (size != newSize)</span><br><span class="line">            elementData[--size] = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-调整数组容量ensureCapacity："><a href="#6-调整数组容量ensureCapacity：" class="headerlink" title="6. 调整数组容量ensureCapacity："></a>6. 调整数组容量ensureCapacity：</h2><p>每当向数组中添加元素时，都要去检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行扩容，以满足添加数据的需求。</p>
<p>数组进行扩容时，会将老数组中的元素重新拷贝一份到新的数组中，每次数组容量的增长大约是其原容量的1.5倍。</p>
<p>代价高，避免使用</p>
<p>数组扩容通过一个公开的方法ensureCapacity(int minCapacity)来实现，可以手动调用实现，以减少递增式再分配的数量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">ensureCapacity</span><span class="params">(<span class="type">int</span> minCapacity)</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; oldCapacity) &#123;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>为什么要用到oldData[]</p>
<p>Arrays.copyOf的实现时新创建了newCapacity大小的内存，然后把老的elementData放入。</p>
<p>旧的内存的引用是elementData， elementData指向了新的内存块，</p>
<p>如果有一个局部变量oldData变量引用旧的内存块的话，在copy的过程中就会比较安全，</p>
<p>因为这样证明这块老的内存依然有引用，分配内存的时候就不会被侵占掉，然后copy完成后这个局部变量的生命期也过去了，然后释放才是安全的。</p>
<p>不然在copy的的时候万一新的内存或其他线程的分配内存侵占了这块老的内存，而copy还没有结束，这将是个严重的事情。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object oldData[] = elementData;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">newCapacity</span> <span class="operator">=</span> (oldCapacity  <span class="number">3</span>)/<span class="number">2</span> + <span class="number">1</span>; <span class="comment">//增加50%+1if (newCapacity &lt; minCapacity) </span></span><br><span class="line">newCapacity = minCapacity;</span><br><span class="line"><span class="comment">// minCapacity is usually close to size, so this is a win: </span></span><br><span class="line">elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// ArrayList还给我们提供了将底层数组的容量调整为当前列表保存的实际元素的大小的功能。它可以通过trimToSize方法来实现</span></span><br><span class="line"><span class="comment">// 由于elementData的长度会被拓展，size标记的是其中包含的元素的个数。</span></span><br><span class="line"><span class="comment">// 所以会出现size很小但elementData.length很大的情况，将出现空间的浪费。</span></span><br><span class="line"><span class="comment">// trimToSize将返回一个新的数组给elementData，元素内容保持不变，length和size相同，节省空间。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">trimToSize</span><span class="params">()</span> &#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldCapacity</span> <span class="operator">=</span> elementData.length;</span><br><span class="line">    <span class="keyword">if</span> (size &lt; oldCapacity) &#123;</span><br><span class="line">        elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-转为静态数组toArray"><a href="#7-转为静态数组toArray" class="headerlink" title="7.转为静态数组toArray"></a>7.转为静态数组toArray</h2><p> 注意ArrayList的两个转化为静态数组的toArray方法。</p>
<p> 1.调用Arrays.copyOf将返回一个数组，数组内容是size个elementData的元素，</p>
<p>  即拷贝elementData从0至size-1位置的元素到新数组并返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData,size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 2.如果传入数组的长度小于size，返回一个新的数组，大小为size，类型与传入数组相同。</p>
<p>  所传入数组长度与size相等，则将elementData复制到传入数组中并返回传入的数组。</p>
<p>  若传入数组长度大于size，除了复制elementData外，还将把返回数组的第size个元素置为空。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="8-ArrayList的实现中大量地调用了Arrays-copyof-和System-arraycopy-方法"><a href="#8-ArrayList的实现中大量地调用了Arrays-copyof-和System-arraycopy-方法" class="headerlink" title="8. ArrayList的实现中大量地调用了Arrays.copyof()和System.arraycopy()方法"></a>8. ArrayList的实现中大量地调用了Arrays.copyof()和System.arraycopy()方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 首先来看Arrays.copyof()方法。它有很多个重载的方法，但实现思路都是一样的，我们来看泛型版本的源码：/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="type">int</span> newLength) &#123;</span><br><span class="line">    <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 很明显调用了另一个copyof方法，该方法有三个参数，最后一个参数指明要转换的数据的类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="type">int</span> newLength, Class&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>[]&gt; newType) &#123;</span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) <span class="keyword">new</span> <span class="title class_">Object</span>[newLength] : (T[])</span><br><span class="line">            Array.newInstance(newType.getComponentType(),newLength);</span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">            Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来看System.arraycopy()方法。</p>
<p>该方法被标记了native，调用了系统的C/C++代码，在JDK中是看不到的，但在openJDK中可以看到其源码。</p>
<p>该函数实际上最终调用了C语言的memmove()函数，因此它可以保证同一个数组内元素的正确复制和移动，</p>
<p>比一般的复制方法的实现效率要高很多，很适合用来批量处理数组。Java强烈推荐在复制大量数组元素时用该方法，以取得更高的效率。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h1><ol>
<li><p>注意其三个不同的构造方法。</p>
<p>无参构造方法构造的ArrayList的容量默认为10</p>
<p>带有Collection参数的构造方法</p>
<p>将Collection转化为数组赋给ArrayList的实现数组elementData。</p>
</li>
<li><p>注意扩充容量的方法ensureCapacity。</p>
<p>ArrayList在每次增加元素（可能是1个，也可能是一组）时，都要调用该方法来确保足够的容量。</p>
<p>当容量不足以容纳当前的元素个数时，就设置新的容量为旧的容量的1.5倍加1，</p>
<p>如果设置后的新容量还不够，则直接新容量设置为传入的参数（也就是所需的容量），</p>
<p>而后用Arrays.copyof()方法将元素拷贝到新的数组。</p>
<p>当容量不够时，每次增加元素，都要将原来的元素拷贝到一个新的数组中，非常之耗时，</p>
<p>也因此建议在事先能确定元素数量的情况下，才使用ArrayList，否则建议使用LinkedList。</p>
</li>
<li><p>ArrayList基于数组实现，可以通过下标索引直接查找到指定位置的元素，因此查找效率高，</p>
<p>但每次插入或删除元素，就要大量地移动元素，插入删除元素的效率低。</p>
</li>
<li><p>在查找给定元素索引值等的方法中，源码都将该元素的值分为null和不为null两种情况处理，ArrayList中允许元素为null。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>字节码插桩</title>
    <url>/posts/54605.html</url>
    <content><![CDATA[<h1 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h1><p>实际提供了一种虚拟机级别的aop</p>
<p>java.lang.instrument 包的具体实现，依赖于 </p>
<p>JVMTI（Java Virtual Machine Tool Interface） 这是一套由 Java 虚拟机提供的，为 JVM 相关工具提供的本地编程接口集合。JVMTI 是从 Java SE 5 开始引入，JVMTI 提供了一套“代理”程序机制，可以支持第三方工具程序以代理的方式连接和访问 JVM，并利用 JVMTI 提供的编程接口，完成很多跟 JVM 相关的功能。事实上， </p>
<p>java.lang.instrument 包的实现，也就是基于这种机制的</p>
<p>如上有2个 </p>
<p>premain() 方法，当1个参数和2个参数的premain()的方法同时存在的时候， </p>
<p>premain(String agentArgs) 将被忽略</p>
<p>可以添加任意多个javaagent。所有的java agent会按照你定义的顺序执行</p>
<p>获取某个方法在一段时间内的执行时间</p>
<ol>
<li>在方法前后加时间戳（硬编码）</li>
<li>Spring AOP 切面</li>
<li>字节码插桩（零侵入）</li>
</ol>
<p><img src="../../images/image-20220408151802110-8692977.png" alt=""></p>
<p>ELK统一日志整理，但是追踪复杂</p>
<p>apm（application performance management）</p>
<h1 id="二、技术实现"><a href="#二、技术实现" class="headerlink" title="二、技术实现"></a>二、技术实现</h1><h2 id="字节码插桩用到的技术"><a href="#字节码插桩用到的技术" class="headerlink" title="字节码插桩用到的技术"></a>字节码插桩用到的技术</h2><ol>
<li>javaagent 代理拦截（插桩的入口）</li>
</ol>
<p><img src="../../images/image-20220408151824283.png" alt=""></p>
<p><img src="../../images/image-20220408151834330.png" alt=""></p>
<p>javaagent 动态拦截</p>
<p>spring，dubbo，mybatis，netty 底层都是javassist，javassist和cglib底层都是asm</p>
<p><img src="../../images/image-20220408151848132.png" alt=""></p>
<h2 id="javassist字节码修改工具（怎么插）"><a href="#javassist字节码修改工具（怎么插）" class="headerlink" title="javassist字节码修改工具（怎么插）"></a>javassist字节码修改工具（怎么插）</h2><h3 id="单方法示例"><a href="#单方法示例" class="headerlink" title="单方法示例"></a>单方法示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// javaagent 入口方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String arg, Instrumentation instrumentation)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello, java agent! &quot;</span>);</span><br><span class="line">    <span class="comment">//基于 javaassist 工具, 在运行时修改class字节码，就是所谓的插桩</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPool</span>();</span><br><span class="line">    pool.appendSystemPath();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打印所有的idea 中类</span></span><br><span class="line">    instrumentation.addTransformer(<span class="keyword">new</span> <span class="title class_">ClassFileTransformer</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="type">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="string">&quot;indi/daisy/mock/agent/UserService&quot;</span>.equals(className)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.get(<span class="string">&quot;indi.daisy.mock.agent.UserService&quot;</span>);</span><br><span class="line">                <span class="type">CtMethod</span> <span class="variable">sayHello</span> <span class="operator">=</span> ctClass.getDeclaredMethod(<span class="string">&quot;sayHello&quot;</span>);</span><br><span class="line">                <span class="comment">//1. 复制方法</span></span><br><span class="line">                <span class="type">CtMethod</span> <span class="variable">copy</span> <span class="operator">=</span> CtNewMethod.copy(sayHello, ctClass, <span class="literal">null</span>);</span><br><span class="line">                copy.setName(<span class="string">&quot;sayHello$agent&quot;</span>);</span><br><span class="line">                ctClass.addMethod(copy);</span><br><span class="line">                <span class="comment">//2. 改变原有方法</span></span><br><span class="line">                sayHello.setBody(<span class="string">&quot;        long begin = System.currentTimeMillis();\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;        sayHello$agent($1);\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;        long end = System.currentTimeMillis();\n&quot;</span> +</span><br><span class="line">                        <span class="string">&quot;        System.out.println(end - begin);&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> ctClass.toBytecode();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类所有方法示例"><a href="#类所有方法示例" class="headerlink" title="类所有方法示例"></a>类所有方法示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// javaagent 入口方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">premain</span><span class="params">(String arg, Instrumentation instrumentation)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">String</span> <span class="variable">config</span> <span class="operator">=</span> arg;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ClassPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPool</span>();</span><br><span class="line">    pool.appendSystemPath();</span><br><span class="line"></span><br><span class="line">    instrumentation.addTransformer(<span class="keyword">new</span> <span class="title class_">ClassFileTransformer</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">byte</span>[] transform(ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, <span class="type">byte</span>[] classfileBuffer) <span class="keyword">throws</span> IllegalClassFormatException &#123;</span><br><span class="line">            <span class="keyword">if</span> (className == <span class="literal">null</span> || className.replaceAll(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;.&quot;</span>).startsWith(<span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                className = className.replaceAll(<span class="string">&quot;/&quot;</span>, <span class="string">&quot;.&quot;</span>);</span><br><span class="line">                <span class="type">CtClass</span> <span class="variable">ctClass</span> <span class="operator">=</span> pool.get(className);</span><br><span class="line">                <span class="comment">//获取所有方法</span></span><br><span class="line">                <span class="keyword">for</span> (CtMethod declaredMethod : ctClass.getDeclaredMethods()) &#123;</span><br><span class="line">                    newMethod(declaredMethod);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> ctClass.toBytecode();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CtMethod <span class="title function_">newMethod</span><span class="params">(CtMethod oldMethod)</span> <span class="keyword">throws</span> CannotCompileException, NotFoundException &#123;</span><br><span class="line">    <span class="type">CtMethod</span> <span class="variable">copy</span> <span class="operator">=</span> CtNewMethod.copy(oldMethod, oldMethod.getDeclaringClass(), <span class="literal">null</span>);</span><br><span class="line">    copy.setName(oldMethod.getName() + <span class="string">&quot;$agent&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (oldMethod.getReturnType().equals(CtClass.voidType)) &#123;</span><br><span class="line">        oldMethod.setBody(String.format(voidSource, oldMethod.getName()));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        oldMethod.setBody(String.format(source, oldMethod.getName()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> <span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;        long begin = System.currentTimeMillis();\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;        Object result;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;        try &#123;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;            result = ($w)%s$agent($$);\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;        &#125; finally &#123;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;            long end = System.currentTimeMillis();\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;            System.out.println(end - begin);\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;        &#125;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;        return ($r) result;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;    &#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">voidSource</span> <span class="operator">=</span> <span class="string">&quot;&#123;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;        long begin = System.currentTimeMillis();\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;        try &#123;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;            %s$agent($$);\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;        &#125; finally &#123;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;            long end = System.currentTimeMillis();\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;            System.out.println(end - begin);\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;        &#125;\n&quot;</span> +</span><br><span class="line">        <span class="string">&quot;    &#125;&quot;</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 加密与解密的艺术</title>
    <url>/posts/28372.html</url>
    <content><![CDATA[<h1 id="1-企业应用安全"><a href="#1-企业应用安全" class="headerlink" title="1. 企业应用安全"></a>1. 企业应用安全</h1><p>安全技术目标</p>
<ul>
<li><p>保密性 Confidentiality</p>
</li>
<li><p>完整性 Integrity</p>
</li>
<li><p>可用性 Availability</p>
</li>
<li><p>可靠性 Reliability</p>
</li>
<li><p>抗否认性 Non-Repudiation</p>
</li>
<li><p>可控性</p>
</li>
<li><p>可审查性</p>
</li>
<li><p>认证（鉴别）</p>
</li>
<li><p>访问控制</p>
</li>
</ul>
<p>五类安全服务</p>
<ul>
<li><p>认证鉴别服务，网络交互中，验证收发双方的身份和数据来源</p>
</li>
<li><p>访问控制服务，防止未授权用户非法访问资源，包括用户身份和权限确认</p>
</li>
<li><p>数据保密性服务，防止数据在传输过程中被破解、泄漏</p>
</li>
<li><p>数据完整性服务，防止数据在传输过程中被篡改</p>
</li>
<li><p>抗否认性服务，防止收发双方在执行格子操作后，否认所做的操作</p>
</li>
</ul>
<p>八类安全机制</p>
<p><img src="../../images/image-20210810171117799.png" alt="image-20210810171117799" style="zoom:200%;" /></p>
<p>TCP/IP从字面上看是两个Internet上的网络协议（TCP是传输控制协议，IP是网际协议），但实际上TCP/IP是一组网络协议，通常包括TCP、IP、UDP、ICMP、RIP、TELNET、FTP、SMTP、ARP、TFTP等协议。TCP/IP参考模型由下至上分为网络接口层、网络层、传输层和应用层。</p>
<p><img src="../../images/image-20210810171147221.png" alt="image-20210810171147221" style="zoom:200%;" /></p>
<p>WTLS协议（Wireless Transport Layer Security）,无线传输层安全</p>
<h1 id="2-密码学"><a href="#2-密码学" class="headerlink" title="2. 密码学"></a>2. 密码学</h1><p>密码学在加密算法上大体可分为单向加密算法、对称加密算法、非对称加密算法三大类。</p>
<ul>
<li><p>MD5、SHA算法是单向加密算法的代表，单向加密算法是数据完整性验证的常用算法。</p>
</li>
<li><p>DES算法是对称加密算法的典型代表，对称加密算法是数据存储加密的常用算法。</p>
</li>
<li><p>RSA算法是非对称加密算法的典型代表。非对称加密算法是数据传输加密的常用算法。</p>
</li>
<li><p>相对对称加密算法而言，非对称加密算法在安全级别上等级更高，但非对称加密算法在时间效率上远不如对称加密算法。</p>
</li>
</ul>
<p>密码学历史大体分为三个阶段，手工加密阶段、机械加密阶段和计算机加密阶段。</p>
<p>密码体制（Cipher System）：由明文空间、密文空间、密钥空间、加密算法和解密算法五部分构成</p>
<p>柯克霍夫原则：数据的安全基于密钥而不是算法的保密，系统的安全性取决于密钥，对密钥保密，对算法公开。</p>
<h2 id="密码学分类"><a href="#密码学分类" class="headerlink" title="密码学分类"></a><strong>密码学分类</strong></h2><p>从时间上，密码学可以分为古典密码学和现代密码学</p>
<p>按保密内容的算法划分，受限制算法密码学和基于密钥算法密码学</p>
<p>按密码体制，分为对称密码体制密码学和非对称密码体制密码学。</p>
<p>按明文的处理方法，分为分组密码学和流密码学</p>
<h2 id="各种密码学"><a href="#各种密码学" class="headerlink" title="各种密码学"></a><strong>各种密码学</strong></h2><ul>
<li><p>古典密码：移位和替代</p>
</li>
<li><p>对称密码体制</p>
</li>
</ul>
<p>对称密码体制分为两种：一种是对明文的单个位（或字节）进行加密和解密，称为流密码，又称为序列密码；另一种是把明文信息划分成不同的组（或块）结构，分别对每个组（或块）进行加密和解密，称为分组密码</p>
<ul>
<li><p>非对称密码体制</p>
</li>
<li><p>散列函数</p>
</li>
<li><p>数字签名</p>
</li>
</ul>
<p>完整性、可认证性和不可否认性，正是数字签名的主要特征。</p>
<ul>
<li>公钥基础设施</li>
</ul>
<p>PKI系统由认证中心（Certificate Authority，CA）、数字证书库（Certificate Repository, CR）、密钥备份及恢复系统、证书作废系统，以及应用程序接口（Application Programming Interface，API）五部分组成。其中，认证中心CA和数字证书库是PKI技术的核心</p>
<ul>
<li>PGP、OpenPGP、GPG</li>
</ul>
<h1 id="3-java加密"><a href="#3-java加密" class="headerlink" title="3. java加密"></a>3. java加密</h1><p>Java安全领域总共分为4个部分：</p>
<ul>
<li>JCA（Java CryptographyArchitecture，Java加密体系结构</li>
<li>JCE（Java CryptographyExtension，Java加密扩展包）</li>
<li>JSSE（Java Secure SocketsExtension, Java安全套接字扩展包）</li>
<li>JAAS（Java Authentication andAuthentication Service，Java鉴别与安全服务）<h2 id="java-security包"><a href="#java-security包" class="headerlink" title="java.security包"></a>java.security包</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Provider p : Security.getProviders())&#123;</span><br><span class="line">  System.out.println(p);</span><br><span class="line">  <span class="keyword">for</span>(Map.Entry&lt;Object,Object&gt; entry:p.entrySet())&#123;</span><br><span class="line">  	System.out.println(<span class="string">&quot;\t&quot;</span>+entry.getKey());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用apache commons codec做常用加密解密<br>SecretKey、PublicKey、PrivateKey三大接口继承于Key接口，定义了对称密钥和非对称密钥接口<h2 id="java-crypto包"><a href="#java-crypto包" class="headerlink" title="java.crypto包"></a>java.crypto包</h2><h2 id="java-security-spec包和javax-crypto-spec包"><a href="#java-security-spec包和javax-crypto-spec包" class="headerlink" title="java.security.spec包和javax.crypto.spec包"></a>java.security.spec包和javax.crypto.spec包</h2><h2 id="java-security-cert包"><a href="#java-security-cert包" class="headerlink" title="java.security.cert包"></a>java.security.cert包</h2><h2 id="javax-net-ssl包"><a href="#javax-net-ssl包" class="headerlink" title="javax.net.ssl包"></a>javax.net.ssl包</h2></li>
</ul>
<h1 id="4-辅助工具"><a href="#4-辅助工具" class="headerlink" title="4. 辅助工具"></a>4. 辅助工具</h1><p>加密组件Bouncy Castle</p>
<p>辅助工具Commons Codec</p>
<h1 id="5-Base64-电子邮件传输算法"><a href="#5-Base64-电子邮件传输算法" class="headerlink" title="5. Base64-电子邮件传输算法"></a>5. Base64-电子邮件传输算法</h1><p><img src="../../images/image-20221221104004083.png" alt=""></p>
<p>编码 </p>
<ul>
<li><p>字符串,以字符为单位 -&gt; 对应的字符编码（如ASCII码）。 </p>
</li>
<li><p>字符编码 -&gt; 二进制码。 </p>
</li>
<li><p>二进制码做分组转换，每3个8位二进制码为一组，转换为每4个6位二进制码为一组（不足6位时低位补0）。这是一个分组变化的过程，3个8位二进制码和4个6位二进制码的长度都是24位（3×8=4×6=24）。 </p>
</li>
<li><p>对获得的4个6位二进制码补位，向6位二进制码添加2位高位0，组成4个8位二进制码。 </p>
</li>
<li><p>将获得的4个8位二进制码转换为十进制码。 </p>
</li>
<li><p>将获得的十进制码转换为Base64字符表中对应的字符。 </p>
</li>
<li><p>当原文的二进制码长度不足24位，最终转换为十进制码时也不足4项，这时就需要用等号补位 </p>
</li>
</ul>
<p><img src="../../images/image-20221221104044522.png" alt=""></p>
<p>Bouncy Castle和Commons Codec都提供了Base64算法实现，但是否遵循RFC 2045定义，即在编码后的字符串末尾是否添加回车换行符，是两种实现的唯一差别！ </p>
<p>Bouncy Castle遵循了一般Base64算法编码。 </p>
<p>Commons Codec提供了Base64算法的两种实现标准：一种是遵循一般Base64算法实现；另一种是遵循RFC 2045定义。此外，CommonsCodec还提供了Base64算法的定制实现，可以自定每行字符数和行末符号。同时，Commons Codec还提供了基于Base64算法的输入输出流实现。 </p>
<p>综上所述，单纯的Base64算法在使用上比Commons Codec更具优势。 </p>
<p>Apache的CommonCodec是我们最好的选择！ </p>
<h1 id="6-消息摘要算法——验证数据完整性"><a href="#6-消息摘要算法——验证数据完整性" class="headerlink" title="6. 消息摘要算法——验证数据完整性"></a>6. 消息摘要算法——<strong>验证数据完整性</strong></h1><p>三大类：MD（Message Digest，消息摘要算法）、SHA-1（SecureHash Algorithm，安全散列算法）和HmacMD5（Message Authentication Code，消息认证码算法）。 </p>
<p>MD系列算法包括MD2、MD4和MD5共3种算法；SHA算法主要包括其代表算法SHA-1和SHA-1算法的变种SHA-2系列算法（包含SHA-224、SHA-256、SHA-384和SHA-512）；MAC算法综合了上述两种算法，主要包括HmacMD5、HmacSHA1、HmacSHA256、HmacSHA384和HmacSHA512算法。 </p>
<p>RipeMD系列（包含RipeMD128、RipeMD160、RipeMD256、RipeMD320）、Tiger、GOST3411和Whirlpool算法 </p>
<p>循环冗余校验算法—CRC算法Cyclic Redundancy Check </p>
<p><img src="../../images/image-20221221104126787.png" alt=""></p>
<h1 id="7-对称加密算法——初等数据加密"><a href="#7-对称加密算法——初等数据加密" class="headerlink" title="7. 对称加密算法——初等数据加密"></a>7. <strong>对称加密算法——初等数据加密</strong></h1><p>在对称加密算法中，DES算法最具有代表性，堪称典范；DESede是DES算法的变种；AES算法则作为DES算法的替代者；而IDEA算法作为一种强加密算法，成为电子邮件加密软件PGP（Pretty Good Privacy）的核心算法之一。 </p>
<p>一般密钥材料实现类（SecretKeySpec类） </p>
<p><img src="../../images/image-20221221104216617.png" alt=""></p>
<p>比较典型的有两重DES（2DES）、三重DES（3DES）和四重DES（4DES）等几种形式，但在实际应用中一般采用3DES方案，它还有两个别名Triple DES和DESede </p>
<p>对于DESede算法的填充方式，Java 7提供了NoPadding、PKCS5Padding和ISO10126Padding共3种填充方式 </p>
<p><img src="../../images/image-20221221104248236.png" alt=""></p>
<p><img src="../../images/image-20221221104256185.png" alt=""></p>
<h1 id="8-非对称加密算法——高等数据加密"><a href="#8-非对称加密算法——高等数据加密" class="headerlink" title="8. 非对称加密算法——高等数据加密"></a>8. <strong>非对称加密算法——高等数据加密</strong></h1><p>分类 </p>
<ul>
<li><p>基于因子分解难题。RSA算法是最为典型的非对称加密算法，该算法由美国麻省理工学院（MIT）的Ron Rivest、AdiShamir和Leonard Adleman三位学者提出，并以这三位学者的姓氏开头字母命名，称为RSA算法。RSA算法是当今应用范围最为广泛的非对称加密算法，也是第一个既能用于数据加密也能用于数字签名的算法。 </p>
</li>
<li><p>基于离散对数难题。ElGamal算法由Taher ElGamal提出，以自己的名字命名。该算法既可用于加密/解密，也可用于数字签名，并为数字签名算法形成标准提供参考。美国的DSS（Digital Signature Standard，数据签名标准）的DSA（Digital SignatureAlgorithm，数字签名算法）经ElGamal算法演变而来。 </p>
</li>
</ul>
<p>ECC（Elliptical Curve Cryptography，椭圆曲线加密）算法以椭圆曲线理论为基础，在创建密钥时可做到更快、更小，并且更有效。ECC 算法通过椭圆曲线方程式的性质产生密钥，而不是采用传统的方法利用大质数的积来产生。 </p>
<p><img src="../../images/image-20221221104327118.png" alt=""></p>
<p>对于DH算法而言，算法的安全强度在于密钥长度和对称加密算法的选择。 </p>
<ul>
<li><p>DH算法支持的密钥长度为64的倍数位，取值范围在512～1024位（含1024位）之间。密钥长度与加密安全强度成正比，与运算时间成反比。在使用时，需选择合适的密钥长度。 </p>
</li>
<li><p>对称加密算法可以选择DES、DESede和AES算法等</p>
</li>
</ul>
<h1 id="10-数字证书"><a href="#10-数字证书" class="headerlink" title="10. 数字证书"></a>10. <strong>数字证书</strong></h1><p>数字证书集合了多种密码学算法：自身带有公钥信息，可完成相应的加密/解密操作；同时，还带有数字签名，可鉴别消息来源；且自身带有消息摘要信息，可验证证书的完整性；由于证书本身含有用户身份信息，因而具有认证性。 </p>
<p>证书的签发过程实际上是对申请数字证书的公钥做数字签名，证书的验证过程实际上是对数字证书的公钥做验证签名，其中还包含证书有效期验证。 </p>
<p>目前主要有JKS和PEM两种编码格式文件。 </p>
<ul>
<li><p>JKS（Java Key Store），Java原生的密钥库/信任库文件。 </p>
</li>
<li><p>PEM（Privacy Enbanced Mail，隐私增强邮件）是使用多种加密方法提供机密性、认证和信息完整性的因特网电子邮件，在因特网中却没有被广泛配置，但在OpenSSL中，却是最为常见的密钥库文件。 </p>
</li>
</ul>
<p><img src="../../images/image-20221221104402980.png" alt=""></p>
<p><img src="../../images/image-20221221104425339.png" alt=""></p>
<h1 id="11-安全协议"><a href="#11-安全协议" class="headerlink" title="11.安全协议"></a><strong>11.安全协议</strong></h1><p>SSL/TLS协议包含两个协议：SSL和TLS。 </p>
<ul>
<li><p>SSL（Secure Socket Layer，安全套接字层）：由Netscape（网景）公司研发，位于TCP/IP参考模型中的网络传输层，作为为网络通信提供安全及数据完整性的一种安全协议。 </p>
</li>
<li><p>TLS（Transport Layer Security，传输层安全）：基于SSL协议之上的通用化协议，它同样位于TCP/IP参考模型中的网络传输层，作为SSL协议的继任者，成为下一代网络安全性和数据完整性安全协议。详见文档RFC2246（<a href="http://www.ietf.org/rfc/rfc2246.txt）。">http://www.ietf.org/rfc/rfc2246.txt）。</a> </p>
</li>
</ul>
<p>SSL/TLS协议可分为两层：记录协议和握手协议。 </p>
<ul>
<li><p>记录协议（Record Protocol）：建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 </p>
</li>
<li><p>握手协议（Handshake Protocol）：建立在SSL记录协议之上，用于在实际的数据传输开始前，通信双方进行身份认证、协商加密算法、交换加密密钥等。 </p>
</li>
</ul>
<h2 id="协商算法"><a href="#协商算法" class="headerlink" title="协商算法"></a><strong>协商算法</strong></h2><p>服务器端和客户端进行握手协议的第一阶段主要是协商算法 </p>
<p><img src="../../images/image-20221221104513614.png" alt=""></p>
<h2 id="验证证书"><a href="#验证证书" class="headerlink" title="验证证书"></a><strong>验证证书</strong></h2><p>如果服务器端回复客户端时带有其他信息，则进入数字证书验证阶段。服务器端下发服务器证书给客户端后，由客户端验证该证书（见图11-7），主要包含以下几个步骤： </p>
<ol>
<li><p>服务器回复客户端响应时带有服务器证书。 </p>
</li>
<li><p>客户端将该证书发送至认证机构。 </p>
</li>
<li><p>认证机构验证该证书。 </p>
</li>
<li><p>认证机构回应客户端验证结果，如果验证失败将同时得到警告信息 </p>
</li>
</ol>
<p><img src="../../images/image-20221221104539274.png" alt=""></p>
<h2 id="产生密钥"><a href="#产生密钥" class="headerlink" title="产生密钥"></a><strong>产生密钥</strong></h2><p><img src="../../images/image-20221221104558935.png" alt=""></p>
<p><img src="../../images/image-20221221104620876.png" alt=""></p>
<h2 id="加密交互"><a href="#加密交互" class="headerlink" title="加密交互"></a><strong>加密交互</strong></h2><p><img src="../../images/image-20221221104649482.png" alt=""></p>
<p>单向认证，双向认证 </p>
<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><h2 id="pom"><a href="#pom" class="headerlink" title="pom"></a>pom</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/commons-codec/commons-codec --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-codec<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.bouncycastle/bcprov-jdk15on --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.bouncycastle<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>bcprov-jdk15on<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.64<span class="tag">&lt;/<span class="name">version</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span> </span><br></pre></td></tr></table></figure>
<h2 id="jdk-实现"><a href="#jdk-实现" class="headerlink" title="jdk 实现"></a>jdk 实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.daisy.demo.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.*;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.interfaces.DHPublicKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.DHParameterSpec;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.PBEKeySpec;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.PBEParameterSpec;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.interfaces.RSAPrivateCrtKey;</span><br><span class="line"><span class="keyword">import</span> java.security.interfaces.RSAPublicKey;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.ECGenParameterSpec;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.InvalidKeySpecException;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.X509EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"><span class="keyword">import</span> java.util.zip.CRC32;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: daisyw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span>: 2020/1/20 下午3:27</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CrypUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Charset</span> <span class="variable">UTF8</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据转16进制编码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">encodeHex</span><span class="params">(<span class="keyword">final</span> <span class="type">byte</span>[] data, <span class="keyword">final</span> <span class="type">boolean</span> toLowerCase)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">char</span>[] DIGITS_LOWER = &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">char</span>[] DIGITS_UPPER = &#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>&#125;;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">char</span>[] toDigits = toLowerCase ? DIGITS_LOWER : DIGITS_UPPER;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> data.length;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">char</span>[] out = <span class="keyword">new</span> <span class="title class_">char</span>[l &lt;&lt; <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// two characters form the hex value.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">            out[j++] = toDigits[(<span class="number">0xF0</span> &amp; data[i]) &gt;&gt;&gt; <span class="number">4</span>];</span><br><span class="line">            out[j++] = toDigits[<span class="number">0x0F</span> &amp; data[i]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base64</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">base64Encode</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.getEncoder().encodeToString(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] base64Decode(<span class="type">byte</span>[] src) &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.getDecoder().decode(src);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息摘要算法 md5</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">md5</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = str.getBytes(UTF8);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MessageDigest</span> <span class="variable">digest</span> <span class="operator">=</span> MessageDigest.getInstance(<span class="string">&quot;md5&quot;</span>);</span><br><span class="line">            digest.update(bytes);</span><br><span class="line">            <span class="type">byte</span>[] rsBytes = digest.digest();</span><br><span class="line">            <span class="keyword">return</span> encodeHex(rsBytes, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息摘要算法 sha256</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">sha256</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> shaBase(<span class="string">&quot;SHA-256&quot;</span>, bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">shaBase</span><span class="params">(String sha, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">MessageDigest</span> <span class="variable">digest</span> <span class="operator">=</span> MessageDigest.getInstance(sha);</span><br><span class="line">            digest.update(bytes);</span><br><span class="line">            <span class="type">byte</span>[] rsBytes = digest.digest();</span><br><span class="line">            <span class="keyword">return</span> encodeHex(rsBytes, <span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e.getMessage(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息摘要算法 hmac</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] getHmacKey(String type) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">KeyGenerator</span> <span class="variable">keyGenerator</span> <span class="operator">=</span> KeyGenerator.getInstance(type);</span><br><span class="line">            <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> keyGenerator.generateKey();</span><br><span class="line">            <span class="type">byte</span>[] key = secretKey.getEncoded();</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">encryptHmacSHA256</span><span class="params">(<span class="type">byte</span>[] data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> encryptHmacBase(data, getHmacKey(<span class="string">&quot;HmacSHA256&quot;</span>), <span class="string">&quot;HmacSHA256&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">encryptHmacBase</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">byte</span>[] key, String type)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1、还原密钥</span></span><br><span class="line">            <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key, type);</span><br><span class="line">            <span class="comment">// 2、创建MAC对象</span></span><br><span class="line">            <span class="type">Mac</span> <span class="variable">mac</span> <span class="operator">=</span> Mac.getInstance(type);</span><br><span class="line">            <span class="comment">// 3、设置密钥</span></span><br><span class="line">            mac.init(secretKey);</span><br><span class="line">            <span class="comment">// 4、数据加密</span></span><br><span class="line">            <span class="type">byte</span>[] bytes = mac.doFinal(data);</span><br><span class="line">            <span class="comment">// 5、生成数据</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">rs</span> <span class="operator">=</span> encodeHex(bytes, <span class="literal">true</span>);</span><br><span class="line">            <span class="keyword">return</span> rs;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息摘要算法 ripemd 参见BC实现</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环冗余校验 CRC 8位16进制字符串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">crc32</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="type">CRC32</span> <span class="variable">crc32</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CRC32</span>();</span><br><span class="line">        crc32.update(bytes);</span><br><span class="line">        <span class="keyword">return</span> Long.toHexString(crc32.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对称加密算法 DES 密钥长度56位+8位校验位</span></span><br><span class="line">    <span class="comment">// 填充模式</span></span><br><span class="line">    <span class="comment">// NoPadding、PKCS5Padding、ISO10126Padding</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] desEncrypty(<span class="type">byte</span>[] data) &#123;</span><br><span class="line">        <span class="keyword">return</span> desEncrypt(data, getDesKey(<span class="string">&quot;DES&quot;</span>, <span class="number">56</span>), <span class="string">&quot;DES&quot;</span>, <span class="string">&quot;DES/ECB/ISO10126Padding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] desDecrypty(<span class="type">byte</span>[] data) &#123;</span><br><span class="line">        <span class="keyword">return</span> desDecrypt(data, getDesKey(<span class="string">&quot;DES&quot;</span>, <span class="number">56</span>), <span class="string">&quot;DES&quot;</span>, <span class="string">&quot;DES/ECB/ISO10126Padding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对称加密算法 3DES 默认密钥长度 168 位</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] desedeEncrypty(<span class="type">byte</span>[] data) &#123;</span><br><span class="line">        <span class="keyword">return</span> desEncrypt(data, getDesKey(<span class="string">&quot;DES&quot;</span>, <span class="number">168</span>), <span class="string">&quot;DESede&quot;</span>, <span class="string">&quot;DESede/ECB/ISO10126Padding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] desedeDecrypty(<span class="type">byte</span>[] data) &#123;</span><br><span class="line">        <span class="keyword">return</span> desDecrypt(data, getDesKey(<span class="string">&quot;DES&quot;</span>, <span class="number">168</span>), <span class="string">&quot;DESede&quot;</span>, <span class="string">&quot;DESede/ECB/ISO10126Padding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对称加密算法 AES 默认密钥长度128，192、256 需要获取无政策限制许可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] aesEncrypty(<span class="type">byte</span>[] data) &#123;</span><br><span class="line">        <span class="keyword">return</span> desEncrypt(data, getDesKey(<span class="string">&quot;AES&quot;</span>, <span class="number">128</span>), <span class="string">&quot;DESede&quot;</span>, <span class="string">&quot;AES/ECB/ISO10126Padding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] aesDecrypty(<span class="type">byte</span>[] data) &#123;</span><br><span class="line">        <span class="keyword">return</span> desDecrypt(data, getDesKey(<span class="string">&quot;AES&quot;</span>, <span class="number">128</span>), <span class="string">&quot;DESede&quot;</span>, <span class="string">&quot;AES/ECB/ISO10126Padding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DES base</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] getDesKey(String type, <span class="type">int</span> length) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">KeyGenerator</span> <span class="variable">keyGenerator</span> <span class="operator">=</span> KeyGenerator.getInstance(type);</span><br><span class="line">            keyGenerator.init(length);<span class="comment">//java7只提供到56位</span></span><br><span class="line">            <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> keyGenerator.generateKey();</span><br><span class="line">            <span class="type">byte</span>[] key = secretKey.getEncoded();</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] desEncrypt(<span class="type">byte</span>[] data, <span class="type">byte</span>[] key, String algorithm, String padding) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key, algorithm);</span><br><span class="line">            <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(padding);</span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, secretKey);</span><br><span class="line">            <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] desDecrypt(<span class="type">byte</span>[] data, <span class="type">byte</span>[] key, String algorithm, String padding) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key, algorithm);</span><br><span class="line">            <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(padding);</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, secretKey);</span><br><span class="line">            <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对称加密算法 IDEA 参见BC实现</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对称加密算法 PBE 基于口令加密</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] initSalt() <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">SecureRandom</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecureRandom</span>();</span><br><span class="line">        <span class="keyword">return</span> random.generateSeed(<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Key <span class="title function_">toKey</span><span class="params">(String password)</span> <span class="keyword">throws</span> NoSuchAlgorithmException, InvalidKeySpecException &#123;</span><br><span class="line">        <span class="type">PBEKeySpec</span> <span class="variable">keySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PBEKeySpec</span>(password.toCharArray());</span><br><span class="line">        <span class="type">SecretKeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> SecretKeyFactory.getInstance(<span class="string">&quot;PBEWITHMD5andDES&quot;</span>);</span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> keyFactory.generateSecret(keySpec);</span><br><span class="line">        <span class="keyword">return</span> secretKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] encrypt(<span class="type">byte</span>[] data, String password, <span class="type">byte</span>[] salt) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Key</span> <span class="variable">key</span> <span class="operator">=</span> toKey(password);</span><br><span class="line">        <span class="type">PBEParameterSpec</span> <span class="variable">paramSpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PBEParameterSpec</span>(salt, <span class="number">100</span>);<span class="comment">//迭代次数</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;PBEWITHMD5andDES&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] decrypt(<span class="type">byte</span>[] data, String password, <span class="type">byte</span>[] salt) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Key</span> <span class="variable">key</span> <span class="operator">=</span> toKey(password);</span><br><span class="line">        <span class="type">PBEParameterSpec</span> <span class="variable">paramSpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PBEParameterSpec</span>(salt, <span class="number">100</span>);<span class="comment">//迭代次数</span></span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;PBEWITHMD5andDES&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, key, paramSpec);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非对称加密算法 DH 默认密钥长度是1024,必须是64的倍数，在512到1024位之间</span></span><br><span class="line">    <span class="comment">// -- 本地密钥算法，即对称加密算法。可选des，aes，desede</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SECRET_ALGORITHM</span> <span class="operator">=</span> <span class="string">&quot;AES&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -- 初始化甲方密钥</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> KeyPair <span class="title function_">initKey</span><span class="params">(<span class="type">int</span> size, String algorithm)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">KeyPairGenerator</span> <span class="variable">keyPairGenerator</span> <span class="operator">=</span> KeyPairGenerator.getInstance(algorithm);</span><br><span class="line">        keyPairGenerator.initialize(size);</span><br><span class="line">        <span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> keyPairGenerator.generateKeyPair();</span><br><span class="line">        <span class="keyword">return</span> keyPair;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// -- 初始化乙方密钥</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> KeyPair <span class="title function_">initKey</span><span class="params">(<span class="type">byte</span>[] key, String algorithm)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//解析甲方的公钥</span></span><br><span class="line">        <span class="comment">//转换公钥的材料</span></span><br><span class="line">        <span class="type">X509EncodedKeySpec</span> <span class="variable">x509KeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X509EncodedKeySpec</span>(key);</span><br><span class="line">        <span class="comment">//实例化密钥工厂</span></span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(algorithm);</span><br><span class="line">        <span class="comment">//产生公钥</span></span><br><span class="line">        <span class="type">PublicKey</span> <span class="variable">pubKey</span> <span class="operator">=</span> keyFactory.generatePublic(x509KeySpec);</span><br><span class="line">        <span class="comment">//由甲方的公钥构造乙方密钥</span></span><br><span class="line">        <span class="type">DHParameterSpec</span> <span class="variable">dhParamSpec</span> <span class="operator">=</span> ((DHPublicKey) pubKey).getParams();</span><br><span class="line">        <span class="comment">//实例化密钥生成器</span></span><br><span class="line">        <span class="type">KeyPairGenerator</span> <span class="variable">keyPairGenerator</span> <span class="operator">=</span> KeyPairGenerator.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        <span class="comment">//初始化密钥生成器</span></span><br><span class="line">        keyPairGenerator.initialize(dhParamSpec);</span><br><span class="line">        <span class="comment">//产生密钥对</span></span><br><span class="line">        <span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> keyPairGenerator.genKeyPair();</span><br><span class="line">        <span class="keyword">return</span> keyPair;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] getSecretKey(<span class="type">byte</span>[] publicKey, <span class="type">byte</span>[] privateKey, String algorithm) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//实例化密钥工厂</span></span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(algorithm);</span><br><span class="line">        <span class="comment">//初始化公钥</span></span><br><span class="line">        <span class="comment">//密钥材料转换</span></span><br><span class="line">        <span class="type">X509EncodedKeySpec</span> <span class="variable">x509KeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X509EncodedKeySpec</span>(publicKey);</span><br><span class="line">        <span class="comment">//产生公钥</span></span><br><span class="line">        <span class="type">PublicKey</span> <span class="variable">pubKey</span> <span class="operator">=</span> keyFactory.generatePublic(x509KeySpec);</span><br><span class="line">        <span class="comment">//初始化私钥</span></span><br><span class="line">        <span class="comment">//密钥材料转换</span></span><br><span class="line">        <span class="type">PKCS8EncodedKeySpec</span> <span class="variable">pkcs8KeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PKCS8EncodedKeySpec</span>(privateKey);</span><br><span class="line">        <span class="comment">//产生私钥</span></span><br><span class="line">        <span class="type">PrivateKey</span> <span class="variable">priKey</span> <span class="operator">=</span> keyFactory.generatePrivate(pkcs8KeySpec);</span><br><span class="line">        <span class="comment">//实例化</span></span><br><span class="line">        <span class="type">KeyAgreement</span> <span class="variable">keyAgree</span> <span class="operator">=</span> KeyAgreement.getInstance(keyFactory.getAlgorithm());</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        keyAgree.init(priKey);</span><br><span class="line">        keyAgree.doPhase(pubKey, <span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//生成本地密钥</span></span><br><span class="line">        <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> keyAgree.generateSecret(SECRET_ALGORITHM);</span><br><span class="line">        <span class="keyword">return</span> secretKey.getEncoded();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testDH</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//甲方密钥</span></span><br><span class="line">        <span class="type">KeyPair</span> <span class="variable">keyPair1</span> <span class="operator">=</span> initKey(<span class="number">512</span>, <span class="string">&quot;DH&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] publicKey1 = keyPair1.getPublic().getEncoded();</span><br><span class="line">        <span class="type">byte</span>[] privateKey1 = keyPair1.getPrivate().getEncoded();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//由甲方的公钥产生的密钥对，乙方使用</span></span><br><span class="line">        <span class="type">KeyPair</span> <span class="variable">keyPair2</span> <span class="operator">=</span> initKey(publicKey1, <span class="string">&quot;DH&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] publicKey2 = keyPair2.getPublic().getEncoded();</span><br><span class="line">        <span class="type">byte</span>[] privateKey2 = keyPair2.getPrivate().getEncoded();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//组装甲方的本地加密密钥,由乙方的公钥和甲方的私钥组合而成</span></span><br><span class="line">        <span class="type">byte</span>[] key1 = getSecretKey(publicKey2, privateKey1, <span class="string">&quot;DH&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;甲方的本地密钥：/n&quot;</span> + Base64.getEncoder().encodeToString(key1));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//组装乙方的本地加密密钥，由甲方的公钥和乙方的私钥组合而成</span></span><br><span class="line">        <span class="type">byte</span>[] key2 = getSecretKey(publicKey1, privateKey2, <span class="string">&quot;DH&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;乙方的本地密钥：/n&quot;</span> + Base64.getEncoder().encodeToString(key2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非对称加密 ECDH</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非对称加密 RSA 1024位密钥</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] encryptRsa(<span class="type">byte</span>[] data, <span class="type">byte</span>[] key) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">            <span class="type">X509EncodedKeySpec</span> <span class="variable">x509KeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X509EncodedKeySpec</span>(key);</span><br><span class="line">            <span class="type">RSAPublicKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> (RSAPublicKey) keyFactory.generatePublic(x509KeySpec);</span><br><span class="line">            <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">            cipher.init(Cipher.PUBLIC_KEY, secretKey);</span><br><span class="line">            <span class="type">byte</span>[] rs = cipher.doFinal(data);</span><br><span class="line">            <span class="keyword">return</span> rs;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] decryptRsa(<span class="type">byte</span>[] data, <span class="type">byte</span>[] key) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">            <span class="type">PKCS8EncodedKeySpec</span> <span class="variable">keySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PKCS8EncodedKeySpec</span>(key);</span><br><span class="line">            <span class="type">RSAPrivateCrtKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> (RSAPrivateCrtKey) keyFactory.generatePrivate(keySpec);</span><br><span class="line">            <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">            cipher.init(Cipher.PRIVATE_KEY, secretKey);</span><br><span class="line">            <span class="type">byte</span>[] rs = cipher.doFinal(data);</span><br><span class="line">            <span class="keyword">return</span> rs;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testRSA</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;java小工匠&quot;</span>;</span><br><span class="line">        <span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> initKey(<span class="number">1024</span>, <span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] secretData = encryptRsa(str.getBytes(), keyPair.getPublic().getEncoded());</span><br><span class="line">        System.out.println(<span class="string">&quot;RSA加密:&quot;</span> + encodeHex(secretData, <span class="literal">true</span>));</span><br><span class="line">        <span class="type">byte</span>[] data = decryptRsa(secretData, keyPair.getPrivate().getEncoded());</span><br><span class="line">        System.out.println(<span class="string">&quot;RSA解密:&quot;</span> + <span class="keyword">new</span> <span class="title class_">String</span>(data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非对称加密 EIGamal 参见BC实现</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数字签名 DSA</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 签名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] sign(<span class="type">byte</span>[] data, <span class="type">byte</span>[] privateKey, String type, String algorithm) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 还原使用</span></span><br><span class="line">            <span class="type">PKCS8EncodedKeySpec</span> <span class="variable">pkcs8EncodedKeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PKCS8EncodedKeySpec</span>(privateKey);</span><br><span class="line">            <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(algorithm);</span><br><span class="line">            <span class="type">PrivateKey</span> <span class="variable">priKey</span> <span class="operator">=</span> keyFactory.generatePrivate(pkcs8EncodedKeySpec);</span><br><span class="line">            <span class="comment">// 1、实例化Signature</span></span><br><span class="line">            <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> Signature.getInstance(type);</span><br><span class="line">            <span class="comment">// 2、初始化Signature</span></span><br><span class="line">            signature.initSign(priKey);</span><br><span class="line">            <span class="comment">// 3、更新数据</span></span><br><span class="line">            signature.update(data);</span><br><span class="line">            <span class="comment">// 4、签名</span></span><br><span class="line">            <span class="keyword">return</span> signature.sign();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 验证</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">verify</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">byte</span>[] publicKey, <span class="type">byte</span>[] sign, String type, String algorithm)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">X509EncodedKeySpec</span> <span class="variable">keySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X509EncodedKeySpec</span>(publicKey);</span><br><span class="line">            <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(algorithm);</span><br><span class="line">            <span class="type">PublicKey</span> <span class="variable">pubKey</span> <span class="operator">=</span> keyFactory.generatePublic(keySpec);</span><br><span class="line">            <span class="comment">// 1、实例化Signature</span></span><br><span class="line">            <span class="type">Signature</span> <span class="variable">signature</span> <span class="operator">=</span> Signature.getInstance(type);</span><br><span class="line">            <span class="comment">// 2、初始化Signature</span></span><br><span class="line">            signature.initVerify(pubKey);</span><br><span class="line">            <span class="comment">// 3、更新数据</span></span><br><span class="line">            signature.update(data);</span><br><span class="line">            <span class="comment">// 4、签名</span></span><br><span class="line">            <span class="keyword">return</span> signature.verify(sign);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testDSAsign</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;java小工匠&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] data = str.getBytes();</span><br><span class="line">        <span class="comment">// 初始化密钥度</span></span><br><span class="line">        <span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> initKey(<span class="number">1024</span>, <span class="string">&quot;DSA&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] publicKey = keyPair.getPublic().getEncoded();</span><br><span class="line">        <span class="type">byte</span>[] privateKey = keyPair.getPrivate().getEncoded();</span><br><span class="line">        <span class="comment">// 签名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> <span class="string">&quot;SHAwithDSA&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] sign = sign(str.getBytes(), privateKey, type, <span class="string">&quot;DSA&quot;</span>);</span><br><span class="line">        <span class="comment">// 验证</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> verify(data, publicKey, sign, type, <span class="string">&quot;DSA&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;验证:&quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数字签名 RSA</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRSAsign</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;java小工匠&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] data = str.getBytes();</span><br><span class="line">        <span class="comment">// 初始化密钥度</span></span><br><span class="line">        <span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> initKey(<span class="number">1024</span>, <span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        <span class="type">byte</span>[] publicKey = keyPair.getPublic().getEncoded();</span><br><span class="line">        <span class="type">byte</span>[] privateKey = keyPair.getPrivate().getEncoded();</span><br><span class="line">        <span class="comment">// 签名</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">type</span> <span class="operator">=</span> <span class="string">&quot;MD5withRSA&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] sign = sign(str.getBytes(), privateKey, type, <span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        <span class="comment">// 验证</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> verify(data, publicKey, sign, type, <span class="string">&quot;RSA&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;验证:&quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数字签名 ECDSA</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化密钥对</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> KeyPair <span class="title function_">initKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">KeyPairGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> KeyPairGenerator.getInstance(<span class="string">&quot;EC&quot;</span>);</span><br><span class="line">            <span class="type">ECGenParameterSpec</span> <span class="variable">ecGenParameterSpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ECGenParameterSpec</span>(<span class="string">&quot;secp256k1&quot;</span>);</span><br><span class="line">            generator.initialize(ecGenParameterSpec, <span class="keyword">new</span> <span class="title class_">SecureRandom</span>());</span><br><span class="line">            generator.initialize(<span class="number">256</span>);</span><br><span class="line">            <span class="keyword">return</span> generator.generateKeyPair();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testECDSA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;java小工匠&quot;</span>;</span><br><span class="line">        <span class="type">byte</span>[] data = str.getBytes();</span><br><span class="line">        <span class="comment">// 初始化密钥度</span></span><br><span class="line">        <span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> initKey();</span><br><span class="line">        <span class="type">byte</span>[] publicKey = keyPair.getPublic().getEncoded();</span><br><span class="line">        <span class="type">byte</span>[] privateKey = keyPair.getPrivate().getEncoded();</span><br><span class="line">        <span class="comment">// 签名</span></span><br><span class="line">        <span class="type">byte</span>[] sign = sign(str.getBytes(), privateKey, <span class="string">&quot;SHA256withECDSA&quot;</span>, <span class="string">&quot;EC&quot;</span>);</span><br><span class="line">        <span class="comment">// 验证</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> verify(data, publicKey, sign, <span class="string">&quot;SHA256withECDSA&quot;</span>, <span class="string">&quot;EC&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;验证:&quot;</span> + b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bouncycastle实现"><a href="#bouncycastle实现" class="headerlink" title="bouncycastle实现"></a>bouncycastle实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.daisy.demo.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.crypto.CipherParameters;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.crypto.Digest;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.crypto.digests.MD5Digest;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.crypto.digests.RIPEMD256Digest;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.crypto.digests.SHA256Digest;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.crypto.macs.HMac;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.crypto.params.KeyParameter;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.jce.provider.BouncyCastleProvider;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.util.encoders.Base64;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.util.encoders.Hex;</span><br><span class="line"><span class="keyword">import</span> org.bouncycastle.util.encoders.UrlBase64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Mac;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.DHParameterSpec;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.X509EncodedKeySpec;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: daisyw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span>: 2020/1/20 下午5:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CrypBC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Charset</span> <span class="variable">UTF8</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base64 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">base64Encode</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.toBase64String(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] base64Decode(<span class="type">byte</span>[] src) &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.decode(src);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">base64EncodeToURLSafeString</span><span class="params">(<span class="type">byte</span>[] data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>(UrlBase64.encode(data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息摘要算法 md5 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">md5</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = str.getBytes(UTF8);</span><br><span class="line">        <span class="type">Digest</span> <span class="variable">digest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MD5Digest</span>();</span><br><span class="line">        digest.update(data, <span class="number">0</span>, data.length);</span><br><span class="line">        <span class="type">byte</span>[] rsData = <span class="keyword">new</span> <span class="title class_">byte</span>[digest.getDigestSize()];</span><br><span class="line">        digest.doFinal(rsData, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> Hex.toHexString(rsData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息摘要算法 sha256 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">sha256</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="type">Digest</span> <span class="variable">digest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SHA256Digest</span>();</span><br><span class="line">        digest.update(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">        <span class="type">byte</span>[] rsData = <span class="keyword">new</span> <span class="title class_">byte</span>[digest.getDigestSize()];</span><br><span class="line">        digest.doFinal(rsData, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> Hex.toHexString(rsData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息摘要算法 hmac </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] getHmacSha256Key() &#123;</span><br><span class="line">        <span class="keyword">return</span> CrypUtil.getHmacKey(<span class="string">&quot;HmacSHA256&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">encryptHmacSHA256</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">byte</span>[] key)</span> &#123;</span><br><span class="line">        <span class="type">HMac</span> <span class="variable">hmac</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HMac</span>(<span class="keyword">new</span> <span class="title class_">SHA256Digest</span>());</span><br><span class="line">        hmac.init(<span class="keyword">new</span> <span class="title class_">KeyParameter</span>(key));</span><br><span class="line">        hmac.update(data, <span class="number">0</span>, data.length);</span><br><span class="line">        <span class="type">byte</span>[] rsData = <span class="keyword">new</span> <span class="title class_">byte</span>[hmac.getMacSize()];</span><br><span class="line">        hmac.doFinal(rsData, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> Hex.toHexString(rsData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息摘要算法 ripemd </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">ripemd256</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="type">Digest</span> <span class="variable">digest</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RIPEMD256Digest</span>();</span><br><span class="line">        digest.update(bytes, <span class="number">0</span>, bytes.length);</span><br><span class="line">        <span class="type">byte</span>[] rsData = <span class="keyword">new</span> <span class="title class_">byte</span>[digest.getDigestSize()];</span><br><span class="line">        digest.doFinal(rsData, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> Hex.toHexString(rsData);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对称加密算法 DES 密钥长度56位+8位校验位 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] desEncrypty(<span class="type">byte</span>[] data) &#123;</span><br><span class="line">        <span class="keyword">return</span> desEncrypt(data, getDesKey(<span class="string">&quot;DES&quot;</span>, <span class="number">56</span>), <span class="string">&quot;DES&quot;</span>, <span class="string">&quot;DES/ECB/ISO10126Padding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] desDecrypty(<span class="type">byte</span>[] data) &#123;</span><br><span class="line">        <span class="keyword">return</span> desDecrypt(data, getDesKey(<span class="string">&quot;DES&quot;</span>, <span class="number">56</span>), <span class="string">&quot;DES&quot;</span>, <span class="string">&quot;DES/ECB/ISO10126Padding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对称加密算法 3DES 默认密钥长度 168 位 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] desedeEncrypty(<span class="type">byte</span>[] data) &#123;</span><br><span class="line">        <span class="keyword">return</span> desEncrypt(data, getDesKey(<span class="string">&quot;DES&quot;</span>, <span class="number">168</span>), <span class="string">&quot;DESede&quot;</span>, <span class="string">&quot;DESede/ECB/ISO10126Padding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] desedeDecrypty(<span class="type">byte</span>[] data) &#123;</span><br><span class="line">        <span class="keyword">return</span> desDecrypt(data, getDesKey(<span class="string">&quot;DES&quot;</span>, <span class="number">168</span>), <span class="string">&quot;DESede&quot;</span>, <span class="string">&quot;DESede/ECB/ISO10126Padding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对称加密算法 AES 默认密钥长度128，192、256 需要获取无政策限制许可 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] aesEncrypty(<span class="type">byte</span>[] data) &#123;</span><br><span class="line">        <span class="keyword">return</span> desEncrypt(data, getDesKey(<span class="string">&quot;AES&quot;</span>, <span class="number">128</span>), <span class="string">&quot;DESede&quot;</span>, <span class="string">&quot;AES/ECB/ISO10126Padding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] aesDecrypty(<span class="type">byte</span>[] data) &#123;</span><br><span class="line">        <span class="keyword">return</span> desDecrypt(data, getDesKey(<span class="string">&quot;AES&quot;</span>, <span class="number">128</span>), <span class="string">&quot;DESede&quot;</span>, <span class="string">&quot;AES/ECB/ISO10126Padding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// DES base </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] getDesKey(String type, <span class="type">int</span> length) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Security.addProvider(<span class="keyword">new</span> <span class="title class_">BouncyCastleProvider</span>());</span><br><span class="line">            <span class="type">KeyGenerator</span> <span class="variable">keyGenerator</span> <span class="operator">=</span> KeyGenerator.getInstance(type, <span class="string">&quot;BC&quot;</span>);</span><br><span class="line">            keyGenerator.init(length);<span class="comment">////BC可以又64位密钥 </span></span><br><span class="line">            <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> keyGenerator.generateKey();</span><br><span class="line">            <span class="keyword">return</span> secretKey.getEncoded();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] desEncrypt(<span class="type">byte</span>[] data, <span class="type">byte</span>[] key, String algorithm, String padding) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Security.addProvider(<span class="keyword">new</span> <span class="title class_">BouncyCastleProvider</span>());</span><br><span class="line">            <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key, algorithm);</span><br><span class="line">            <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(padding);</span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, secretKey);</span><br><span class="line">            <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] desDecrypt(<span class="type">byte</span>[] data, <span class="type">byte</span>[] key, String algorithm, String padding) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Security.addProvider(<span class="keyword">new</span> <span class="title class_">BouncyCastleProvider</span>());</span><br><span class="line">            <span class="type">SecretKey</span> <span class="variable">secretKey</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SecretKeySpec</span>(key, algorithm);</span><br><span class="line">            <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(padding);</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, secretKey);</span><br><span class="line">            <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对称加密算法 IDEA 密钥长度128 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] ideaEncrypty(<span class="type">byte</span>[] data) &#123;</span><br><span class="line">        <span class="keyword">return</span> desEncrypt(data, getDesKey(<span class="string">&quot;IDEA&quot;</span>, <span class="number">128</span>), <span class="string">&quot;IDEA&quot;</span>, <span class="string">&quot;IDEA/ECB/ISO10126Padding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] ideaDecrypty(<span class="type">byte</span>[] data) &#123;</span><br><span class="line">        <span class="keyword">return</span> desDecrypt(data, getDesKey(<span class="string">&quot;IDEA&quot;</span>, <span class="number">128</span>), <span class="string">&quot;IDEA&quot;</span>, <span class="string">&quot;IDEA/ECB/ISO10126Padding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对称加密算法 PBE 参见java实现 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非对称加密 RSA 参见java实现 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非对称加密 EIGamal </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> KeyPair <span class="title function_">initKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 加入对BouncyCastle支持 </span></span><br><span class="line">            Security.addProvider(<span class="keyword">new</span> <span class="title class_">BouncyCastleProvider</span>());</span><br><span class="line">            <span class="comment">// 初始化参数生成器 </span></span><br><span class="line">            <span class="type">AlgorithmParameterGenerator</span> <span class="variable">apg</span> <span class="operator">=</span> AlgorithmParameterGenerator.getInstance(<span class="string">&quot;ElGamal&quot;</span>, <span class="string">&quot;BC&quot;</span>);</span><br><span class="line">            apg.init(<span class="number">256</span>);</span><br><span class="line">            <span class="comment">// 生成算法参数 </span></span><br><span class="line">            <span class="type">AlgorithmParameters</span> <span class="variable">params</span> <span class="operator">=</span> apg.generateParameters();</span><br><span class="line">            <span class="comment">// 构建参数 </span></span><br><span class="line">            <span class="type">DHParameterSpec</span> <span class="variable">elParams</span> <span class="operator">=</span> (DHParameterSpec) params.getParameterSpec(DHParameterSpec.class);</span><br><span class="line">            <span class="comment">// 实例化密钥生成器 </span></span><br><span class="line">            <span class="type">KeyPairGenerator</span> <span class="variable">kpg</span> <span class="operator">=</span> KeyPairGenerator.getInstance(<span class="string">&quot;ElGamal&quot;</span>);</span><br><span class="line">            <span class="comment">// 初始化密钥对生成器 </span></span><br><span class="line">            kpg.initialize(elParams, <span class="keyword">new</span> <span class="title class_">SecureRandom</span>());</span><br><span class="line">            <span class="type">KeyPair</span> <span class="variable">keyPair</span> <span class="operator">=</span> kpg.generateKeyPair();</span><br><span class="line"><span class="comment">//            keyPair.getPrivate().getEncoded(); </span></span><br><span class="line"><span class="comment">//            keyPair.getPublic().getEncoded(); </span></span><br><span class="line">            <span class="keyword">return</span> keyPair;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公钥加密 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] encrypt(<span class="type">byte</span>[] data, <span class="type">byte</span>[] key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> <span class="title class_">BouncyCastleProvider</span>());</span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(<span class="string">&quot;ElGamal&quot;</span>);</span><br><span class="line">        <span class="type">X509EncodedKeySpec</span> <span class="variable">x509KeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">X509EncodedKeySpec</span>(key);</span><br><span class="line">        <span class="type">PublicKey</span> <span class="variable">pubKey</span> <span class="operator">=</span> keyFactory.generatePublic(x509KeySpec);</span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;ElGamal&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, pubKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私钥解密 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] decrypt(<span class="type">byte</span>[] data, <span class="type">byte</span>[] key) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Security.addProvider(<span class="keyword">new</span> <span class="title class_">BouncyCastleProvider</span>());</span><br><span class="line">        <span class="type">PKCS8EncodedKeySpec</span> <span class="variable">pkcs8KeySpec</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PKCS8EncodedKeySpec</span>(key);</span><br><span class="line">        <span class="type">KeyFactory</span> <span class="variable">keyFactory</span> <span class="operator">=</span> KeyFactory.getInstance(<span class="string">&quot;ElGamal&quot;</span>);</span><br><span class="line">        <span class="type">PrivateKey</span> <span class="variable">privateKey</span> <span class="operator">=</span> keyFactory.generatePrivate(pkcs8KeySpec);</span><br><span class="line">        <span class="type">Cipher</span> <span class="variable">cipher</span> <span class="operator">=</span> Cipher.getInstance(<span class="string">&quot;ElGamal&quot;</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="commons-codec-实现"><a href="#commons-codec-实现" class="headerlink" title="commons.codec 实现"></a>commons.codec 实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.daisy.demo.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Base64;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.Hex;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.binary.StringUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.digest.DigestUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.digest.HmacAlgorithms;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.codec.digest.HmacUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.Mac;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: daisyw</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@data</span>: 2020/1/20 下午5:35 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CrypCC</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Charset</span> <span class="variable">UTF8</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SI</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">EI</span> <span class="operator">=</span> <span class="number">24</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// base64 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">base64Encode</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64String(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] base64Decode(<span class="type">byte</span>[] src) &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.decodeBase64(src);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  -- CC base64编码，编码长度超过76个字符,添加\r\n 字符进行换行 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">base64EncodeToChunkedStr</span><span class="params">(<span class="type">byte</span>[] data)</span> &#123;</span><br><span class="line">        <span class="type">byte</span>[] bytes = Base64.encodeBase64(data, <span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> StringUtils.newStringUsAscii(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  -- 使用&#x27;-&#x27; 和 &#x27;_&#x27; 下划线替换Base64 编码中的 &#x27;+&#x27; 和 &#x27;/&#x27;,解决 URL传输问题 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">base64EncodeToURLSafeString</span><span class="params">(<span class="type">byte</span>[] data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.encodeBase64URLSafeString(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息摘要算法 md5 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">md5</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DigestUtils.md5Hex(str.getBytes(UTF8));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">md5L16</span><span class="params">(String str)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> md5(str).substring(SI,EI);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息摘要算法 sha256 </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">sha256</span><span class="params">(<span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> DigestUtils.sha256Hex(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息摘要算法 hmac </span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">byte</span>[] getHmacSha256Key() &#123;</span><br><span class="line">        <span class="keyword">return</span> CrypUtil.getHmacKey(<span class="string">&quot;HmacSHA256&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">encryptHmacSHA256</span><span class="params">(<span class="type">byte</span>[] data, <span class="type">byte</span>[] key)</span> &#123;</span><br><span class="line">        <span class="type">Mac</span> <span class="variable">mac</span> <span class="operator">=</span> HmacUtils.getInitializedMac(HmacAlgorithms.HMAC_SHA_256, key);</span><br><span class="line">        <span class="keyword">return</span> Hex.encodeHexString(mac.doFinal(data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 消息摘要算法 ripemd 参见BC实现 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对称加密算法 DES 密钥长度56位+8位校验位 暂无 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对称加密算法 AES 暂无 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对称加密算法 IDEA 参见BC实现 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对称加密算法 PBE 参见java实现 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非对称加密 RSA 参见java实现 </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非对称加密 EIGamal 参见BC实现 </span></span><br><span class="line"></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>阿塞拜疆巴库三日自由行</title>
    <url>/posts/15937.html</url>
    <content><![CDATA[<h1 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h1><p>时间： 10.21 —10.24  4天</p>
<p>花费： 1000AED，约2000RMB</p>
<p>签证：落地签，目前是30USD</p>
<p>交通：当地的公交很不错，坐公交方便而且划算，我们在机场买的公交卡，卡费2马纳特，充值4马纳特，往返机场的大巴，每小时一趟，单程1.3，市内公交有坐过0.3和0.4的，都很方便。google map完全可以解决问题。只需要上车刷卡，所以好像可以几个人共用，不太确定，我们是买了3张。</p>
<p>物价：整体感觉比UAE要贵一点，也可能我们位置在旅游区和步行街，吃饭住宿贵一点，住宿大约600RMB/3人/天，吃饭大约400RMB/3人/顿</p>
<p>气候：这个时候已经有点冷了，需要一件厚点的外套，或者毛衣，我们去的时候没想到那么冷，我在当地买了毛衣，帽子（风吹耳朵冷）还有一条睡裤，用来当秋裤穿，😂</p>
<p>电话卡：5G流量25马纳特（100RMB）</p>
<h1 id="行程路线"><a href="#行程路线" class="headerlink" title="行程路线"></a>行程路线</h1><p><img src="../../images/image-20221027141707341.png" alt="image-20221027141707341"></p>
<p>实际上去的地方要比地图上规划的要少好多，中年少女旅行团保持了老年人的作息，所以有些没赶上直接放弃了。</p>
<p>路线是按顺序的，其实完全可以照着走，但是每天都睡到10点，11点之后出门，吃完饭快2点，各种选择走路比较多的我们，只能放弃一些了。</p>
<ol>
<li>黑达尔阿利耶夫国际机场 ， Heydar Aliyev，机场建的很不错，国家有钱！</li>
<li><p>🌟YARAT当代艺术中心 Contemporary Art Centre，强推，虽然没进去，但是周围环境很漂亮，适合走一走</p>
</li>
<li><p>巴库之眼 ， Baku Eye，一个摩天轮，一般，感觉跟天津之眼一样的</p>
</li>
<li><p>沙希德纪念碑 ， Shahidlar Monument，山上，爬不上去，就远远的看了一眼。</p>
</li>
<li>火焰塔 ， Flame Towers，山上，爬不上去，走哪里都能看到。</li>
<li>阿塞拜疆国家美术馆 ， Azerbaijan National Museum of Art</li>
<li>少女塔 ， Maiden Tower，一座塔，可以看看</li>
<li>巴库老城 ， Baku Old City，适合逛逛，感觉不错</li>
<li>希尔万沙宫殿 ， Shirvanshahs’ Palace，老式的城堡，可以逛一下。</li>
<li>集市广场 ， Market Square，都在一圈，可以逛到。</li>
<li>微型书博物馆 ， Museum of Miniature Books，不大，我喜欢，有趣的。</li>
<li>喷泉广场 ， Fountains Square，路过，不大，拍照走人。</li>
<li>阿塞拜疆国家历史博物馆 ， National Museum of History of Azerbaijan</li>
<li>巴库大道 ， Baku Boulevard，推荐，海边走一走，环境很好，心情都美丽了</li>
<li>Park Bulvar Mall</li>
<li>巴库港购物中心 ， Port Baku Mall</li>
<li>🌟黑达尔阿利耶夫中心 ， Heydar Aliyev Centre，强推，建的很漂亮，各种展都好喜欢，尤其三楼的玩偶，超赞！</li>
<li>马尔达康城堡 ， Mardakan Cast，位置远，没有去</li>
<li>火神庙 ， Fire Temple，位置远，没有去</li>
</ol>
<p>推荐几个我们去了又好玩的景点吧：</p>
<h2 id="YARAT当代艺术中心"><a href="#YARAT当代艺术中心" class="headerlink" title="YARAT当代艺术中心"></a>YARAT当代艺术中心</h2><p>坐公交可以到，其实我们去的时候没有展览，所以压根没开门，但是从这里一路沿海走回老城区，有风有海，真的很美。</p>
<p>这个就是艺术中心，我们去的时候没展览，就没开门，但是沿路走回去，看到了很多漂亮的东西，拍照也超级美的。</p>
<p><img src="../../images/image-20221114182532492.png" alt="image-20221114182532492"></p>
<p>路边的小火车</p>
<p><img src="../../images/image-20221114182037080.png" alt="image-20221114182037080"></p>
<p>海边的艺术展</p>
<p><img src="../../images/image-20221114182311506.png" alt="image-20221114182311506"></p>
<h2 id="黑达尔阿利耶夫中心"><a href="#黑达尔阿利耶夫中心" class="headerlink" title="黑达尔阿利耶夫中心"></a>黑达尔阿利耶夫中心</h2><p>一定要去，强烈推荐，博物馆建的很好，而且展品也很让人喜欢啊～～</p>
<p>设计师是扎哈· 哈迪德，以阿塞拜疆前总统的名字命名。外观是很漂亮的流线型，外观类从地面向天空呈波浪状上升，又缓慢降下，据说设计中没有使用任何一条直线，叹为观止。</p>
<p><img src="../../images/image-20221114182050192.png" alt="image-20221114182050192"></p>
<p>楼梯，拍照很好，好看， 有钱的国家果然建设比较好</p>
<p><img src="../../images/image-20221114182645046.png" alt="image-20221114182645046"></p>
<p>一楼有一些老式汽车的展览，还挺有趣。二楼是建筑结构展览，包括这边出名的几座建筑的小模型，还不错。</p>
<p>没有去地毯博物馆，在这里看到了地毯的结构，漂亮！</p>
<p><img src="../../images/image-20221114181903007.png" alt="image-20221114181903007"></p>
<p>最爱三楼，玩偶博物馆，好棒，栩栩如生的</p>
<p><img src="../../images/image-20221114182214055.png" alt="image-20221114182214055"></p>
<p><img src="../../images/image-20221114182332646.png" alt="image-20221114182332646"></p>
<h2 id="老城区"><a href="#老城区" class="headerlink" title="老城区"></a>老城区</h2><p>老城区不大，常见的景点都在这里，就还好吧。</p>
<p><img src="../../images/image-20221114181755552.png" alt="image-20221114181755552"></p>
<h2 id="微型书博物馆"><a href="#微型书博物馆" class="headerlink" title="微型书博物馆"></a>微型书博物馆</h2><p>房间不大，但是里面确实有很多的东西，还挺有趣的。顺路逛逛，完全没问题的</p>
<p><img src="../../images/image-20221114182024489.png" alt="image-20221114182024489"></p>
<p>还有一套小的四书五经，也是惊喜了。</p>
<p><img src="../../images/image-20221114182609780.png" alt="image-20221114182609780"></p>
<h2 id="意外的惊喜"><a href="#意外的惊喜" class="headerlink" title="意外的惊喜"></a>意外的惊喜</h2><p>无意间在某个地下通道看到的，就手工制图画的展览，大灰狼和小红帽，好有爱～</p>
<p><img src="../../images/image-20221114182443199.png" alt="image-20221114182443199"></p>
<h1 id="住宿排雷"><a href="#住宿排雷" class="headerlink" title="住宿排雷"></a>住宿排雷</h1><p>房间地址Nizami Street 77，房东Ruslan，非常不建议这个房东的任何房子！！！</p>
<p>我们租了3天，3张床的大loft，房租大概250-300美金，我付的AED，950.</p>
<p>这次出门，因为比较懒，所以在看房子的时候没怎么仔细看评价，只是简单挑了一下，然后住到了我曾经住过最不好的房子。（当然，一起去的朋友说她们在摩洛哥住过更差的，直接房间没法睡，睡客厅的）</p>
<p>这次遇到了，就发出来提醒大家一下。</p>
<p>房东名下有很多套房子，当时因为这个选择了他，觉得这种应该是有经营的，不会太差。后来发现好几套都跟我们差不多，下面有不那么明显的差评。</p>
<p>后来综合看了一下。这个房东的房子都有以下的特点。</p>
<p>优点：</p>
<ol>
<li>地理位置都非常好，Nizami Street楼下就是步行街，</li>
<li>他的管理人都还很负责任，一路沟通都很顺利</li>
</ol>
<p>缺点：</p>
<ol>
<li>预定后不可退款，后来才意识到是套路，我们定了3天，要是可以退，怕当天就走了。估计他也清楚自己的房子不行，所以定了这种苛刻的政策。</li>
<li>房子非常老旧，照片要比实际好很多。我们这间，第一次进去，还有好大一股霉味。</li>
<li>家具比较旧，其实沙发坐的还蛮舒服的，但感觉是二手的，床也软的。但是床单，被套都是质量很不好的那种，都有起球，我朋友看了被套里面，说是黑的，得亏我没看，不然怕睡不着了。</li>
<li>房东抠门的不行，洗漱用品什么都没有，毛巾一人一条，我没用，感觉质量不好。最可怕的是！！！洗手间都没有纸巾！！！真的以前从未遇到过</li>
<li>这点很奇怪，他签的租赁合同。收了我100美金的押金，说是退房的时候给。我们早上的飞机，6点要出门，我说可以提前一天晚上，他们不愿意，就最后一天早上5点半来敲门了。。哎，我是速度快的懒人，闹钟都45才响。不过服务态度真的可以，小哥在客厅等了半天，后面也正常退钱。这里坑了，他没给我美金，给了阿塞拜疆马纳特170，后面我去机场兑换，还自己贴了4马纳特。</li>
<li>最后一个坑爹的，我走之后，这个房东还有他的manager都不停的给我发消息让我给5星，我纠结了一下，给了个4星，其实想给3星的，后来觉得算了，毕竟小哥态度挺好，而且我们那么早退房。。。但是我们对房子还是很不满意，所以没理他，最后，房东给了一个Not good的评价我。（大概觉得我会给差评，就恶人先告状一下吧，看来对自己认知还挺准确）</li>
</ol>
<p>现在看来，Airbnb风险比较高，不可控的因素太多了，挑房子还是要小心。后来我在网上关注了下，发现Airbnb可能保护房东比较多，所以以后还是挑一些宽松的政策的吧，至少还能退掉。</p>
]]></content>
      <categories>
        <category>旅行</category>
      </categories>
      <tags>
        <tag>旅行</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Analyst</title>
    <url>/posts/42467.html</url>
    <content><![CDATA[<h1 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h1><h2 id="Defination"><a href="#Defination" class="headerlink" title="Defination"></a>Defination</h2><p>Attribute: A characteristic or quality of data used to label a column in a table</p>
<p>Business task: The question or problem data analysis resolves for a business</p>
<p>Context: The condition in which something exists or happens</p>
<p>Data: A collection of facts</p>
<p>Data analysis: The collection, transformation, and organization of data in order to draw<br>conclusions, make predictions, and drive informed decision-making</p>
<p>Data analyst: Someone who collects, transforms, and organizes data in order to draw<br>conclusions, make predictions, and drive informed decision-making</p>
<p>Data analytics: The science of data</p>
<p>Data design: How information is organized</p>
<p>Data-driven decision-making: Using facts to guide business strategy</p>
<p>Data ecosystem: The various elements that interact with one another in order to produce,<br>manage, store, organize, analyze, and share data</p>
<p>Data science: A field of study that uses raw data to create new ways of modeling and<br>understanding the unknown</p>
<p>Data strategy: The management of the people, processes, and tools used in data analysis</p>
<p>Data visualization: The graphical representation of data</p>
<p>Database: A collection of data stored in a computer system</p>
<p>Dataset: A collection of data that can be manipulated or analyzed as one unit</p>
<p>Fairness: A quality of data analysis that does not create or reinforce bias</p>
<p>Formula: A set of instructions used to perform a calculation using the data in a spreadsheet</p>
<p>Function: A preset command that automatically performs a specified process or task using<br>the data in a spreadsheet</p>
<p>Gap analysis: A method for examining and evaluating the current state of a process in order to<br>identify opportunities for improvement in the future</p>
<p>Observation: The attributes that describe a piece of data contained in a row of a table</p>
<p>Query: A request for data or information from a database</p>
<p>Query language: A computer programming language used to communicate with a database</p>
<p>Root cause: The reason why a problem occurs</p>
<p>Stakeholders: People who invest time and resources into a project and are interested in its<br>outcome</p>
<p>Technical mindset: The ability to break things down into smaller steps or pieces and work with<br>them in an orderly and logical way</p>
<p>Visualization: (Refer to data visualization)</p>
<h2 id="data-analysis-life-cycle"><a href="#data-analysis-life-cycle" class="headerlink" title="data analysis life cycle"></a>data analysis life cycle</h2><ol>
<li><strong>Ask</strong>: Business Challenge/Objective/Question</li>
<li><strong>Prepare</strong>: Data generation, collection, storage, and data management</li>
<li><strong>Process</strong>: Data cleaning/data integrity</li>
<li><strong>Analyze</strong>: Data exploration, visualization, and analysis</li>
<li><strong>Share</strong>: Communicating and interpreting results </li>
<li><strong>Act</strong>: Putting your insights to work to solve the problem</li>
</ol>
<h2 id="Key-data-analyst-skills"><a href="#Key-data-analyst-skills" class="headerlink" title="Key data analyst skills"></a>Key data analyst skills</h2><p>Analytical skills: Qualities and characteristics associated with using facts to solve problems</p>
<ol>
<li>Curiosity</li>
<li>Understanding Context</li>
<li>Having a technical mindset</li>
<li>Data design</li>
<li>Data strategy</li>
</ol>
<h2 id="Analytical-thinking"><a href="#Analytical-thinking" class="headerlink" title="Analytical thinking"></a>Analytical thinking</h2><p>Analytical thinking: The process of identifying and defining a problem, then solving it by using<br>data in an organized, step-by-step manner</p>
<ol>
<li>Visualization 可视化</li>
<li>Strategy 战略</li>
<li>Problem-orientation 问题导向</li>
<li>Correlation 相关性</li>
<li>Big-picture and detail-oriented thinking 大局和细节思维</li>
</ol>
<h2 id="The-life-cycle-of-data"><a href="#The-life-cycle-of-data" class="headerlink" title="The life cycle of data"></a>The life cycle of data</h2><ol>
<li><strong>Plan:</strong> Decide what kind of data is needed, how it will be managed, and who will be responsible for it.</li>
<li><strong>Capture:</strong> Collect or bring in data from a variety of different sources.</li>
<li><strong>Manage:</strong> Care for and maintain the data. This includes determining how and where it is stored and the tools used to do so.</li>
<li><strong>Analyze:</strong> Use the data to solve problems, make decisions, and support business goals.</li>
<li><strong>Archive:</strong> Keep relevant data stored for long-term and future reference.</li>
<li><strong>Destroy:</strong> Remove data from storage and delete any shared copies of the data.</li>
</ol>
<h3 id="Harvard-Business-School-HBS"><a href="#Harvard-Business-School-HBS" class="headerlink" title="Harvard Business School (HBS)"></a>Harvard Business School (HBS)</h3><p>One final data life cycle informed by Harvard University research has eight stages:</p>
<ol>
<li>Generation</li>
<li>Collection</li>
<li>Processing</li>
<li>Storage </li>
<li>Management</li>
<li>Analysis</li>
<li>Visualization</li>
<li>Interpretation</li>
</ol>
<h2 id="key-data-analyst-tools"><a href="#key-data-analyst-tools" class="headerlink" title="key data analyst tools"></a>key data analyst tools</h2><ul>
<li>Spreadsheets</li>
<li>database and query languages</li>
<li>Visualization tools: Tableau and Looker<ul>
<li>Programming language (R with RStudio) </li>
</ul>
</li>
</ul>
<h3 id="Steps-to-plan-a-data-visualization"><a href="#Steps-to-plan-a-data-visualization" class="headerlink" title="Steps to plan a data visualization"></a>Steps to plan a data visualization</h3><ol>
<li>Explore the data for patterns</li>
<li>Plan your visuals</li>
<li>Create your visuals</li>
</ol>
<h2 id="Decoding-the-job-description"><a href="#Decoding-the-job-description" class="headerlink" title="Decoding the job description"></a>Decoding the job description</h2><p><img src="../../images/image-20230508234143217.png" alt="image-20230508234143217"></p>
<h2 id="Job-specializations-by-industry"><a href="#Job-specializations-by-industry" class="headerlink" title="Job specializations by industry"></a>Job specializations by industry</h2><ul>
<li>Marketing analyst — analyzes market conditions to assess the potential sales of products and services </li>
<li>HR/payroll analyst — analyzes payroll data for inefficiencies and errors</li>
<li>Financial analyst — analyzes financial status by collecting, monitoring, and reviewing data</li>
<li>Risk analyst — analyzes financial documents, economic conditions, and client data to help companies determine the level of risk involved in making a particular business decision</li>
<li>Healthcare analyst — analyzes medical data to improve the business aspect of hospitals and medical facilities</li>
</ul>
<h1 id="Ask"><a href="#Ask" class="headerlink" title="Ask"></a>Ask</h1><h2 id="Data-analysts-typically-work-with-six-problem-types"><a href="#Data-analysts-typically-work-with-six-problem-types" class="headerlink" title="Data analysts typically work with six problem types"></a>Data analysts typically work with six problem types</h2><p><img src="../../images/image-20230509110930529.png" alt="image-20230509110930529"></p>
<h2 id="Highly-effective-questions-are-SMART-questions"><a href="#Highly-effective-questions-are-SMART-questions" class="headerlink" title="Highly effective questions are SMART questions"></a>Highly effective questions are SMART questions</h2><p><img src="../../images/image-20230509111522131.png" alt="image-20230509111522131"></p>
<h2 id="Qualitative-and-quantitative-data"><a href="#Qualitative-and-quantitative-data" class="headerlink" title="Qualitative and quantitative data"></a>Qualitative and quantitative data</h2><p><img src="../../images/image-20230509154721963.png" alt="image-20230509154721963"></p>
<h1 id="Prepare-Data"><a href="#Prepare-Data" class="headerlink" title="Prepare Data"></a>Prepare Data</h1><h2 id="Data-Collection-considerations"><a href="#Data-Collection-considerations" class="headerlink" title="Data Collection considerations"></a>Data Collection considerations</h2><p><img src="../../images/image-20230510110436286.png" alt="*image-20230510110436286*"></p>
<h2 id="Data-Format"><a href="#Data-Format" class="headerlink" title="Data Format"></a>Data Format</h2><p><img src="../../images/image-20230510110950937.png" alt="image-20230510110950937"></p>
<p><img src="../../images/image-20230510110958081.png" alt="image-20230510110958081"></p>
<p><img src="../../images/image-20230510111006469.png" alt="image-20230510111006469"></p>
<p><img src="../../images/image-20230510111006469-9343224.png" alt="image-20230510111006469"></p>
<p><img src="../../images/image-20230510111021482.png" alt="image-20230510111021482"></p>
<p><img src="../../images/image-20230510111028441.png" alt="image-20230510111028441"></p>
<p><img src="../../images/image-20230510111035968.png" alt="image-20230510111035968"></p>
<p><img src="../../images/image-20230510111507513.png" alt="image-20230510111507513"></p>
<h2 id="Data-modeling-levels-and-techniques"><a href="#Data-modeling-levels-and-techniques" class="headerlink" title="Data modeling levels and techniques"></a>Data modeling levels and techniques</h2><p><img src="../../images/image-20230510111933322.png" alt="image-20230510111933322"></p>
<ul>
<li>Entity Relationship Diagram (ERD)</li>
<li>Unified Modeling Language (UML)</li>
</ul>
<h1 id="For-Resume"><a href="#For-Resume" class="headerlink" title="For Resume"></a>For Resume</h1><h2 id="soft-skills"><a href="#soft-skills" class="headerlink" title="soft skills"></a>soft skills</h2><p><img src="../../images/image-20230510162450331.png" alt="*image-20230510162450331*"></p>
]]></content>
      <categories>
        <category>data</category>
      </categories>
      <tags>
        <tag>data</tag>
      </tags>
  </entry>
  <entry>
    <title>使用nacos做配置中心</title>
    <url>/posts/59136.html</url>
    <content><![CDATA[<h2 id="一、nacos项目集成"><a href="#一、nacos项目集成" class="headerlink" title="一、nacos项目集成"></a>一、nacos项目集成</h2><p>选择springcloud的方式集成，spring/spring boot需要用@NacosValue注解</p>
<h3 id="1-增加pom-需要注意版本对应关系"><a href="#1-增加pom-需要注意版本对应关系" class="headerlink" title="1. 增加pom, 需要注意版本对应关系"></a>1. 增加pom, 需要注意版本对应关系</h3><p><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E</a><br>    此处springboot版本为2.3.2.RELEASE</p>
<p>springboot 2.1.7   &lt;==&gt;  nacos  2.1.2</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">version</span>&gt;</span>2.3.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2-配置文件修改"><a href="#2-配置文件修改" class="headerlink" title="2. 配置文件修改"></a>2. 配置文件修改</h3><p><img src="../../images/image-20221117163123247.png" alt=""></p>
<p>bootstrap.properties 增加nacos相关修改</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment">##dataid $&#123;prefix&#125;-$&#123;spring.profiles.active&#125;.$&#123;file-extension&#125;</span></span><br><span class="line"><span class="comment">#两个配置意义相同，配一个即可，代表对应配置文件</span></span><br><span class="line"><span class="comment">## spring.application.name=nacos</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.prefix</span>=<span class="string">greencode</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.file-extension</span>=<span class="string">properties</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">## nacos group，代表项目</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.group</span>=<span class="string">LOCAL</span></span><br><span class="line"><span class="comment">## nacosserveraddr</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.server-addr</span>=<span class="string">127.0.0.1:8848,127.0.0.1:8849,127.0.0.1:8850</span></span><br><span class="line"><span class="comment">## nacos的namespace，需要使用id,用来隔离环境，默认会使用保留命名空间，public</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.namespace</span>=<span class="string">14173c25-a156-452c-bed5-6ee4cd4bf972</span></span><br><span class="line"><span class="comment">## nacos开关</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.refresh-enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="comment">## nacos账号</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.username</span>=<span class="string">nacos</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.password</span>=<span class="string">nacos</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[0].group</span>=<span class="string">DEFAULT_GROUP</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[0].data-id</span>=<span class="string">mongo.properties</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[0].refresh</span>=<span class="string">true</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[1].group</span>=<span class="string">DEFAULT_GROUP</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[1].data-id</span>=<span class="string">redis.properties</span></span><br><span class="line"><span class="attr">spring.cloud.nacos.config.extension-configs[1].refresh</span>=<span class="string">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-自动刷新配置，需要增加注解-RefreshScope"><a href="#3-自动刷新配置，需要增加注解-RefreshScope" class="headerlink" title="3. 自动刷新配置，需要增加注解 @RefreshScope"></a>3. 自动刷新配置，需要增加注解 @RefreshScope</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">## 实际调用</span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">ConfigurableApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">applicationContext.getEnvironment().getProperty(<span class="string">&quot;common.name&quot;</span>);</span><br></pre></td></tr></table></figure>
<h2 id="二、-nacos服务搭建"><a href="#二、-nacos服务搭建" class="headerlink" title="二、 nacos服务搭建"></a>二、 nacos服务搭建</h2><ol>
<li>java环境，jdk 1.8+，maven 3.2+</li>
<li>使用了nacos1.3.2版本</li>
<li>集群版默认需要至少3个服务</li>
<li>需要连接数据库，此处使用了mysql，nacos有自带的初始化sql文件，需要手动添加</li>
<li>docker中使用需要对应配置</li>
</ol>
<p>参考文档：<a href="https://blog.csdn.net/Alfalfa99/article/details/108042109">https://blog.csdn.net/Alfalfa99/article/details/108042109</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 拉取镜像</span></span></span><br><span class="line">docker pull nacos/nacos-server</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 执行mysql，有固定mysql，执行即可</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># mysql 目录/home/nacos/conf/schema.sql</span></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 启动镜像命令</span></span></span><br><span class="line">docker run -d \</span><br><span class="line">-e PREFER_HOST_MODE=hostname \</span><br><span class="line">-e MODE=cluster \</span><br><span class="line">-e NACOS_APPLICATION_PORT=8847 \</span><br><span class="line">-e NOCOS_SERVERS=&quot;192.168.1.1:8846 192.168.1.1:8847 192.168.1.1:8848&quot; \</span><br><span class="line">-e SPRING_DATASOURCE_PLATFORM=mysql \</span><br><span class="line">-e MYSQL_SERVICE_HOST=192.168.1.1 \</span><br><span class="line">-e MYSQL_SERVICE_PORT=3306 \</span><br><span class="line">-e MYSQL_SERVICE_USER=root \</span><br><span class="line">-e MYSQL_SERVICE_PASSWORD=1234 \</span><br><span class="line">-e NACOS_SERVER_IP=192.168.1.1 \</span><br><span class="line">-p 8847:8847 \</span><br><span class="line">--name my-nacos2 \</span><br><span class="line">nacos/nacos-server</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 可以使用nginx代理域名</span></span></span><br></pre></td></tr></table></figure>
<h2 id="三、具体使用过程中的问题"><a href="#三、具体使用过程中的问题" class="headerlink" title="三、具体使用过程中的问题"></a>三、具体使用过程中的问题</h2><ol>
<li><p>默认账号密码 naocs，nacos</p>
</li>
<li><p>nacos配置最好加上注释</p>
</li>
<li><p>数据库尽可能使用extention 配置</p>
</li>
<li><p>nacos data model</p>
<p><img src="../../images/image-20210915192442006-8688545.png" style="zoom:50%;" /></p>
</li>
</ol>
<ol>
<li><p>页面支持导入导出</p>
<p><img src="../../images/image-20210914194351380-2771527-2771900.png" alt=""></p>
</li>
<li><p>nacos支持open api 发布获取配置</p>
<ol>
<li>curl -X GET ‘<a href="http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.example&amp;group=com.alibaba.nacos">http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.example&amp;group=com.alibaba.nacos</a>‘ </li>
<li>curl -X POST ‘<a href="http://127.0.0.1:8848/nacos/v1/cs/configs">http://127.0.0.1:8848/nacos/v1/cs/configs</a>‘ -d ‘dataId=nacos.example&amp;group=com.alibaba.nacos&amp;content=contentTest’ </li>
<li>curl -X DELETE ‘<a href="http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.example&amp;group=com.alibaba.nacos">http://127.0.0.1:8848/nacos/v1/cs/configs?dataId=nacos.example&amp;group=com.alibaba.nacos</a>‘ </li>
</ol>
</li>
<li><p>nacos 关闭log的配置</p>
<p>logging.level.com.alibaba.nacos=warn</p>
</li>
<li><p>有时候会提示有问题，但其实是没问题的，用的时候注意</p>
</li>
<li><p>虽然实时生效，但有一部分加载到bean里的配置，需要重启才能生效</p>
</li>
<li><p>支持关闭登陆</p>
</li>
</ol>
<p><img src="../../images/image-20210915193301861.png" alt=""></p>
<ol>
<li><p>nacos 配置的优先级</p>
<p><img src="../../images/image-20210915195154493.png" alt=""></p>
</li>
<li><p>spring boot 配置优先级</p>
<p>命令行参数 &gt; 操作系统环境变量 &gt; 应用外的配置文件 &gt; 应用内的配置文件</p>
<p>Nacos &gt;  操作系统环境变量 &gt; 应用内的配置文件</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring.config.location` &gt; `spring.profiles.active` &gt; `spring.config.additional-location` &gt; 默认的 `application.proerties</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    config:</span><br><span class="line">      # 是否允许本地配置覆盖远程配置，默认true</span><br><span class="line">      allow-override: true</span><br><span class="line">      # 是否一切以本地配置为准，默认false</span><br><span class="line">      override-none: false</span><br><span class="line">      # 系统环境变量或系统属性才能覆盖远程配置文件的配置</span><br><span class="line">      # 本地配置文件中配置的优先级低于远程配置，默认true</span><br><span class="line">      override-system-properties: true</span><br></pre></td></tr></table></figure>
<ol>
<li>spring cloud nacos目前只支持 <code>properties</code> 和 <code>yaml</code> 类型</li>
</ol>
<h2 id="四、为什么使用配置中心"><a href="#四、为什么使用配置中心" class="headerlink" title="四、为什么使用配置中心"></a>四、为什么使用配置中心</h2><h4 id="配置加载方式"><a href="#配置加载方式" class="headerlink" title="配置加载方式"></a>配置加载方式</h4><p>程序内hard code</p>
<p>配置文件</p>
<p>环境变量</p>
<p>启动参数</p>
<p>基于数据库</p>
<h4 id="单体架构的好处"><a href="#单体架构的好处" class="headerlink" title="单体架构的好处"></a>单体架构的好处</h4><p>开发效率高，容易测试，容易部署，</p>
<h4 id="大规模复杂应用——单体架构"><a href="#大规模复杂应用——单体架构" class="headerlink" title="大规模复杂应用——单体架构"></a>大规模复杂应用——单体架构</h4><p>复杂性变高，可维护性变差</p>
<p>版本迭代慢</p>
<p>阻碍技术创新</p>
<p>无法按需伸缩</p>
<h4 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h4><p>职责单一，易于开发理解和维护，方便拆分管理</p>
<p>可伸缩</p>
<p>局部修改容易替换部署，有利于持续集成和快速迭代</p>
<p>不受限于技术栈</p>
<h4 id="传统配置的问题"><a href="#传统配置的问题" class="headerlink" title="传统配置的问题"></a>传统配置的问题</h4><p>格式不标准，不够统一</p>
<p>修改麻烦，容易弄错</p>
<p>缺乏安全审计和版本控制</p>
<h4 id="目前我们配置需求"><a href="#目前我们配置需求" class="headerlink" title="目前我们配置需求"></a>目前我们配置需求</h4><p>交付项目和配置分离</p>
<p>抽象和标准化的使用配置</p>
<p>多环境多集群的支持</p>
<p>高可用</p>
<p>实时性</p>
<p>治理：配置审计、版本、权限控制、灰度发布</p>
<h4 id="配置分类"><a href="#配置分类" class="headerlink" title="配置分类"></a>配置分类</h4><p><img src="../../images/image-20220121174141040.png" alt=""></p>
<h2 id="五、选型说明"><a href="#五、选型说明" class="headerlink" title="五、选型说明"></a>五、选型说明</h2><ul>
<li>对比spring cloud config，apollo，nacos后选择nacos</li>
<li>spring cloud config 各方面都相对一般</li>
<li>apollo与nacos对比，整体相差不大（nacos已经支持权限管理），nacos部署使用相对容易，所以最终选用了nacos</li>
</ul>
<p><img src="../../images/image-20210810110046415-2771332-2771817.png" alt=""></p>
<p><img src="../../images/image-20210915190609020-2771802.png" alt=""></p>
<p><img src="../../images/image-20210915190644748.png" alt=""></p>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
      <tags>
        <tag>spring cloud</tag>
        <tag>nacos</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出HTTPS</title>
    <url>/posts/26010.html</url>
    <content><![CDATA[<h2 id="一、HTTP介绍"><a href="#一、HTTP介绍" class="headerlink" title="一、HTTP介绍"></a>一、HTTP介绍</h2><h3 id="1-1-什么是web"><a href="#1-1-什么是web" class="headerlink" title="1.1 什么是web"></a>1.1 什么是web</h3><p>HTTP（HyperText Transfer Protocol，超文本传输协议 </p>
<p>URL的官方名称叫作统一资源标识符（Uniform ResourceLocator） </p>
<p>80是HTTP协议的默认端口 </p>
<p>HTML超文本标记语言 </p>
<h3 id="1-2-理解HTTP"><a href="#1-2-理解HTTP" class="headerlink" title="1.2 理解HTTP"></a>1.2 理解HTTP</h3><p>HTTP的模型很简单，是一个B/S模型，由客户端和服务器组成，交互流程很简单。 </p>
<ul>
<li><p>◎一个HTTP客户端发送请求至HTTP服务器，然后等待服务器的响应。 </p>
</li>
<li><p>◎一个HTTP服务器负责监听端口（默认是80），然后等待客户端的请求，处理完成后，回复给客户端。 </p>
</li>
</ul>
<p>HTTP消息由三部分组成。 </p>
<ul>
<li><p>◎请求行或响应行。 </p>
</li>
<li><p>◎HTTP头部。 </p>
</li>
<li><p>◎HTML实体，包括请求实体和响应实体。 </p>
</li>
</ul>
<h3 id="1-3-网络模型"><a href="#1-3-网络模型" class="headerlink" title="1.3 网络模型"></a>1.3 网络模型</h3><p>应用层：HTTP，FTP，邮件协议 </p>
<p>传输层：TCP，UDP </p>
<p>网络层：IP </p>
<p>链路层：以太网包头 </p>
<h3 id="1-4-协议安全分析"><a href="#1-4-协议安全分析" class="headerlink" title="1.4 协议安全分析"></a>1.4 协议安全分析</h3><h3 id="1-5-web应用安全"><a href="#1-5-web应用安全" class="headerlink" title="1.5 web应用安全"></a>1.5 web应用安全</h3><h2 id="二、密码学"><a href="#二、密码学" class="headerlink" title="二、密码学"></a>二、密码学</h2><p>OpenSSL </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">openssl version </span><br><span class="line">openssl help </span><br><span class="line">openssl rsa --help </span><br><span class="line">man rsa </span><br></pre></td></tr></table></figure>
<h3 id="2-1-密码学认知"><a href="#2-1-密码学认知" class="headerlink" title="2.1 密码学认知"></a>2.1 密码学认知</h3><p>目标 </p>
<ul>
<li>机密性 </li>
<li>完整性 </li>
<li>身份验证 </li>
<li>不可抵赖性 </li>
</ul>
<h3 id="2-2-随机数"><a href="#2-2-随机数" class="headerlink" title="2.2 随机数"></a>2.2 随机数</h3><h3 id="2-3-hash算法"><a href="#2-3-hash算法" class="headerlink" title="2.3 hash算法"></a>2.3 hash算法</h3><h3 id="2-4-对称加密算法"><a href="#2-4-对称加密算法" class="headerlink" title="2.4 对称加密算法"></a>2.4 对称加密算法</h3><p>块密码算法： </p>
<pre><code>AES，DES,3DES,Blowfish,Rijndael,Camellia,IDEA,SEED 

迭代模式 

ECB,CBC,CTR,CFB,OFB,XTS 
</code></pre><p>流密码算法 </p>
<pre><code>RC4，ChaCha 
</code></pre><h3 id="2-5-消息验证码"><a href="#2-5-消息验证码" class="headerlink" title="2.5 消息验证码"></a>2.5 消息验证码</h3><p>AE(Authenticated Encryption)加密模式 </p>
<pre><code>Encrypt-and-MAC (E&amp;M) 

MAC-then-Encrypt (MtE) 

Encrypt-then-MAC (EtM) 
</code></pre><p>AEAD (AE with Associated Data)加密模式 </p>
<pre><code>CCM模式 

GCM 

ChaCha20-Poly1305 
</code></pre><h3 id="2-6-公开秘钥算法"><a href="#2-6-公开秘钥算法" class="headerlink" title="2.6 公开秘钥算法"></a>2.6 公开秘钥算法</h3><h3 id="2-7-密钥"><a href="#2-7-密钥" class="headerlink" title="2.7 密钥"></a>2.7 密钥</h3><h3 id="2-8-密钥协商算法"><a href="#2-8-密钥协商算法" class="headerlink" title="2.8 密钥协商算法"></a>2.8 密钥协商算法</h3><h3 id="2-9-椭圆曲线"><a href="#2-9-椭圆曲线" class="headerlink" title="2.9 椭圆曲线"></a>2.9 椭圆曲线</h3><h3 id="2-10-数字签名"><a href="#2-10-数字签名" class="headerlink" title="2.10 数字签名"></a>2.10 数字签名</h3><h3 id="2-11-DSA数字签名算法"><a href="#2-11-DSA数字签名算法" class="headerlink" title="2.11 DSA数字签名算法"></a>2.11 DSA数字签名算法</h3><h3 id="2-12-算法安全性与性能"><a href="#2-12-算法安全性与性能" class="headerlink" title="2.12 算法安全性与性能"></a>2.12 算法安全性与性能</h3><h2 id="三、宏观理解TLS-Transport-Layer-Security"><a href="#三、宏观理解TLS-Transport-Layer-Security" class="headerlink" title="三、宏观理解TLS (Transport Layer Security)"></a>三、宏观理解TLS (Transport Layer Security)</h2><p>TLS/SSL协议位于应用层协议和TCP之间 </p>
<p>四个目标 </p>
<ul>
<li>数据是机密的 </li>
<li>可操作性 </li>
<li>可扩展性 </li>
<li>效率 </li>
</ul>
<h3 id="3-1-TLS-SSL协议综述"><a href="#3-1-TLS-SSL协议综述" class="headerlink" title="3.1 TLS/SSL协议综述"></a>3.1 TLS/SSL协议综述</h3><p>HTTPS = HTTP + TLS/SSL </p>
<p>TLS/SSL协议核心就三大步骤：认证、密钥协商、数据加密 </p>
<h3 id="3-2-TLS-SSL背后算法"><a href="#3-2-TLS-SSL背后算法" class="headerlink" title="3.2 TLS/SSL背后算法"></a>3.2 TLS/SSL背后算法</h3><p>申请证书流程是非常复杂的，大体流程如下： </p>
<pre><code>◎服务器实体希望发布一个HTTPS网站（https://www.example.com）。 

◎服务器实体生成公开密钥算法的一对密钥，比如一对RSA密钥。 

◎服务器实体生成一个CSR（Cerificate Signing Request）文件，CSR是证书签名请求文件，其中包含的重要信息是网站的域名（www.example.com）、RSA密钥对的公钥、营业执照，然后将CSR文件发送给CA机构申请证书。 

◎CA机构收到CSR文件后，核实申请者的身份，最简单的核实就是校验域名（www.example.com）的拥有者是不是证书申请者。 

◎一旦审核成功，CA机构用自己的密钥对（比如ECDSA密钥对）的私钥签名CSR文件的内容得到签名值，然后将签名值附在CSR文件后面得到证书文件，证书文件中除了包含申请者的信息，还包括CA机构的信息，比如包括CA机构采用的签名算法（本例中就是ECDSA签名算法）、CA机构的名称。 

◎最终CA机构将证书文件发送给服务器实体。 
</code></pre><p>客户端如何校验证书，大体流程如下： </p>
<pre><code>◎浏览器向服务器端发送连接请求https://www.example.com。 

◎服务器接收到请求后，将证书文件和RSA密钥对的公钥发送给浏览器。 

◎浏览器接收到证书文件，从中判断出是某CA机构签发的证书，并且知道了证书签名算法是ECDSA算法，由于浏览器内置了该CA机构的根证书，根证书包含了CA机构的ECDSA公钥，用于验证签名。 

◎浏览器一旦验证签名成功，代表该证书确实是合法CA机构签发的。 

◎浏览器接着校验证书申请者的身份，从证书中取出RSA公钥（注意不是CA机构的公钥）和主机名，假设证书包含的主机也是www.example.com，且连接阶段接收到的RSA公钥等同于证书中包含的RSA公钥，则表示浏览器成功校验了服务器的身份，连接的服务器确实是www.example.com主机的拥有者。 
</code></pre><h3 id="3-3-HTTPS总结"><a href="#3-3-HTTPS总结" class="headerlink" title="3.3 HTTPS总结"></a>3.3 HTTPS总结</h3><p>证书中包含了两部分信息： </p>
<pre><code>◎服务器实体信息，比如服务器的主机名、服务器公钥。 

◎CA机构的信息，比如CA机构数字签名算法标识符、签名值 
</code></pre><h2 id="四、选择HTTPS"><a href="#四、选择HTTPS" class="headerlink" title="四、选择HTTPS"></a>四、选择HTTPS</h2><h3 id="4-1-部署HTTPS"><a href="#4-1-部署HTTPS" class="headerlink" title="4.1 部署HTTPS"></a>4.1 部署HTTPS</h3><h2 id="五、快速搭建HTTPS网站"><a href="#五、快速搭建HTTPS网站" class="headerlink" title="五、快速搭建HTTPS网站"></a>五、快速搭建HTTPS网站</h2><p>如何获取自签名证书 </p>
<pre><code>1.生成私钥对和CSR 

openssl req -newkey rsa:1024-nodes -keyout example_key.pem -out example_csr.pem 

openssl req命令最终生成两个文件，example_key.pem表示密钥对文件，example_cert.pem表示CSR文件 

2.生成自签名证书 

openssl x509 -signkey example_key.pem -in example_csr.pem -req -days 365-out example_cert.pem     

-signkey表示密钥对文件，-in表示CSR文件，-days表示证书有效期，-out表示最终的证书文件 
</code></pre><p>基于ACME协议的Certbot客户端可以向免费CA机构Let’sEncrypt申请证书 </p>
<pre><code>下载certbot客户端 

git clone https://github.com/certbot/certbot 

cd certbot 

一步生成证书 

./certbot-auto certonly --webroot -w /usr/nginx/web -d www.example.com 



-w表示代码根目录，-d表示要为哪些域名生成证书，--webroot表示安装插件（Certbot客户端有很多插件 

运行结束后，会在/etc/letsencrypt/live/www.example.com目录下生成四个文件，最重要的两个文件是fullchain.pem（完整证书链）和privkey.pem（私钥 
</code></pre><p>curl https:/www.baidu.com —verbose 查看https详细信息 </p>
<p>HTTP GET请求可以进行301重定向，而HTTP POST接口无法进行301重定向 </p>
<p>HSTS标准(HTTP Strict Transport Security),本质是http头部 </p>
<pre><code>Strict-Transport-Security: max-age=31536000;includeSubDomains;preload 

◎max-age，服务器告诉某个客户端，在31536000秒内，应该实施HSTS标准，这段时间内如果客户端重新访问了HTTPS网站，max-age时间就会被重新刷新。◎includeSubDomains，服务器告诉客户端域名下的所有子域名都实施HSTS标准，不仅仅是发出HSTS HTTP头部的主机才遵循该标准。 

◎preload，简单地说就是浏览器预存了需要实施HSTS标准的网站，详细信息后续介绍。 
</code></pre><p>实施HSTS的好处是什么呢？主要有以下几点： </p>
<pre><code>◎当浏览器发现某张证书是自签名证书时，且服务器发出了HSTS头部，不会提示用户是否信任该证书，直接中止访问HTTPS网站。 

◎当用户单击某个http://www.example.com明文连接的时候，且服务器（www.example.com）存在HSTS头部，在发出请求之前，浏览器会将http://www.example.com连接转换为https://www.example.com后再访问。 

◎用户访问https://www.example.com页面，浏览器解析的时候如果发现该页面存在混合内容，且服务器（www.example.com）发出了HSTS头部，则会将www.example.com下所有的明文连接转换为HTTPS连接后再访问。 
</code></pre><p>CSP机制（Content Security Policy）来有效控制混合内容的加载。 </p>
<h2 id="六、证书"><a href="#六、证书" class="headerlink" title="六、证书"></a>六、证书</h2><p>PKI（Public Key Infrastructure，称为公钥基础设施） </p>
<p>HTTPS中最常用的标准就是X.509标准 </p>
<p><img src="../..//images/image-20220126185841819.png" alt=""></p>
<p>从证书链的角度看，证书可以分为三种类型，分别是服务器实体证书、中间证书、根证书 </p>
<pre><code>1）服务器实体证书 

服务器实体证书在证书链的最末端，在图6-3的例子中，服务器实体证书是Let's EncryptAuthority X3签发的，该证书包含了服务器实体的一些信息，比如域名、服务器的公钥。 

2）中间证书 

中间证书在证书链的中间，服务器实体证书的上面。一般情况下，由中间证书签发服务器实体证书，中间证书不一定就是一张证书，中间证书可以由多张证书构成，中间证书还可以签发其他中间证书。 

3）根证书 

根证书称为自签名证书（self-signed），处于证书链中的最顶端，在图6-3的例子中，表示DSTROOT CA的根证书签发了Let's Encrypt Authority X3中间证书。 

其中chain.pem文件就是中间证书，它签发的服务器实体证书是cert.pem, fullchain.pem文件包含了cert.pem和chain.pem文件的内容，构成了完整的证书链 
</code></pre><h2 id="七、Let‘s-Encrypt-免费证书"><a href="#七、Let‘s-Encrypt-免费证书" class="headerlink" title="七、Let‘s Encrypt 免费证书"></a>七、Let‘s Encrypt 免费证书</h2><h2 id="八、TLS协议分析"><a href="#八、TLS协议分析" class="headerlink" title="八、TLS协议分析"></a>八、TLS协议分析</h2><h2 id="九、HTTPS性能和安全"><a href="#九、HTTPS性能和安全" class="headerlink" title="九、HTTPS性能和安全"></a>九、HTTPS性能和安全</h2><h2 id="十、HTTPS网站实战"><a href="#十、HTTPS网站实战" class="headerlink" title="十、HTTPS网站实战"></a>十、HTTPS网站实战</h2>]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>钻石</title>
    <url>/posts/45587.html</url>
    <content><![CDATA[<p>课程来源：<a href="https://masterclass-cn.ssef.ch/">https://masterclass-cn.ssef.ch/</a></p>
<h1 id="钻石简介"><a href="#钻石简介" class="headerlink" title="钻石简介"></a>钻石简介</h1><p>“钻石”（diamond）一词来源于希腊语adamas，意思是非常有抵抗力的或不可战胜的。本身只适用于天然来源的钻石。</p>
<p>合成钻石的身份是需要向消费者进行明确说明的</p>
<p>钻石的外观和颜色是可能被处理而获得改善的；这些处理方法也需要进行声明</p>
<h1 id="什么是钻石"><a href="#什么是钻石" class="headerlink" title="什么是钻石"></a>什么是钻石</h1><p>钻石是由碳组成的，在高压和高温下结晶的立方体晶体。钻石可能含有少量的其他杂质元素，如氮（N）或硼（B）。</p>
<p>钻石有高折射率（RI约为2.42）</p>
<p><img src="../../images/image-20221219165400138.png" alt="image-20221219165400138"></p>
<p>钻石是自然界中发现的最硬的矿物。因此，只有钻石的硬度足以切割和抛光另一颗钻石。这是因为钻石的不同晶面具有不同的硬度，这被称为硬度各向异性。</p>
<p>钻石的常见形状和切工</p>
<p><img src="../../images/image-20221219165450155.png" alt="image-20221219165450155"></p>
<p>钻石具有高折射率和高色散，通常被称为 “火彩”</p>
<p><img src="../../images/image-20221219165521420.png" alt="image-20221219165521420"></p>
<h1 id="什么是彩色钻石"><a href="#什么是彩色钻石" class="headerlink" title="什么是彩色钻石"></a>什么是彩色钻石</h1><p>钻石可以是任何颜色：无色、白色、黑色、蓝色、红色、绿色、橙色、粉红色或棕色等等等等。这些色调的之间又可以有着多种的组合，并有着宽泛的饱和度（色调强度）和色调的变化</p>
<p>彩色钻石，切割的目的是为了为钻石带来最强烈的色彩饱和度。</p>
<h3 id="彩色钻石的颜色分级"><a href="#彩色钻石的颜色分级" class="headerlink" title="彩色钻石的颜色分级"></a>彩色钻石的颜色分级</h3><p>钻石的颜色分级是一个非常细致的过程，因为必须考虑到三个光学参数的相互作用，以最终得出颜色等级：</p>
<p>1）颜色色相（如粉红色、蓝色、绿色）</p>
<p>2）颜色饱和度（从弱到强）</p>
<p>3）色调（从浅到深）</p>
<h1 id="钻石的历史"><a href="#钻石的历史" class="headerlink" title="钻石的历史"></a>钻石的历史</h1><p>印度，包括婆罗洲（Borneo），直到1730年左右在巴西的矿藏被发现之前，都是钻石的唯一产地</p>
<p>在佛教中，钻石也被尊为力量和智慧的象征</p>
<p>南非是一个钻石生产的大国，20世纪在非洲大陆的其他国家也发现了钻石矿藏</p>
<p>20世纪末，新出现了不少国家成为了钻石产出的主力，在几年的时间里，俄罗斯、加拿大和澳大利亚成为了世界上最重要的钻石产地。</p>
<h1 id="著名的钻石"><a href="#著名的钻石" class="headerlink" title="著名的钻石"></a>著名的钻石</h1><h4 id="美丽的桑西-The-Beau-Sancy"><a href="#美丽的桑西-The-Beau-Sancy" class="headerlink" title="美丽的桑西 The Beau Sancy"></a>美丽的桑西 The Beau Sancy</h4><p><img src="../../images/image-20221219165950207.png" alt="image-20221219165950207"></p>
<p><em>一颗自16世纪起即有记载可寻的34.98ct的微棕色钻石</em></p>
<h4 id="维特尔斯巴赫蓝钻-The-Wittelsbach"><a href="#维特尔斯巴赫蓝钻-The-Wittelsbach" class="headerlink" title="维特尔斯巴赫蓝钻 The Wittelsbach"></a>维特尔斯巴赫蓝钻 The Wittelsbach</h4><p><img src="../../images/image-20221219170015710.png" alt="image-20221219170015710"></p>
<p>一颗35.56克拉的枕形蓝钻</p>
<h4 id="德雷斯顿绿钻-The-Dresden-Green"><a href="#德雷斯顿绿钻-The-Dresden-Green" class="headerlink" title="德雷斯顿绿钻 The Dresden Green"></a>德雷斯顿绿钻 The Dresden Green</h4><p><img src="../../images/image-20221219170039802.png" alt="image-20221219170039802"></p>
<p>德累斯顿绿钻是一颗41克拉的钻石，在印度开采，18世纪初被带到欧洲。它是世界上最著名的彩色钻石之一，也是一枚极为特殊的天然绿色钻石</p>
<p>其他著名的历史性钻石包括库里南钻石（the Cullinan）、希望钻石（the Hope）、摄政王钻石（the Regent）、光之山（Koh-i-Noor）钻石、奥尔洛夫（the Orlov）钻石和百年纪念（the Centenary）钻石，<em>奥本海默蓝钻</em>，<em>粉红之星钻石</em>，<em>格拉夫艳丽黄钻</em>，<em>穆萨耶夫红钻</em>等</p>
<h1 id="钻石：来源和产地"><a href="#钻石：来源和产地" class="headerlink" title="钻石：来源和产地"></a>钻石：来源和产地</h1><p>大多数钻石是在被称为的岩石圈地幔中形成的，深度范围相当狭窄，大约是从地下140公里到200公里之间。</p>
<p>也有钻石产自于地球更深部（被称为超深钻石），有报道称有产自于超过地下600公里深的钻石。</p>
<h1 id="钻石分级"><a href="#钻石分级" class="headerlink" title="钻石分级"></a>钻石分级</h1><p>钻石使用4C分级系统进行分级：克拉（Carat）、净度（Clarity）、颜色（Color）和切工（Cut）</p>
<p>钻石分级标准 <a href="https://www.iso.org/standard/79795.html">ISO 标准24016</a></p>
<p><strong>克拉（Carat）：</strong>钻石重量的单位是克拉（ct）。一克拉等于0.2克</p>
<p><strong>颜色（Color）：</strong>钻石的颜色的分级是与CIBJO官方认证的钻石比色石系列进行比较而得出的。</p>
<p><strong>净度（Clarity）：</strong>净度等级是通过10x放大镜来评估的，用以评价钻石内部包裹体等内部特征的多寡。</p>
<p><strong>切工（Cut）：</strong>钻石的切工等级取决于其对称性、抛光、比例和腰部厚度等等</p>
<p><em>深度和台面比例：</em>钻石的深度和台面尺寸是以其平均直径（对于圆形）或其宽度（对于其他形状）的百分比来表示。</p>
<p><em>腰棱：</em>钻石的腰棱是由它的厚度（非常厚、厚、中等、薄、非常薄、锋利的边缘）和它的状态（粗磨、刻面、抛光）来描述。</p>
<p><em>抛光：</em>钻石的抛光描述了其切面的质量，用以下术语表示：优秀，非常好，好，中等，或差。</p>
<p><em>对称性：</em>钻石的对称性是指其形状和切面排列的精确性。它由以下术语来表示：优秀、非常好、好、中等、差。</p>
<p><strong>紫外线荧光：</strong>当钻石被紫外线（长波）照射时，它可能会自然地被激发释放出可见光，需描述其强度（无、微、中或强）和色调（如蓝色、橙色、黄色）。</p>
<p><em>形状和切工：</em>钻石的形状用以描述其轮廓（如圆形、八角形），钻石的切工是由它的刻面的排列决定的（如明亮型、阶梯型）。</p>
<p><em>测量：</em>以毫米为单位，对于圆形：”最小直径”-“最大直径 “x “深度”。对于其它形状：”长度 “x “宽度 “x “深度”。</p>
<h1 id="实地考察"><a href="#实地考察" class="headerlink" title="实地考察"></a>实地考察</h1><p>短片《<em>苏瓦（Sewa）河上的潜水员</em>》</p>
<p><a href="https://mineral-choices.com/content/watch-the-divers-of-sewa/">https://mineral-choices.com/content/watch-the-divers-of-sewa/</a></p>
<h1 id="合成钻石"><a href="#合成钻石" class="headerlink" title="合成钻石"></a>合成钻石</h1><p>自20世纪50年代开始，合成钻石的生产已经有了长足的发展</p>
<p>第一种方法：高压高温（HPHT）合成法，使用压力机来重现钻石在自然界中生长的条件。</p>
<p>第二种方法，化学气相沉积（CVD），是一种在真空室中使用等离子体，在低压下人工生长钻石的方法。</p>
<p>长期以来，合成钻石只是为工业目的而制造的，在传统上是用做切割、锯切、研磨和抛光的工具。</p>
<h1 id="钻石处理方法"><a href="#钻石处理方法" class="headerlink" title="钻石处理方法"></a>钻石处理方法</h1><p>一颗钻石可能被处理以改善其颜色或净度。而向消费者和贸易界申明该钻石经由的任何的处理是必须的。</p>
<p><strong>钻石（或合成钻石）的颜色被处理而发生改变，例如：</strong></p>
<ul>
<li>涂层、烫金和喷色</li>
<li>辐照（通常与随后的加热相结合）</li>
<li>用亚原子粒子轰击</li>
<li>高压高温（HPHT）处理</li>
</ul>
<p><strong>钻石（或合成钻石）的净度也一样可以通过处理来改变，例如：</strong></p>
<ul>
<li>用高折射率的玻璃（如铅玻璃）填充裂缝</li>
<li>激光钻孔以减少内含物的可见度</li>
</ul>
<h1 id="米粒钻Melee"><a href="#米粒钻Melee" class="headerlink" title="米粒钻Melee"></a>米粒钻Melee</h1><p>每个月，钟表业界和珠宝业界都要消耗使用数百万颗无色的、小粒的、圆形的刻面钻石，这些小钻石被称为 “米粒钻”。米粒钻是指重量小于0.25克拉或直径约4.1毫米的钻石。米粒钻可以小到直径仅为半毫米（0.5毫米）。</p>
<h1 id="科技钻石鉴定"><a href="#科技钻石鉴定" class="headerlink" title="科技钻石鉴定"></a>科技钻石鉴定</h1><p>利用傅里叶变换红外光谱（FTIR），我们可以区分出不同类型的钻石：</p>
<p>I型钻石：含有微量的氮（N）化学杂质的钻石。</p>
<p>II型钻石：不含（FTIR检测到的）氮的钻石，但可能含有微量的硼（B）。</p>
<p>此外，我们可以根据这些氮或硼杂质在钻石晶体结构中的存在方式来区分几个亚类型。</p>
<p>不含氮和硼元素的纯钻石是IIa型。</p>
<p>而含有微量的硼元素的钻石是IIb型。由于硼的存在，它们的颜色是蓝色（至灰蓝色）</p>
<p><img src="../../images/image-20221219171617897.png" alt="image-20221219171617897"></p>
]]></content>
      <categories>
        <category>SSEF 钻石入门课</category>
      </categories>
  </entry>
  <entry>
    <title>分治、排序、搜索和随机算法 Week1 Problem Set</title>
    <url>/posts/54874.html</url>
    <content><![CDATA[<p>课程地址：<a href="https://www.coursera.org/specializations/algorithms">https://www.coursera.org/specializations/algorithms</a></p>
<h1 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h1><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><p><img src="../../../images/image-20221028144237574.png" alt=""></p>
<h2 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h2><p>假设在 Merge Sort 的每个步骤中不是分成两半，而是分成三份，每三分之一排序，最后使用三向合并子例程将所有这些合并。这个算法的整体渐近运行时间是多少？（提示：注意合并步骤仍然可以在$O（n）$时间实现。）</p>
<p>方案1 </p>
<ul>
<li><p>merge 3个元素，所需步骤为$3 + 5n &lt;= 8n$</p>
</li>
<li><p>假设数组长度n为3的幂，每次平均拆分数组，这个过程共有$\log_{3}n$次</p>
</li>
<li><p>所以，第 $j$ 层有 $3^j$ 个节点，每个节点有 $n/3^j$ 个数字</p>
</li>
<li><p>第 $j$ 层merge的时间复杂度为 O(n)</p>
</li>
</ul>
<script type="math/tex; mode=display">
  3^j * 8\frac {n}{3^j} = 8n</script><ul>
<li>一共有 $log_{3}n + 1$ 层，所以总的时间复杂度为 </li>
</ul>
<script type="math/tex; mode=display">
8nlog_{3}n+8n</script><ul>
<li>所以时间复杂度为 $nlog_3{n}$</li>
</ul>
<p>方案2 </p>
<ul>
<li><p>对于2路mergeSort 来说 $T(n) = 2T(\frac{n}{2})+O(n)$</p>
</li>
<li><script type="math/tex; mode=display">
\begin{align}
T(n) &= 2T(\frac{n}{2}) + n \\
& \leq 2c \frac{n}{2} log(\frac{n}{2} ) +n\\
& = cnlogn -cnlog2 +n \\
& =cnlogn-cn+n \\
&\leq cnlogn
\end{align}</script></li>
<li><p>同理 3路的mergeSort： $T(n) = 3T(\frac{n}{3})+O(n)$</p>
</li>
<li><p>$T(n) = nlog_3n$</p>
</li>
</ul>
<h1 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h1><h2 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h2><p><img src="../../../images/image-20221028144251962.png" alt=""></p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><p>$f,g $ 满足$f(n)=O(g(n))$ ，是否满足$f(n)<em>log_2(f(n)^c) = O(g(n)</em>log_2(g(n)))$ ? （c是常数) 假设 $f,g $ 非递减并且总是大于1</p>
<p>已知，存在 $c_1$ ，使得 $f(n) \leq c_1<em>g(n)$ ，求证，存在 $c_2$ 使 $f(n)</em>log_2(f(n)^c) \leq c_2<em> O(g(n)</em>log_2(g(n)))$</p>
<script type="math/tex; mode=display">
\begin{align}
f(n)*log_2(f(n)^c) & = c*f(n)*log_2(f(n)) \\
                                     & \leq c * c1* g(n) * log_2(c1*g(n)) \\
                                     & = c * c1 * g(n) * log_2{c1} +  c * c1 * g(n) * log_2{g(n)} \\
                                     & \leq  c * c1 * g(n) * log_2{g(n)} \\
c2 = c * c1
\end{align}</script><h1 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h1><h2 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h2><p><img src="../../../images/image-20221028144300714.png" alt=""></p>
<h2 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h2><p>假设两个（正）非减函数 $f,g $ 满足 $f(n)=O(g(n))$. $2^{f(n)}=O(2^{g(n)})$ 是否正确?</p>
<p>已知，存在 $c_1$ ，使得 $f(n) \leq c_1<em>g(n)$ ，求证， $2^{f(n)}\leq c2 </em>2^{g(n)})$ 是否成立</p>
<p> $2^{f(n)}\leq c2 *2^{g(n)})$  等价于  $f(n) \leq logc_2+g(n)$ </p>
<p>并非恒成立的</p>
<h1 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h1><h2 id="答案-3"><a href="#答案-3" class="headerlink" title="答案"></a>答案</h2><p><img src="../../../images/image-20221028144308774.png" alt=""></p>
<h2 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h2><p>k-way-Merge 排序。假设给你k个数组，每个都有n元素，并且您想将它们组合成一个数组kn元素。考虑以下方法。使用讲座中教授的合并子程序，合并前 2 个数组，然后合并$3^{rd}$给定数组与前两个数组的合并版本，然后合并$4^{th}$时间,给定数组与前三个数组的合并版本，依此类推，直到您在最终合并$k^{th}$输入数组。这个连续合并算法所花费的运行时间是多少，作为一个函数k和n? （可选：您能想出一种更快的方法来执行 k 路合并过程吗？）</p>
<p>对于上界，合并后的列表大小都为 $O(nk)$，合并在较大数组的大小上是线性的，并且有$k$次迭代。所以为$O(nk)*k$</p>
<p>对于下限，最后 $\frac{k}{2}$ 次合并中的每一个都需要$\Omega(nk)$ 时间，即与数组中较长的那个长度成正比</p>
<h1 id="问题5"><a href="#问题5" class="headerlink" title="问题5"></a>问题5</h1><h2 id="答案-4"><a href="#答案-4" class="headerlink" title="答案"></a>答案</h2><p><img src="../../../images/image-20221028144323651.png" alt=""></p>
<h2 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h2><p>按递增顺序排列以下函数，$f(n)= O(g(n))$ 时，$g(n)$  在 $f(n)$ 之后</p>
<p>$2^{2^n}$</p>
<p>$2^{n^2}$</p>
<p>$n^2\log(n)$</p>
<p>$n$</p>
<p>$n^{2^n}$</p>
<script type="math/tex; mode=display">
n \leq n^2\log(n) \leq 2^{n^2} \leq 2^{2^n} \leq n^{2^n}</script><h1 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h1><h2 id="答案-5"><a href="#答案-5" class="headerlink" title="答案"></a>答案</h2><p><img src="../../../images/image-20221028172904266.png" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">8539734222673567065463550869546574495034888535765114961879601127067743044893204848617875072216249073013374895871952806582723184</span><br></pre></td></tr></table></figure>
<h2 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h2><p>Karatsuba 算法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">multiply</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">if</span> (x &lt; <span class="number">10</span> <span class="keyword">or</span> y &lt; <span class="number">10</span>):</span><br><span class="line">        <span class="keyword">return</span> x*y</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        k = <span class="built_in">min</span>(<span class="built_in">len</span>(<span class="built_in">str</span>(x)), <span class="built_in">len</span>(<span class="built_in">str</span>(y))) //<span class="number">2</span> </span><br><span class="line">        u = <span class="number">10</span>**k</span><br><span class="line">        a = x//u</span><br><span class="line">        c = y//u</span><br><span class="line">        b = x - a*u</span><br><span class="line">        d = y - c*u</span><br><span class="line">        ac = multiply(a,c)</span><br><span class="line">        bd = multiply(b,d)</span><br><span class="line">        abcd = multiply(a+b,c+d)</span><br><span class="line">        adbc = abcd - ac - bd</span><br><span class="line">        res = u**<span class="number">2</span> * ac + u * adbc + bd</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line">x = <span class="number">3141592653589793238462643383279502884197169399375105820974944592</span></span><br><span class="line">y = <span class="number">2718281828459045235360287471352662497757247093699959574966967627</span></span><br><span class="line"><span class="built_in">print</span>(multiply(x, y))</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>斯坦福算法课</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>斯坦福算法课</tag>
      </tags>
  </entry>
  <entry>
    <title>分治、排序、搜索和随机算法Week2</title>
    <url>/posts/40684.html</url>
    <content><![CDATA[<p>课程地址：<a href="https://www.coursera.org/specializations/algorithms">https://www.coursera.org/specializations/algorithms</a></p>
<h1 id="O-nlogn-逆序对计数算法"><a href="#O-nlogn-逆序对计数算法" class="headerlink" title="O(nlogn) 逆序对计数算法"></a>O(nlogn) 逆序对计数算法</h1><ul>
<li>Input: 数组A，包含数字1，2，3….n，任意顺序</li>
<li>Output: 逆序数 = 数组中 $ pairs(i,j)$ 的数量，$i<j,A[i]>A[j]$</li>
</ul>
<h2 id="常规算法"><a href="#常规算法" class="headerlink" title="常规算法"></a>常规算法</h2><p>对于数组，最多可能的反转次数，为$n(n-1)/2$ ，所以常规估计的算法复杂度为$O(n^2)$</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def count(arr n):</span><br><span class="line">    res = 0</span><br><span class="line">    for i in range(len(l)):</span><br><span class="line">        for j in range(i + 1, len(l)):</span><br><span class="line">            if l[i] &gt; l[j]:</span><br><span class="line">                res += 1</span><br><span class="line">    return res</span><br></pre></td></tr></table></figure>
<h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><ul>
<li>像 merge sort一样的</li>
<li>计算前一半的反转次数并排序，计算后一半的反转次数并排序</li>
<li>计算CountSPlitInv的次数，期望的时间复杂度为O(n)</li>
<li>最终求和</li>
<li>时间复杂度为$O(nlogn)$</li>
<li>伪码<img src="../../../images/image-20221031174302135.png" alt="image-20221031174302135"></li>
</ul>
<p><img src="../../../../../demodaisy/hexoblog/source/images/image-20221101171807839.png" alt=""></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">countsplitinv</span>(<span class="params">L,R,arr,n</span>):</span><br><span class="line">    n1 = <span class="built_in">len</span>(L)</span><br><span class="line">    n2 = <span class="built_in">len</span>(R)</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    i,j=<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n1 <span class="keyword">and</span> j &lt; n2 : </span><br><span class="line">        <span class="keyword">if</span> L[i] &lt;= R[j]: </span><br><span class="line">            arr[k] = L[i] </span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            arr[k] = R[j]</span><br><span class="line">            count += n1-i</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span> </span><br><span class="line">    <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">count</span>(<span class="params">arr, n</span>):</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i+<span class="number">1</span>,n):</span><br><span class="line">            <span class="keyword">if</span> arr[i] &gt; arr[j]:</span><br><span class="line">                 count +=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count        </span><br></pre></td></tr></table></figure>
<h1 id="Strassen的三次矩阵乘法算法"><a href="#Strassen的三次矩阵乘法算法" class="headerlink" title="Strassen的三次矩阵乘法算法"></a>Strassen的三次矩阵乘法算法</h1><p>矩阵乘法$Z = X<em>Y$，矩阵维度为$n</em>n$ </p>
<script type="math/tex; mode=display">
Z_{ij} = \sum_{k=1}^{n}X_{ik}*Y_{kj}</script><p>新数组中每个数的计算量都是$\Theta(n)$，因此总体的计算复杂度是$\Theta(n^3)$</p>
<p>使用分治算法，可以减少一层计算，最终复杂度为$\Theta(n^2)$</p>
<script type="math/tex; mode=display">
\begin{align}
X*Y & = \begin{pmatrix} A & B \\ C & D\end{pmatrix} * \begin{pmatrix} E & F \\ G & H\end{pmatrix} \\
        & = \begin{pmatrix} AE + BG & AF+BH \\ CE+DG & CF+DH\end{pmatrix} \\
        & =  \begin{pmatrix} P_5+P_4-P_2+P_6 & P_1+P_2 \\ P_3+P_4 & P_1+P_5-P_2-P_7\end{pmatrix}\\
        \\
        \\
        &P_1 = A*(F-H)\\
        &P_2 = (A+B)*H\\
        &P_3 = (C+D)*E\\
        &P_4 = D*(G-E) \\
        &P_5 = (A+D)*(E+H)\\
        &P_6 =(B-D)*(G+H)\\
        &P_7 = (A-C) *(E+F)
\end{align}</script><h1 id="O-nlogn-最近点对的算法"><a href="#O-nlogn-最近点对的算法" class="headerlink" title="O(nlogn) 最近点对的算法"></a>O(nlogn) 最近点对的算法</h1><ul>
<li>Input:  平面$R^2$中的一组点 $P ={p_1,…,p_n}$</li>
<li><p>欧几里得距离 $p_i =(x_i,y_i), p_j =(x_j,y_j)$ , 则 $d(p_i,p_j) = \sqrt{(x_i -x_j)^2+(y_i-y_j)^2} $</p>
</li>
<li><p>Output: 求点集中最近距离的点对 </p>
</li>
</ul>
<p><strong>解决方案</strong></p>
<ul>
<li><p>假设每个点都有对应的横纵坐标</p>
</li>
<li><p>直接计算各个点之间的距离，为$\Theta(n^2)$</p>
</li>
<li><p>如果点在同一条直线上，那么可以用排序方法解决，为$O(nlog(n))$</p>
<p><img src="../../../images/image-20221101172246504.png" alt=""></p>
</li>
<li><p>二维情况如何使时间复杂度降低到$O(nlogn)$\</p>
</li>
<li><p>伪代码如下</p>
</li>
</ul>
<p><img src="../../../images/image-20221101172454332.png" alt=""></p>
<p><strong>算法说明</strong></p>
<p>点对 $(P_x,P_y)$</p>
<ol>
<li>假设Q为P的坐半部分，R为P的右半部分。</li>
<li>$(p_1,q_1)$是左边最近的点</li>
<li>$(p_2,q_2)$是右边最近的点</li>
<li>$\delta = min{d(p_1,q_1),d(p_2,q_2)}$</li>
<li>(p_3,q_3)是左边点$p_x$和右边点$p_y$ ，他们距离最近</li>
<li>返回三组中最小的结果</li>
</ol>
<p><img src="../../../images/image-20221101180518159.png" alt=""></p>
<p>第五步的计算方式如下：</p>
<p>$\overline{x}$ = 左半部分最大的x左标 // 中位x的坐标</p>
<p>$S_y$ = 点集 $q_1,q_2,…q_n$, 其中$x\in {\overline{x}-\theta,\overline{x}+\theta}$ ，按照y排序</p>
<p>初始化，最短距离为$\delta$, 点对为NUll</p>
<p>循环获取最近点对，第二重循环只需要7次。</p>
<p><strong>证明：</strong></p>
<p>$p\in Q,q \in R$ 为 $d(p,q) &lt; \delta$ 的点对，则</p>
<p>A：$p,q \in S_y$</p>
<p>B: $p,q$ 在 $S_y$ 中最多距离7位</p>
<p>令$p = (x_1,y_1),q=(x_2,y_2)$</p>
<p>证明A：</p>
<p><img src="../../../images/image-20221101183029174.png" alt=""></p>
<script type="math/tex; mode=display">
因为 d(p,q) \leq \delta,  |x_1-x_2| \leq \delta, |y_1 -Y_2| \leq \delta \\
p \in Q  =>  x_1 \leq \overline{x} \\
q \in R  =>  x_2 \geq \overline{x} \\
x_1,x_2 \in [\overline{x}- \delta, \overline{x} + \delta]</script><p>证明B：</p>
<p><img src="../../../images/image-20221101183410156.png" alt=""></p>
<p>需要证明如下2点：</p>
<ol>
<li>$S_y$中纵坐标范围介于p,q纵坐标之间的点都落在这8个方格之内</li>
</ol>
<p>$|y_1- y_2| \leq d(p,q) &lt; \delta \ $</p>
<ol>
<li>1个方格内最多有1个点</li>
</ol>
<p>如果两个点在同一格中，它们的距离$&lt; \sqrt{2} \delta/2$</p>
<p>所以只需要计算7次，就可以找到最小点对。</p>
<h1 id="主定理-Master-Method"><a href="#主定理-Master-Method" class="headerlink" title="主定理 Master Method"></a>主定理 Master Method</h1><h2 id="动力-Motivation"><a href="#动力-Motivation" class="headerlink" title="动力 Motivation"></a>动力 Motivation</h2><p>$x = 10^{n/2}a + b$   </p>
<p>$ y = 10^{n/2}c+d$</p>
<p>则：</p>
<p>$xy=10^nac + 10^{n/2}(ad+bc)+bd$</p>
<p><strong>算法1</strong>：计算ac，ad，bc，bd 4个值，并递归，复杂度$T(n) &lt;= 4 T(n/2) + O(n)$ </p>
<p><strong>算法2</strong>：$ad+bc = (a+b)(c+d) - ac -bd$ , 只须计算3个值，复杂度 $T(n) &lt;= 3 T(n/2) + O(n)$</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>递归类型的算法，很多的时间复杂度如下：</p>
<p>$T(n) &lt;= a$ 常数，对有效的小n</p>
<p>$T(n) &lt;= aT(n/b)+O(n^d)$ 对所有大n，a 递归次数&gt;=1 b 输入数据的收缩系数 &gt;1, d 合并步骤的指数&gt;=0</p>
<p><img src="../../../images/image-20221221171834651.png" alt=""></p>
<h3 id="举例如下："><a href="#举例如下：" class="headerlink" title="举例如下："></a>举例如下：</h3><p><strong>MergeSort</strong></p>
<p><img src="../../../images/image-20221221172159931.png" alt=""></p>
<p><strong>大数乘法</strong></p>
<p><img src="../../../images/image-20221221172244484.png" alt=""></p>
<p><strong>矩阵乘法</strong></p>
<p><img src="../../../images/image-20221221172346096.png" alt=""></p>
<p><strong>Fictitious 递归</strong></p>
<p><img src="../../../images/image-20221221172418993.png" alt=""></p>
]]></content>
      <categories>
        <category>斯坦福算法课</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>斯坦福算法课</tag>
      </tags>
  </entry>
  <entry>
    <title>分治、排序、搜索和随机算法Week1</title>
    <url>/posts/40876.html</url>
    <content><![CDATA[<p>课程地址：<a href="https://www.coursera.org/specializations/algorithms">https://www.coursera.org/specializations/algorithms</a></p>
<h1 id="整数乘法-Integer-Multiplication"><a href="#整数乘法-Integer-Multiplication" class="headerlink" title="整数乘法 Integer Multiplication"></a>整数乘法 Integer Multiplication</h1><ul>
<li>Input：2个n位的数字x，y</li>
<li>Output：x*y</li>
</ul>
<h2 id="常用计算方式"><a href="#常用计算方式" class="headerlink" title="常用计算方式"></a>常用计算方式</h2><p>例如 1234  * 5678</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">			5 6 7 8</span><br><span class="line">  *   1 2 3 4</span><br><span class="line">_______________</span><br><span class="line">		2 2 7 1 2</span><br><span class="line">	1 7 0 3 4</span><br><span class="line">1 1 3 5 6</span><br><span class="line">5 6 7 8</span><br><span class="line">_______________</span><br><span class="line">7 0 0 6 6 5 2</span><br></pre></td></tr></table></figure>
<h2 id="Karatsuba-Multiplication"><a href="#Karatsuba-Multiplication" class="headerlink" title="Karatsuba Multiplication"></a>Karatsuba Multiplication</h2><p>典型的分治算法</p>
<p>$x = 10^{n/2}a + b$   </p>
<p>$ y = 10^{n/2}c+d$</p>
<p>则：</p>
<p>$xy=10^nac + 10^{n/2}(ad+bc)+bd$</p>
<p>又因为</p>
<p>$ (a+b)(c+d)=ac +bc +ad +bd $</p>
<p>$  bc + ad  = (a+b)(c+d)-ac -bc $</p>
<h3 id="算法说明"><a href="#算法说明" class="headerlink" title="算法说明"></a>算法说明</h3><ul>
<li>$xy=10^nac + 10^{n/2}(ad+bc)+bd$</li>
<li>计算$ac$</li>
<li>计算$bd$</li>
<li>计算$(a+b)(c+d)$</li>
<li>计算 $ad + bc =(a+b)(c+d)-ac-bd$</li>
</ul>
<p>如果位数n比较多，可以不断递归计算</p>
<h1 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序 Merge Sort"></a>归并排序 Merge Sort</h1><p>一种分治算法</p>
<ul>
<li>Input: 乱序的数字数组</li>
<li>Output: 同样的数字，升序排列</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">		5 4 1 8 7 2 6 3</span><br><span class="line">5 4 1 8         7 2 6 3</span><br><span class="line">		----递归调用----</span><br><span class="line">1 4 5 8					2 3 6 7</span><br><span class="line">		 ----Merge----</span><br><span class="line">		1 2 3 4 5 6 7 8</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="算法说明-1"><a href="#算法说明-1" class="headerlink" title="算法说明"></a>算法说明</h2><ul>
<li>递归：对数组的前一半排序</li>
<li>递归：对数组的后一半排序</li>
<li>将两个数组merge成一组</li>
</ul>
<h2 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge</span>(<span class="params">arr, l, m, r</span>): </span><br><span class="line">    n1 = m - l + <span class="number">1</span></span><br><span class="line">    n2 = r- m </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 创建临时数组</span></span><br><span class="line">    L = [<span class="number">0</span>] * (n1)</span><br><span class="line">    R = [<span class="number">0</span>] * (n2)</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 拷贝数据到临时数组 arrays L[] 和 R[] </span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span> , n1): </span><br><span class="line">        L[i] = arr[l + i] </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span> , n2): </span><br><span class="line">        R[j] = arr[m + <span class="number">1</span> + j] </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 归并临时数组到 arr[l..r] </span></span><br><span class="line">    i = <span class="number">0</span>     <span class="comment"># 初始化第一个子数组的索引</span></span><br><span class="line">    j = <span class="number">0</span>     <span class="comment"># 初始化第二个子数组的索引</span></span><br><span class="line">    k = l     <span class="comment"># 初始归并子数组的索引</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">while</span> i &lt; n1 <span class="keyword">and</span> j &lt; n2 : </span><br><span class="line">        <span class="keyword">if</span> L[i] &lt;= R[j]: </span><br><span class="line">            arr[k] = L[i] </span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>: </span><br><span class="line">            arr[k] = R[j] </span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 拷贝 L[] 的保留元素</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n1: </span><br><span class="line">        arr[k] = L[i] </span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 拷贝 R[] 的保留元素</span></span><br><span class="line">    <span class="keyword">while</span> j &lt; n2: </span><br><span class="line">        arr[k] = R[j] </span><br><span class="line">        j += <span class="number">1</span></span><br><span class="line">        k += <span class="number">1</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mergeSort</span>(<span class="params">arr,l,r</span>): </span><br><span class="line">    <span class="keyword">if</span> l &lt; r: </span><br><span class="line">  </span><br><span class="line">        </span><br><span class="line">        m = <span class="built_in">int</span>((l+(r-<span class="number">1</span>))/<span class="number">2</span>)</span><br><span class="line">  </span><br><span class="line">       </span><br><span class="line">        mergeSort(arr, l, m) </span><br><span class="line">        mergeSort(arr, m+<span class="number">1</span>, r) </span><br><span class="line">        merge(arr, l, m, r) </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">arr = [<span class="number">12</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>] </span><br><span class="line">n = <span class="built_in">len</span>(arr) </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;给定的数组&quot;</span>) </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n): </span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;%d&quot;</span> %arr[i]), </span><br><span class="line">  </span><br><span class="line">mergeSort(arr,<span class="number">0</span>,n-<span class="number">1</span>) </span><br><span class="line"><span class="built_in">print</span> (<span class="string">&quot;\n\n排序后的数组&quot;</span>) </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n): </span><br><span class="line">    <span class="built_in">print</span> (<span class="string">&quot;%d&quot;</span> %arr[i]),</span><br></pre></td></tr></table></figure>
<h2 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h2><p><img src="../../../images/image-20221027182742964.png" alt=""></p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>长度为m的数组做归并排序，运行时间？</p>
<p><strong>Merge分析</strong></p>
<ul>
<li>2次操作：$i,j$的初始化</li>
<li>给k赋值</li>
<li>比较 $A(i),B(j)$ 的值</li>
<li>给$C(k)$赋值</li>
<li><p>$i,j$的自增</p>
</li>
<li><p>所以，每次merge 需要 $4m+2 \leq 6m$ 次操作 （$m\geq 1$）</p>
</li>
<li>merge的时间复杂度为 O(n)</li>
</ul>
<p><strong>递归分析</strong></p>
<ul>
<li>假设数组长度n为2的幂，每次平均拆分数组，这个过程共有$\log_{2}n$次</li>
</ul>
<p><img src="../../../images/image-20221027184605882.png" alt=""></p>
<ul>
<li><p>所以，第 $j$ 层有 $2^j$ 个节点，每个节点有 $n/2^j$ 个数字</p>
</li>
<li><p>第 $j$ 层merge的时间复杂度为 </p>
</li>
</ul>
<script type="math/tex; mode=display">
  2^j * 6\frac {n}{2^j} = 6n</script><ul>
<li>一共有 $log_{2}n + 1$ 层，所以总的时间复杂度为 </li>
</ul>
<script type="math/tex; mode=display">
6nlog_{2}n+6n</script><h3 id="算法分析指导原则"><a href="#算法分析指导原则" class="headerlink" title="算法分析指导原则"></a>算法分析指导原则</h3><ol>
<li>使用最坏的情况来分析</li>
<li>不要过分关注小的常数项或低阶项</li>
<li>使用渐进分析，关注大的输入项的情况</li>
</ol>
<p>总的来说，快的算法 $\approx$  最坏情况的运行时间，随着输入项缓慢的增长</p>
<p>通常的，希望尽可能的接近 $O(n)$ </p>
<h1 id="渐进分析"><a href="#渐进分析" class="headerlink" title="渐进分析"></a>渐进分析</h1><p>讨论算法设计和分析的基本词汇</p>
<p>高级思想：抑制常数项（过于依赖系统）和低阶项（与大输入无关）</p>
<p>例如：$6nlog<em>{2}n+6$ 的运行时间为 $O(nlog</em>{2}n)$</p>
<h2 id="几个例子"><a href="#几个例子" class="headerlink" title="几个例子"></a>几个例子</h2><h3 id="一个循环"><a href="#一个循环" class="headerlink" title="一个循环"></a>一个循环</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i = 1 to n do</span><br><span class="line">	if A[i] == t then</span><br><span class="line">		Return TRUE</span><br><span class="line">RETURN FALSE</span><br></pre></td></tr></table></figure>
<p>时间复杂度为 $O(n)$</p>
<h3 id="两个循环"><a href="#两个循环" class="headerlink" title="两个循环"></a>两个循环</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i = 1 to n do</span><br><span class="line">	if A[i] == t then</span><br><span class="line">		Return TRUE</span><br><span class="line">for i = 1 to n do</span><br><span class="line">	if B[i] == t then</span><br><span class="line">		Return TRUE</span><br><span class="line">RETURN FALSE</span><br></pre></td></tr></table></figure>
<p>时间复杂度为 $O(n)$</p>
<h3 id="两个嵌套循环"><a href="#两个嵌套循环" class="headerlink" title="两个嵌套循环"></a>两个嵌套循环</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i = 1 to n do</span><br><span class="line">	for j = 1 to n do</span><br><span class="line">		if A[i] == B[j] then</span><br><span class="line">			Return TRUE</span><br><span class="line">RETURN FALSE</span><br></pre></td></tr></table></figure>
<p>时间复杂度为 $O(n^2)$</p>
<h3 id="两个嵌套循环2"><a href="#两个嵌套循环2" class="headerlink" title="两个嵌套循环2"></a>两个嵌套循环2</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i = 1 to n do</span><br><span class="line">	for j = i+1 to n do</span><br><span class="line">		if A[i] == A[j] then</span><br><span class="line">			Return TRUE</span><br><span class="line">RETURN FALSE</span><br></pre></td></tr></table></figure>
<p>时间复杂度为 $O(n^2)$</p>
<h2 id="大-O-符号"><a href="#大-O-符号" class="headerlink" title="大  $O$   符号"></a>大  $O$   符号</h2><p>$T(n) = O(f(n))$  当且仅当存在常数$c,n_0 &gt; 0$ 时，对 $\forall n \geq n_0 $ 有  $T(n) \leq c*f(n)$ </p>
<p>注意：$c, n_0$ 与 $n$ 无关</p>
<p><img src="../../../images/image-20221028105857026.png" alt=""></p>
<h3 id="举例分析"><a href="#举例分析" class="headerlink" title="举例分析"></a>举例分析</h3><blockquote>
<p>例一</p>
</blockquote>
<p>如果 $T(n) =a_kn^k + …+ a_1n+a_0$ ，则 $T(n) = O(n^k)$</p>
<p>假设 $n<em>0 = 1$ ，$c = |a_k|+|a</em>{k-1}|+..+|a_1|+|a_0|$ ，需要证明 $\forall{n} \geq 1, T(n) \leq c * n^k$</p>
<script type="math/tex; mode=display">
\begin{align}
T(n) &\leq |a_k|n^k+...+|a_1|n+|a_0| \\
&     \leq |a_k|n^k+...+|a_1|n^k+|a_0|n^k \\
&     =c * n^k
\end{align}</script><h2 id="大-Omega-符号"><a href="#大-Omega-符号" class="headerlink" title="大 $\Omega$ 符号"></a>大 $\Omega$ 符号</h2><p>$T(n) = \Omega(f(n))$  当且仅当存在常数$c,n_0 &gt; 0$ 时，对 $\forall n \geq n_0 $ 有  $T(n) \geq c*f(n)$ </p>
<p><img src="../../../images/image-20221028120038885.png" alt="image-20221028120038885"></p>
<h2 id="大-Theta-符号"><a href="#大-Theta-符号" class="headerlink" title="大 $\Theta$ 符号"></a>大 $\Theta$ 符号</h2><p>$T(n) = \Theta(f(n))$  当且仅当存在常数$c_1,c_2,n_0 &gt; 0$ 时，对 $\forall n \geq n_0 $ 有  $c_1f(n) \leq T(n) \leq c_2*f(n)$ </p>
<p>$T(n) = \Theta(f(n))$  等价于   $T(n) = O(f(n))$ 且 $T(n) = /Omega(f(n))$</p>
<h2 id="小-o-符号"><a href="#小-o-符号" class="headerlink" title="小 $o$ 符号"></a>小 $o$ 符号</h2><p> $T(n) = o(f(n))$ 当且仅当 $\forall c&gt;0$ ,存在常数 $c &gt;0$ , 对 $\forall n \geq n_0 $ 有  $T(n) \leq c*f(n)$ </p>
<p>举例： $\forall k \geq 1, n^{k-1} = o(n^k)$</p>
<h2 id="补充举例"><a href="#补充举例" class="headerlink" title="补充举例"></a>补充举例</h2><h3 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h3><p>证明 $2^(n+10) = O(2^n)$</p>
<p>需要找到常数 $c,n_0$ ，满足 $2^(n+10) \leq c*2^n，n \geq n_0$</p>
<p>$ c = 1024, n_0 = 1$ 即可</p>
<h3 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h3><p>证明 $ 2^{10n} \neq O(2^n)$</p>
<p>反证法，如果  $ 2^{10n} =  O(2^n)$ ，则存在常数$c, n_0 \geq 0$, $2^{10n} \leq c*2^n, n\geq n_0$</p>
<p>即 $2^{9n} \leq c, n \geq n_0$</p>
<p>上面式子很明显是不成立的</p>
<h3 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h3><p>证明： <script type="math/tex">max\left\{f,g\right\} = \Theta(f(n) + g(n))</script></p>
<script type="math/tex; mode=display">
max\left\{f,g\right\} \leq f(n)+g(n) \leq 2*max\left\{f,g\right\} \\
\frac{1}{2} (f(n)+g(n)) \leq max\left\{f,g\right\} \leq f(n) + g(n) \\</script>]]></content>
      <categories>
        <category>斯坦福算法课</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>斯坦福算法课</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL 基础</title>
    <url>/posts/19528.html</url>
    <content><![CDATA[<h1 id="SQL概述"><a href="#SQL概述" class="headerlink" title="SQL概述"></a>SQL概述</h1><p>Structured Query Language</p>
<p>用于访问和处理数据库的标准的计算机语言</p>
<p>适用于所有关系型数据库</p>
<p>目前很多数据库系统只支持SQL-99的部分特征，而大部分数据库系统都能支持1992年制定的SQL-92</p>
<h1 id="Sql特点"><a href="#Sql特点" class="headerlink" title="Sql特点"></a>Sql特点</h1><ul>
<li>综合统一性，不同数据库的支持的SQL稍有不同</li>
<li>非过程化语言</li>
<li>简捷</li>
<li>一种语法结构，两种使用方式</li>
</ul>
<h1 id="Sql-语言组成"><a href="#Sql-语言组成" class="headerlink" title="Sql 语言组成"></a>Sql 语言组成</h1><h2 id="数据定义语言-DDL-Data-Definition-Language"><a href="#数据定义语言-DDL-Data-Definition-Language" class="headerlink" title="数据定义语言-DDL Data Definition Language"></a>数据定义语言-DDL Data Definition Language</h2><p>对数据库和表的常用操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 查看所有数据库</span><br><span class="line"><span class="keyword">show</span> databases;</span><br><span class="line"># 创建数据库</span><br><span class="line"><span class="keyword">create</span> database [if <span class="keyword">not</span> exist] mydb [charset<span class="operator">=</span>utf8mb4]</span><br><span class="line"># 切换选择数据库</span><br><span class="line">use mydb;</span><br><span class="line"># 删除数据库</span><br><span class="line"><span class="keyword">drop</span> database [if <span class="keyword">exists</span>] mydb;</span><br><span class="line"># 修改数据库编码</span><br><span class="line"><span class="keyword">alter</span> database mydb <span class="type">character</span> <span class="keyword">set</span> utf8;</span><br><span class="line"></span><br><span class="line"># 查看当前数据库的所有表名称</span><br><span class="line"><span class="keyword">show</span> tables;</span><br><span class="line"># 查看指定某个表的创建语句</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> 表名；</span><br><span class="line"># 查看表结构</span><br><span class="line"><span class="keyword">desc</span> 表名</span><br><span class="line"># 删除表</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> 表名</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> [if <span class="keyword">not</span> <span class="keyword">exists</span>]表名(</span><br><span class="line">  字段名<span class="number">1</span> 类型[(宽度)] [约束条件] [comment <span class="string">&#x27;字段说明&#x27;</span>],</span><br><span class="line">  字段名<span class="number">2</span> 类型[(宽度)] [约束条件] [comment <span class="string">&#x27;字段说明&#x27;</span>]</span><br><span class="line">)[表的一些设置];</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span>  <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> student(</span><br><span class="line">    sid <span class="type">int</span>,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 修改表添加列</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 列名 类型(长度) [约束];</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">ADD</span> `dept` <span class="type">VARCHAR</span>(<span class="number">20</span>); </span><br><span class="line"></span><br><span class="line"># 修改列名和类型</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 change 旧列名 新列名 类型(长度) 约束; </span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student change `dept` department <span class="type">VARCHAR</span>(<span class="number">30</span>); </span><br><span class="line"></span><br><span class="line"># 修改表删除列</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">drop</span> 列名;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> student <span class="keyword">DROP</span> department;</span><br><span class="line"></span><br><span class="line"># 修改表名</span><br><span class="line">rename <span class="keyword">table</span> 表名 <span class="keyword">to</span> 新表名;</span><br><span class="line"></span><br><span class="line">rename <span class="keyword">table</span> `student`  <span class="keyword">to</span> stu;</span><br></pre></td></tr></table></figure>
<p><strong>表的数据类型</strong></p>
<ul>
<li>数值</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>大小</strong></th>
<th><strong>范围（有符号）</strong></th>
<th><strong>范围（无符号）</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>TINYINT</strong></td>
<td>1 byte</td>
<td>(-128，127)</td>
<td>(0，255)</td>
<td>小整数值</td>
</tr>
<tr>
<td><strong>SMALLINT</strong></td>
<td>2 bytes</td>
<td>(-32768，32767)</td>
<td>(0，65535)</td>
<td>大整数值</td>
</tr>
<tr>
<td><strong>MEDIUMINT</strong></td>
<td>3 bytes</td>
<td>(-8388608，8388607)</td>
<td>(0，16777215)</td>
<td>大整数值</td>
</tr>
<tr>
<td><strong>INT</strong>/<strong>INTEGER</strong></td>
<td>4 bytes</td>
<td>(-2147483648，2147483647)</td>
<td>(0，4294 967295)</td>
<td>大整数值</td>
</tr>
<tr>
<td><strong>BIGINT</strong></td>
<td>8 bytes</td>
<td>(-9,223,372,036,854,775,808，9,223,372,036,854,775,807)</td>
<td>(0，18 446 744 073 709 551 615)</td>
<td>极大整数值</td>
</tr>
<tr>
<td><strong>FLOAT</strong></td>
<td>4 bytes</td>
<td>(-3.402,823,466,351,E+38，3.402,823,466,E+38)</td>
<td>0，(1.175,494,351,E-38，3.402,823,466,E+38)</td>
<td>单精度     浮点数值</td>
</tr>
<tr>
<td><strong>DOUBLE</strong></td>
<td>8 bytes</td>
<td>(-1.797,693,134,862,315,7E+308，1.797,693,134,862,315,7E+308)</td>
<td>0，(2.225,073,858,507,201,4,E-308，1.797,693,134,862,315,7,E+308)</td>
<td>双精度     浮点数值</td>
</tr>
<tr>
<td><strong>DECIMAL</strong></td>
<td></td>
<td>依赖于M和D的值</td>
<td>依赖于M和D的值</td>
<td>小数值</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>日期和时间</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>DATE</strong></th>
<th><strong>3</strong></th>
<th><strong>1000-01-01/9999-12-31</strong></th>
<th><strong>YYYY-MM-DD</strong></th>
<th><strong>日期值</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>TIME</strong></td>
<td>3</td>
<td>‘-838:59:59’/‘838:59:59’</td>
<td>HH:MM:SS</td>
<td>时间值或持续时间</td>
</tr>
<tr>
<td><strong>YEAR</strong></td>
<td>1</td>
<td>1901/2155</td>
<td>YYYY</td>
<td>年份值</td>
</tr>
<tr>
<td><strong>DATETIME</strong></td>
<td>8</td>
<td>1000-01-01 00:00:00/9999-12-31  23:59:59</td>
<td>YYYY-MM-DD HH:MM:SS</td>
<td>混合日期和时间值</td>
</tr>
<tr>
<td><strong>TIMESTAMP</strong></td>
<td>4</td>
<td>1970-01-01 00:00:00/2038  结束时间是第 2147483647 秒，北京时间2038-1-19  11:14:07，格林尼治时间  2038年1月19日  凌晨  03:14:07</td>
<td>YYYYMMDD HHMMSS</td>
<td>混合日期和时间值，时间戳</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>字符串</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>大小</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CHAR</strong></td>
<td>0-255 bytes</td>
<td>定长字符串</td>
</tr>
<tr>
<td><strong>VARCHAR</strong></td>
<td>0-65535 bytes</td>
<td>变长字符串</td>
</tr>
<tr>
<td><strong>TINYBLOB</strong></td>
<td>0-255 bytes</td>
<td>不超过 255 个字符的二进制字符串</td>
</tr>
<tr>
<td><strong>TINYTEXT</strong></td>
<td>0-255 bytes</td>
<td>短文本字符串</td>
</tr>
<tr>
<td><strong>BLOB</strong></td>
<td>0-65 535 bytes</td>
<td>二进制形式的长文本数据</td>
</tr>
<tr>
<td><strong>TEXT</strong></td>
<td>0-65 535 bytes</td>
<td>长文本数据</td>
</tr>
<tr>
<td><strong>MEDIUMBLOB</strong></td>
<td>0-16 777 215 bytes</td>
<td>二进制形式的中等长度文本数据</td>
</tr>
<tr>
<td><strong>MEDIUMTEXT</strong></td>
<td>0-16 777 215 bytes</td>
<td>中等长度文本数据</td>
</tr>
<tr>
<td><strong>LONGBLOB</strong></td>
<td>0-4 294 967 295 bytes</td>
<td>二进制形式的极大文本数据</td>
</tr>
<tr>
<td><strong>LONGTEXT</strong></td>
<td>0-4 294 967 295 bytes</td>
<td>极大文本数据</td>
</tr>
</tbody>
</table>
</div>
<h2 id="数据操纵语言-DML-Data-Manipulation-Language"><a href="#数据操纵语言-DML-Data-Manipulation-Language" class="headerlink" title="数据操纵语言-DML Data Manipulation Language"></a>数据操纵语言-DML Data Manipulation Language</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">insert</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表 (列名<span class="number">1</span>,列名<span class="number">2</span>,列名<span class="number">3.</span>..) <span class="keyword">values</span> (值<span class="number">1</span>,值<span class="number">2</span>,值<span class="number">3.</span>..);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表 <span class="keyword">values</span> (值<span class="number">1</span>,值<span class="number">2</span>,值<span class="number">3.</span>..);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">1001</span>,<span class="string">&#x27;北京&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># <span class="keyword">delete</span></span><br><span class="line"># <span class="keyword">delete</span>只删除内容</span><br><span class="line"># <span class="keyword">truncate</span>类似于<span class="keyword">drop</span> <span class="keyword">table</span> ，可以理解为是将整个表删除，然后再创建该表；</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> 表名 [<span class="keyword">where</span> 条件];</span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> 表名 # 清空表数据</span><br><span class="line"><span class="keyword">truncate</span> 表名    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># <span class="keyword">update</span></span><br><span class="line"><span class="keyword">update</span> 表名 <span class="keyword">set</span> 字段名<span class="operator">=</span>值,字段名<span class="operator">=</span>值... <span class="keyword">where</span> 条件;</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> student <span class="keyword">set</span> address <span class="operator">=</span> <span class="string">&#x27;重庆’; </span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<h2 id="数据控制语言-DCL"><a href="#数据控制语言-DCL" class="headerlink" title="数据控制语言-DCL"></a>数据控制语言-DCL</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># <span class="keyword">GRANT</span></span><br><span class="line"># 用于授予用户或角色对数据库对象的特定权限，例如<span class="keyword">SELECT</span>、<span class="keyword">INSERT</span>、<span class="keyword">UPDATE</span>、<span class="keyword">DELETE</span>等。<span class="keyword">GRANT</span>语句可以授权用户执行特定操作或访问特定数据</span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> table_name <span class="keyword">TO</span> user_name;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">REVOKE</span></span><br><span class="line"># 用于撤销用户或角色对数据库对象的权限。<span class="keyword">REVOKE</span>语句可以取消先前授予的权限，限制用户的访问或操作权限。</span><br><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> table_name <span class="keyword">FROM</span> user_name;</span><br></pre></td></tr></table></figure>
<h2 id="数据查询语言-DQL"><a href="#数据查询语言-DQL" class="headerlink" title="数据查询语言-DQL"></a>数据查询语言-DQL</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 基本查询</span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">  [<span class="keyword">all</span><span class="operator">|</span><span class="keyword">distinct</span>]</span><br><span class="line">  <span class="operator">&lt;</span>目标列的表达式<span class="number">1</span><span class="operator">&gt;</span> [<span class="keyword">as</span>] [别名],</span><br><span class="line">  <span class="operator">&lt;</span>目标列的表达式<span class="number">2</span><span class="operator">&gt;</span> [<span class="keyword">as</span>] [别名]...</span><br><span class="line"><span class="keyword">from</span> <span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span> [<span class="keyword">as</span>] [别名],<span class="operator">&lt;</span>表名或视图名<span class="operator">&gt;</span> [别名]...</span><br><span class="line">[<span class="keyword">where</span><span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>]</span><br><span class="line">[<span class="keyword">group</span> <span class="keyword">by</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> </span><br><span class="line">[<span class="keyword">having</span> <span class="operator">&lt;</span>条件表达式<span class="operator">&gt;</span>]]</span><br><span class="line">[<span class="keyword">order</span> <span class="keyword">by</span> <span class="operator">&lt;</span>列名<span class="operator">&gt;</span> [<span class="keyword">asc</span><span class="operator">|</span><span class="keyword">desc</span>]]</span><br><span class="line">[limit <span class="operator">&lt;</span>数字或者列表<span class="operator">&gt;</span>];</span><br><span class="line"></span><br><span class="line"># 去掉重复值</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> price <span class="keyword">from</span> product;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="四种运算符"><a href="#四种运算符" class="headerlink" title="四种运算符"></a>四种运算符</h3><blockquote>
<p>算术运算符</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>算术运算符</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>+</strong></td>
<td>加法运算</td>
</tr>
<tr>
<td><strong>-</strong></td>
<td>减法运算</td>
</tr>
<tr>
<td><strong>*</strong></td>
<td>乘法运算</td>
</tr>
<tr>
<td><strong>/</strong> <strong>或</strong> <strong>DIV</strong></td>
<td>除法运算，返回商</td>
</tr>
<tr>
<td><strong>%</strong> <strong>或</strong> <strong>MOD</strong></td>
<td>求余运算，返回余数</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">6</span> <span class="operator">+</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="number">6</span> <span class="operator">-</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="number">6</span> <span class="operator">*</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="number">6</span> <span class="operator">/</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="number">6</span> <span class="operator">%</span> <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 将每件商品的价格加10</span></span><br><span class="line"><span class="keyword">select</span> name,price <span class="operator">+</span> <span class="number">10</span> <span class="keyword">as</span> new_price <span class="keyword">from</span> product;</span><br><span class="line"><span class="comment">-- 将所有商品的价格上调10%</span></span><br><span class="line"><span class="keyword">select</span> pname,price <span class="operator">*</span> <span class="number">1.1</span> <span class="keyword">as</span> new_price <span class="keyword">from</span> product;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>比较运算符</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>比较运算符</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>=</strong></td>
<td>等于</td>
</tr>
<tr>
<td><strong>&lt;</strong>  <strong>和</strong>  <strong>&lt;=</strong></td>
<td>小于和小于等于</td>
</tr>
<tr>
<td><strong>&gt;</strong>  <strong>和</strong>  <strong>&gt;=</strong></td>
<td>大于和大于等于</td>
</tr>
<tr>
<td><strong>&lt;=&gt;</strong></td>
<td>安全的等于，两个操作码均为NULL时，其所得值为1；而当一个操作码为NULL时，其所得值为0</td>
</tr>
<tr>
<td><strong>&lt;&gt; 或!=</strong></td>
<td>不等于</td>
</tr>
<tr>
<td><strong>IS NULL</strong> <strong>或</strong> <strong>ISNULL</strong></td>
<td>判断一个值是否为  NULL</td>
</tr>
<tr>
<td><strong>IS NOT NULL</strong></td>
<td>判断一个值是否不为  NULL</td>
</tr>
<tr>
<td><strong>LEAST</strong></td>
<td>当有两个或多个参数时，返回最小值</td>
</tr>
<tr>
<td><strong>GREATEST</strong></td>
<td>当有两个或多个参数时，返回最大值</td>
</tr>
<tr>
<td><strong>BETWEEN AND</strong></td>
<td>判断一个值是否落在两个值之间</td>
</tr>
<tr>
<td><strong>IN</strong></td>
<td>判断一个值是IN列表中的任意一个值</td>
</tr>
<tr>
<td><strong>NOT IN</strong></td>
<td>判断一个值不是IN列表中的任意一个值</td>
</tr>
<tr>
<td><strong>LIKE</strong></td>
<td>通配符匹配</td>
</tr>
<tr>
<td><strong>REGEXP</strong></td>
<td>正则表达式匹配</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询商品名称为“海尔洗衣机”的商品所有信息：</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> pname <span class="operator">=</span> <span class="string">&#x27;海尔洗衣机&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 查询价格为800商品</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> price <span class="operator">=</span> <span class="number">800</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 查询价格不是800的所有商品</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> price <span class="operator">!=</span> <span class="number">800</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> price <span class="operator">&lt;&gt;</span> <span class="number">800</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> <span class="keyword">not</span>(price <span class="operator">=</span> <span class="number">800</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 查询商品价格大于60元的所有商品信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> price <span class="operator">&gt;</span> <span class="number">60</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 查询商品价格在200到1000之间所有商品</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> price <span class="operator">&gt;=</span> <span class="number">200</span> <span class="keyword">and</span> price <span class="operator">&lt;=</span><span class="number">1000</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> price <span class="keyword">between</span> <span class="number">200</span> <span class="keyword">and</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询商品价格是200或800的所有商品</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> price <span class="operator">=</span> <span class="number">200</span> <span class="keyword">or</span> price <span class="operator">=</span> <span class="number">800</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> price <span class="keyword">in</span> (<span class="number">200</span>,<span class="number">800</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询含有‘裤&#x27;字的所有商品</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> pname <span class="keyword">like</span> <span class="string">&#x27;%裤%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询以&#x27;海&#x27;开头的所有商品</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> pname <span class="keyword">like</span> <span class="string">&#x27;海%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询第二个字为&#x27;蔻&#x27;的所有商品</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> pname <span class="keyword">like</span> <span class="string">&#x27;_蔻%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询category_id为null的商品</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> category_id <span class="keyword">is</span> <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 查询category_id不为null分类的商品</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">where</span> category_id <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用least求最小值</span></span><br><span class="line"><span class="keyword">select</span> least(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>); <span class="comment">-- 10</span></span><br><span class="line"><span class="keyword">select</span> least(<span class="number">10</span>, <span class="keyword">null</span> , <span class="number">30</span>); <span class="comment">-- null</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 使用greatest求最大值</span></span><br><span class="line"><span class="keyword">select</span> greatest(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">select</span> greatest(<span class="number">10</span>, <span class="keyword">null</span>, <span class="number">30</span>); <span class="comment">-- null</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>正则常用匹配</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>模式</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>^</strong></td>
<td>匹配输入字符串的开始位置。</td>
</tr>
<tr>
<td><strong>$</strong></td>
<td>匹配输入字符串的结束位置。</td>
</tr>
<tr>
<td><strong>.</strong></td>
<td>匹配除 “\n” 之外的任何单个字符。</td>
</tr>
<tr>
<td><strong>[…]</strong></td>
<td>字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配  “plain” 中的  ‘a’。</td>
</tr>
<tr>
<td><strong><sup><a href="#fn_..." id="reffn_...">...</a></sup></strong></td>
<td>负值字符集合。匹配未包含的任意字符。例如，  ‘<sup><a href="#fn_abc" id="reffn_abc">abc</a></sup>‘ 可以匹配  “plain” 中的’p’。</td>
</tr>
<tr>
<td>**p1\</td>
<td>p2\</td>
<td>p3**</td>
<td>匹配 p1 或 p2  或 p3。例如，’z\</td>
<td>food’ 能匹配  “z” 或  “food”。’(z\</td>
<td>f)ood’ 则匹配  “zood”  或  “food”。</td>
</tr>
<tr>
<td><strong>*</strong></td>
<td><strong>匹配前面的子表达式零次或多次。例如，**</strong>zo*<strong> </strong>能匹配<strong> </strong>“z”<strong> </strong>以及<strong> </strong>“zoo”<strong><strong>。<em>*</em></strong></strong> <strong>等价于**</strong>{0,}<strong>**。</strong></td>
</tr>
<tr>
<td><strong>+</strong></td>
<td>匹配前面的子表达式一次或多次。例如，’zo+’  能匹配  “zo” 以及  “zoo”，但不能匹配  “z”。+ 等价于  {1,}。</td>
</tr>
<tr>
<td><strong>{n}</strong></td>
<td>n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’  不能匹配  “Bob” 中的  ‘o’，但是能匹配  “food”  中的两个 o。</td>
</tr>
<tr>
<td><strong>{n,m}</strong></td>
<td>m 和 n 均为非负整数，其中n  &lt;= m。最少匹配 n 次且最多匹配 m 次。</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- ^ 在字符串开始处进行匹配</span></span><br><span class="line"><span class="keyword">SELECT</span>  <span class="string">&#x27;abc&#x27;</span> REGEXP <span class="string">&#x27;^a&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- $ 在字符串末尾开始匹配</span></span><br><span class="line"><span class="keyword">SELECT</span>  <span class="string">&#x27;abc&#x27;</span> REGEXP <span class="string">&#x27;a$&#x27;</span>;</span><br><span class="line"><span class="keyword">SELECT</span>  <span class="string">&#x27;abc&#x27;</span> REGEXP <span class="string">&#x27;c$’;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- . 匹配任意字符</span></span><br><span class="line"><span class="string">SELECT  &#x27;</span>abc<span class="string">&#x27; REGEXP &#x27;</span>.b<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">SELECT  &#x27;</span>abc<span class="string">&#x27; REGEXP &#x27;</span>.c<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">SELECT  &#x27;</span>abc<span class="string">&#x27; REGEXP &#x27;</span>a.<span class="string">&#x27;;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">-- [...] 匹配括号内的任意单个字符</span></span><br><span class="line"><span class="string">SELECT  &#x27;</span>abc<span class="string">&#x27; REGEXP &#x27;</span>[xyz]<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">SELECT  &#x27;</span>abc<span class="string">&#x27; REGEXP &#x27;</span>[xaz]<span class="string">&#x27;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- [^...] 注意^符合只有在[]内才是取反的意思，在别的地方都是表示开始处匹配</span></span><br><span class="line"><span class="string">SELECT  &#x27;</span>a<span class="string">&#x27; REGEXP &#x27;</span>[<span class="operator">^</span>abc]<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">SELECT  &#x27;</span>x<span class="string">&#x27; REGEXP &#x27;</span>[<span class="operator">^</span>abc]<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">SELECT  &#x27;</span>abc<span class="string">&#x27; REGEXP &#x27;</span>[<span class="operator">^</span>a]<span class="string">&#x27;;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">-- a* 匹配0个或多个a,包括空字符串。 可以作为占位符使用.有没有指定字符都可以匹配到数据</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">SELECT &#x27;</span>stab<span class="string">&#x27; REGEXP &#x27;</span>.ta<span class="operator">*</span>b<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">SELECT &#x27;</span>stb<span class="string">&#x27; REGEXP &#x27;</span>.ta<span class="operator">*</span>b<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">SELECT &#x27;&#x27; REGEXP &#x27;</span>a<span class="operator">*</span><span class="string">&#x27;;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">-- a+  匹配1个或者多个a,但是不包括空字符</span></span><br><span class="line"><span class="string">SELECT &#x27;</span>stab<span class="string">&#x27; REGEXP &#x27;</span>.ta<span class="operator">+</span>b<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">SELECT &#x27;</span>stb<span class="string">&#x27; REGEXP &#x27;</span>.ta<span class="operator">+</span>b<span class="string">&#x27;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- a?  匹配0个或者1个a</span></span><br><span class="line"><span class="string">SELECT &#x27;</span>stb<span class="string">&#x27; REGEXP &#x27;</span>.ta?b<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">SELECT &#x27;</span>stab<span class="string">&#x27; REGEXP &#x27;</span>.ta?b<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">SELECT &#x27;</span>staab<span class="string">&#x27; REGEXP &#x27;</span>.ta?b<span class="string">&#x27;;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">-- a1|a2  匹配a1或者a2，</span></span><br><span class="line"><span class="string">SELECT &#x27;</span>a<span class="string">&#x27; REGEXP &#x27;</span>a<span class="operator">|</span>b<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">SELECT &#x27;</span>b<span class="string">&#x27; REGEXP &#x27;</span>a<span class="operator">|</span>b<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">SELECT &#x27;</span>b<span class="string">&#x27; REGEXP &#x27;</span><span class="operator">^</span>(a<span class="operator">|</span>b)<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">SELECT &#x27;</span>a<span class="string">&#x27; REGEXP &#x27;</span><span class="operator">^</span>(a<span class="operator">|</span>b)<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">SELECT &#x27;</span>c<span class="string">&#x27; REGEXP &#x27;</span><span class="operator">^</span>(a<span class="operator">|</span>b)<span class="string">&#x27;;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">-- a&#123;m&#125; 匹配m个a</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">SELECT &#x27;</span>auuuuc<span class="string">&#x27; REGEXP &#x27;</span>au&#123;<span class="number">4</span>&#125;c<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">SELECT &#x27;</span>auuuuc<span class="string">&#x27; REGEXP &#x27;</span>au&#123;<span class="number">3</span>&#125;c<span class="string">&#x27;;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- a&#123;m,n&#125; 匹配m到n个a,包含m和n</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">SELECT &#x27;</span>auuuuc<span class="string">&#x27; REGEXP &#x27;</span>au&#123;<span class="number">3</span>,<span class="number">5</span>&#125;c<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">SELECT &#x27;</span>auuuuc<span class="string">&#x27; REGEXP &#x27;</span>au&#123;<span class="number">4</span>,<span class="number">5</span>&#125;c<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">SELECT &#x27;</span>auuuuc<span class="string">&#x27; REGEXP &#x27;</span>au&#123;<span class="number">5</span>,<span class="number">10</span>&#125;c<span class="string">&#x27;;</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">-- (abc) abc作为一个序列匹配，不用括号括起来都是用单个字符去匹配，如果要把多个字符作为一个整体去匹配就需要用到括号，所以括号适合上面的所有情况。</span></span><br><span class="line"><span class="string">SELECT &#x27;</span>xababy<span class="string">&#x27; REGEXP &#x27;</span>x(abab)y<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">SELECT &#x27;</span>xababy<span class="string">&#x27; REGEXP &#x27;</span>x(ab)<span class="operator">*</span>y<span class="string">&#x27;;</span></span><br><span class="line"><span class="string">SELECT &#x27;</span>xababy<span class="string">&#x27; REGEXP &#x27;</span>x(ab)&#123;<span class="number">1</span>,<span class="number">2</span>&#125;y<span class="string">&#x27;;</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>逻辑运算符</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>逻辑运算符</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>NOT</strong> <strong>或者</strong> <strong>!</strong></td>
<td>逻辑非</td>
</tr>
<tr>
<td><strong>AND</strong> <strong>或者</strong> <strong>&amp;&amp;</strong></td>
<td>逻辑与</td>
</tr>
<tr>
<td><strong>OR</strong> <strong>或者</strong> **\</td>
<td>\</td>
<td>**</td>
<td>逻辑或</td>
</tr>
<tr>
<td><strong>XOR</strong></td>
<td>逻辑异或</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>位运算符</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>位运算符</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>**\</td>
<td>**</td>
<td>按位或</td>
</tr>
<tr>
<td><strong>&amp;</strong></td>
<td>按位与</td>
</tr>
<tr>
<td><strong>^</strong></td>
<td>按位异或</td>
</tr>
<tr>
<td><strong>&lt;&lt;</strong></td>
<td>按位左移</td>
</tr>
<tr>
<td><strong>&gt;&gt;</strong></td>
<td>按位右移</td>
</tr>
<tr>
<td><strong>~</strong></td>
<td>按位取反，反转所有比特</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">3</span><span class="operator">&amp;</span><span class="number">5</span>; <span class="comment">-- 位与</span></span><br><span class="line"><span class="keyword">select</span> <span class="number">3</span><span class="operator">|</span><span class="number">5</span>; <span class="comment">-- 位或</span></span><br><span class="line"><span class="keyword">select</span> <span class="number">3</span><span class="operator">^</span><span class="number">5</span>; <span class="comment">-- 位异或</span></span><br><span class="line"><span class="keyword">select</span> <span class="number">3</span><span class="operator">&gt;&gt;</span><span class="number">1</span>; <span class="comment">-- 位左移</span></span><br><span class="line"><span class="keyword">select</span> <span class="number">3</span><span class="operator">&lt;&lt;</span><span class="number">1</span>; <span class="comment">-- 位右移</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">~</span><span class="number">3</span>;   <span class="comment">-- 位取反</span></span><br></pre></td></tr></table></figure>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><ul>
<li>asc代表升序，desc代表降序，如果不写默认升序</li>
<li>order by用于子句中可以支持单个字段，多个字段，表达式，函数，别名</li>
<li>order by子句，放在查询语句的最后面。LIMIT子句除外</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line"> 字段名<span class="number">1</span>，字段名<span class="number">2</span>，……</span><br><span class="line"><span class="keyword">from</span> 表名</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> 字段名<span class="number">1</span> [<span class="keyword">asc</span><span class="operator">|</span><span class="keyword">desc</span>]，字段名<span class="number">2</span>[<span class="keyword">asc</span><span class="operator">|</span><span class="keyword">desc</span>]……</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1.使用价格排序(降序)</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">order</span> <span class="keyword">by</span> price <span class="keyword">desc</span>;</span><br><span class="line"><span class="comment">-- 2.在价格排序(降序)的基础上，以分类排序(降序)</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product <span class="keyword">order</span> <span class="keyword">by</span> price <span class="keyword">desc</span>,category_id <span class="keyword">asc</span>;</span><br><span class="line"><span class="comment">-- 3.显示商品的价格(去重复)，并排序(降序)</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> price <span class="keyword">from</span> product <span class="keyword">order</span> <span class="keyword">by</span> price <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>
<h3 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>聚合函数</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>count()</strong></td>
<td>统计指定列不为NULL的记录行数；</td>
</tr>
<tr>
<td><strong>sum()</strong></td>
<td>计算指定列的数值和，如果指定列类型不是数值类型，那么计算结果为0</td>
</tr>
<tr>
<td><strong>max()</strong></td>
<td>计算指定列的最大值，如果指定列是字符串类型，那么使用字符串排序运算；</td>
</tr>
<tr>
<td><strong>min()</strong></td>
<td>计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算；</td>
</tr>
<tr>
<td><strong>avg()</strong></td>
<td>计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1 查询商品的总条数</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> product;</span><br><span class="line"><span class="comment">-- 2 查询价格大于200商品的总条数</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> product <span class="keyword">where</span> price <span class="operator">&gt;</span> <span class="number">200</span>;</span><br><span class="line"><span class="comment">-- 3 查询分类为&#x27;c001&#x27;的所有商品的总和</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">sum</span>(price) <span class="keyword">from</span> product <span class="keyword">where</span> category_id <span class="operator">=</span> <span class="string">&#x27;c001&#x27;</span>;</span><br><span class="line"><span class="comment">-- 4 查询商品的最大价格</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(price) <span class="keyword">from</span> product;</span><br><span class="line"><span class="comment">-- 5 查询商品的最小价格</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">min</span>(price) <span class="keyword">from</span> product;</span><br><span class="line"><span class="comment">-- 6 查询分类为&#x27;c002&#x27;所有商品的平均价格</span></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">avg</span>(price) <span class="keyword">from</span> product <span class="keyword">where</span> category_id <span class="operator">=</span> <span class="string">&#x27;c002&#x27;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>对null的处理</p>
</blockquote>
<ol>
<li>count函数对null值的处理：如果count函数的参数为星号（*），则统计所有记录的个数。而如果参数为某字段，不统计含null值的记录个数。</li>
<li>sum和avg函数对null值的处理：这两个函数忽略null值的存在，就好象该条记录不存在一样。</li>
<li>max和min函数对null值的处理：max和min两个函数同样忽略null值的存在。</li>
</ol>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><blockquote>
<p>聚合函数</p>
</blockquote>
<ul>
<li>group_concat()函数首先根据group by指定的列进行分组，并且用分隔符分隔，将同一个分组中的值连接起来，返回一个字符串结果。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">group_concat([<span class="keyword">distinct</span>] 字段名 [<span class="keyword">order</span> <span class="keyword">by</span> 排序字段 <span class="keyword">asc</span><span class="operator">/</span><span class="keyword">desc</span>] [separator <span class="string">&#x27;分隔符&#x27;</span>])</span><br><span class="line"></span><br><span class="line"># 使用<span class="keyword">distinct</span>可以排除重复值</span><br><span class="line"># 如果需要对结果中的值进行排序，可以使用<span class="keyword">order</span> <span class="keyword">by</span>子句</span><br><span class="line"># separator是一个字符串值，默认为逗号</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> group_concat(emp_name) <span class="keyword">from</span> emp;</span><br><span class="line"><span class="keyword">select</span> department,group_concat(emp_name separator <span class="string">&#x27;;&#x27;</span> ) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> department; </span><br><span class="line"><span class="keyword">select</span> department,group_concat(emp_name <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span> separator <span class="string">&#x27;;&#x27;</span> ) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> department;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>数学函数</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>函数名</strong></th>
<th><strong>描述</strong></th>
<th><strong>实例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ABS(x)</strong></td>
<td>返回 x 的绝对值</td>
<td>返回 -1 的绝对值：<br/>SELECT  ABS(-1) — 返回1</td>
</tr>
<tr>
<td><strong>CEIL(x)</strong></td>
<td>返回大于或等于 x 的最小整数</td>
<td>SELECT  CEIL(1.5) — 返回2</td>
</tr>
<tr>
<td><strong>FLOOR(x)</strong></td>
<td>返回小于或等于 x 的最大整数</td>
<td>小于或等于  1.5 的整数： <br/>SELECT  FLOOR(1.5) — 返回1</td>
</tr>
<tr>
<td><strong>GREATEST(expr1, expr2,  …)</strong></td>
<td>返回列表中的最大值</td>
<td>返回以下数字列表中的最大值：  <br/>SELECT  GREATEST(3, 12, 34, 8, 25); — 34  <br/>返回以下字符串列表中的最大值：  <br/>SELECT  GREATEST(“Google”, “Runoob”, “Apple”);  — Runoob</td>
</tr>
<tr>
<td><strong>LEAST(expr1, expr2, expr3, …)</strong></td>
<td>返回列表中的最小值</td>
<td>返回以下数字列表中的最小值： <br/>SELECT  LEAST(3, 12, 34, 8, 25); — 3 <br/>返回以下字符串列表中的最小值：<br/>SELECT  LEAST(“Google”, “Runoob”,  “Apple”);  — Apple</td>
</tr>
<tr>
<td><strong>MAX(expression)</strong></td>
<td>返回字段 expression 中的最大值</td>
<td>返回数据表Products中字段Price的最大值 <br/>SELECT MAX(Price) AS LargestPrice FROM Products;</td>
</tr>
<tr>
<td><strong>MIN(expression)</strong></td>
<td>返回字段 expression 中的最小值</td>
<td>返回数据表  Products 中字段  Price 的最小值：<br/>SELECT  MIN(Price) AS MinPrice FROM Products;</td>
</tr>
<tr>
<td><strong>MOD(x,y)</strong></td>
<td>返回 x 除以 y 以后的余数</td>
<td>5 除于 2 的余数：  <br/>SELECT  MOD(5,2) — 1</td>
</tr>
<tr>
<td><strong>PI()</strong></td>
<td>返回圆周率(3.141593）</td>
<td>SELECT  PI()  —3.141593</td>
</tr>
<tr>
<td><strong>POW(x,y)</strong></td>
<td>返回 x 的 y 次方</td>
<td>2 的 3 次方：  SELECT  POW(2,3) — 8</td>
</tr>
<tr>
<td><strong>RAND()</strong></td>
<td>返回 0 到 1 的随机数</td>
<td>SELECT RAND() —0.93099315644334</td>
</tr>
<tr>
<td><strong>ROUND(x)</strong></td>
<td>返回离 x 最近的整数（遵循四舍五入）</td>
<td>SELECT  ROUND(1.23456) —1</td>
</tr>
<tr>
<td><strong>ROUND(x,y)</strong></td>
<td>返回指定位数的小数（遵循四舍五入）</td>
<td>SELECT  ROUND(1.23456,3) –1.235</td>
</tr>
<tr>
<td><strong>TRUNCATE(x,y)</strong></td>
<td>返回数值 x 保留到小数点后 y 位的值<br/>（与  ROUND 最大的区别是不会进行四舍五入）</td>
<td>SELECT  TRUNCATE(1.23456,3) — 1.234</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>字符串函数</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>函数</strong></th>
<th><strong>描述</strong></th>
<th><strong>实例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CHAR_LENGTH(s)</strong></td>
<td>返回字符串 s 的字符数</td>
<td>返回字符串  RUNOOB 的字符数  SELECT  CHAR_LENGTH(“RUNOOB”) AS LengthOfString;</td>
</tr>
<tr>
<td><strong>CHARACTER_LENGTH(s)</strong></td>
<td>返回字符串 s 的字符数</td>
<td>返回字符串  RUNOOB 的字符数  SELECT  CHARACTER_LENGTH(“RUNOOB”) AS LengthOfString;</td>
</tr>
<tr>
<td><strong>CONCAT(s1,s2…sn)</strong></td>
<td>字符串 s1,s2 等多个字符串合并为一个字符串</td>
<td>合并多个字符串  SELECT  CONCAT(“SQL “, “Runoob “, “Gooogle “,  “Facebook”) AS ConcatenatedString;</td>
</tr>
<tr>
<td><strong>CONCAT_WS(x, s1,s2…sn)</strong></td>
<td>同 CONCAT(s1,s2,…) 函数，但是每个字符串之间要加上 x，x 可以是分隔符</td>
<td>合并多个字符串，并添加分隔符：  SELECT  CONCAT_WS(“-“, “SQL”, “Tutorial”,  “is”, “fun!”)AS ConcatenatedString;</td>
</tr>
<tr>
<td><strong>FIELD(s,s1,s2…)</strong></td>
<td>返回第一个字符串 s 在字符串列表(s1,s2…)中的位置</td>
<td>返回字符串 c 在列表值中的位置：  SELECT  FIELD(“c”, “a”, “b”, “c”,  “d”, “e”);</td>
</tr>
<tr>
<td><strong>LTRIM(s)</strong></td>
<td>去掉字符串 s 开始处的空格</td>
<td>去掉字符串 RUNOOB开始处的空格： SELECT LTRIM(“    RUNOOB”) AS LeftTrimmedString;— RUNOOB**</td>
</tr>
<tr>
<td><strong>MID(s,n,len)</strong></td>
<td>从字符串 s 的 n 位置截取长度为  len 的子字符串，同  SUBSTRING(s,n,len)</td>
<td>从字符串  RUNOOB 中的第 2 个位置截取 3个  字符：  SELECT  MID(“RUNOOB”, 2, 3) AS ExtractString; — UNO</td>
</tr>
<tr>
<td><strong>POSITION(s1 IN s)</strong></td>
<td>从字符串 s 中获取 s1 的开始位置</td>
<td>返回字符串  abc 中 b 的位置：  SELECT  POSITION(‘b’ in ‘abc’) — 2</td>
</tr>
<tr>
<td><strong>REPLACE(s,s1,s2)</strong></td>
<td>将字符串 s2 替代字符串 s 中的字符串 s1</td>
<td>将字符串  abc 中的字符 a 替换为字符 x：  SELECT  REPLACE(‘abc’,’a’,’x’) —xbc</td>
</tr>
<tr>
<td><strong>REVERSE(s)</strong></td>
<td>将字符串s的顺序反过来</td>
<td>将字符串 abc 的顺序反过来：  SELECT  REVERSE(‘abc’)  — cba</td>
</tr>
<tr>
<td><strong>RIGHT(s,n)</strong></td>
<td>返回字符串 s 的后 n 个字符</td>
<td>返回字符串 runoob 的后两个字符：  SELECT RIGHT(‘runoob’,2) — ob</td>
</tr>
<tr>
<td><strong>RTRIM(s)</strong></td>
<td>去掉字符串 s 结尾处的空格</td>
<td>去掉字符串  RUNOOB 的末尾空格：  SELECT  RTRIM(“RUNOOB   “) AS  RightTrimmedString;  — RUNOOB</td>
</tr>
<tr>
<td><strong>STRCMP(s1,s2)</strong></td>
<td>比较字符串 s1 和 s2，如果 s1  与 s2  相等返回 0 ，如果  s1&gt;s2 返回 1，如果  s1&lt;s2 返回 -1</td>
<td>比较字符串：  SELECT  STRCMP(“runoob”, “runoob”); — 0</td>
</tr>
<tr>
<td><strong>SUBSTR(s, start, length)</strong></td>
<td>从字符串 s 的 start 位置截取长度为  length 的子字符串</td>
<td>从字符串  RUNOOB 中的第 2 个位置截取 3个  字符：  SELECT  SUBSTR(“RUNOOB”, 2, 3) AS ExtractString; — UNO</td>
</tr>
<tr>
<td><strong>SUBSTRING(s, start, length)</strong></td>
<td>从字符串 s 的 start 位置截取长度为  length 的子字符串</td>
<td>从字符串  RUNOOB 中的第 2 个位置截取 3个  字符：  SELECT  SUBSTRING(“RUNOOB”, 2, 3) AS ExtractString;  — UNO</td>
</tr>
<tr>
<td><strong>TRIM(s)</strong></td>
<td>去掉字符串 s 开始和结尾处的空格</td>
<td>去掉字符串 RUNOOB 的首尾空格：  SELECT TRIM(‘  RUNOOB  ‘) AS TrimmedString;</td>
</tr>
<tr>
<td><strong>UCASE(s)</strong></td>
<td>将字符串转换为大写</td>
<td>将字符串  runoob 转换为大写：  SELECT  UCASE(“runoob”); — RUNOOB</td>
</tr>
<tr>
<td><strong>UPPER(s)</strong></td>
<td>将字符串转换为大写</td>
<td>将字符串  runoob 转换为大写：  SELECT  UPPER(“runoob”); — RUNOOB</td>
</tr>
<tr>
<td><strong>LCASE(s)</strong></td>
<td>将字符串  s  的所有字母变成小写字母</td>
<td>字符串  RUNOOB 转换为小写：  SELECT LCASE(‘RUNOOB’) —  runoob</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>日期函数</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>函数名</strong></th>
<th><strong>描述</strong></th>
<th><strong>实例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>UNIX_TIMESTAMP()</strong></td>
<td>返回从1970-01-01  00:00:00到当前毫秒值</td>
<td>select  UNIX_TIMESTAMP() -&gt; 1632729059</td>
</tr>
<tr>
<td><strong>UNIX_TIMESTAMP(**</strong>DATE_STRING<strong>**)</strong></td>
<td>将制定日期转为毫秒值时间戳</td>
<td>SELECT  UNIX_TIMESTAMP(‘2011-12-07 13:01:03’);</td>
</tr>
<tr>
<td><strong>FROM_UNIXTIME(BIGINT UNIXTIME[,  STRING FORMAT])</strong></td>
<td>将毫秒值时间戳转为指定格式日期</td>
<td>SELECT  FROM_UNIXTIME(1598079966,’%Y-%m-%d %H:%i:%s’); -&gt; 2020-08-22 15-06-06</td>
</tr>
<tr>
<td><strong>CURDATE()</strong></td>
<td>返回当前日期</td>
<td>SELECT  CURDATE();  -&gt;  2018-09-19</td>
</tr>
<tr>
<td><strong>CURRENT_DATE()</strong></td>
<td>返回当前日期</td>
<td>SELECT  CURRENT_DATE();  -&gt;  2018-09-19</td>
</tr>
<tr>
<td><strong>CURRENT_TIME</strong></td>
<td>返回当前时间</td>
<td>SELECT CURRENT_TIME();  -&gt; 19:59:02</td>
</tr>
<tr>
<td><strong>CURTIME()</strong></td>
<td>返回当前时间</td>
<td>SELECT  CURTIME();  -&gt;  19:59:02</td>
</tr>
<tr>
<td><strong>CURRENT_TIMESTAMP()</strong></td>
<td>返回当前日期和时间</td>
<td>SELECT  CURRENT_TIMESTAMP()  -&gt;  2018-09-19 20:57:43</td>
</tr>
<tr>
<td><strong>DATE()</strong></td>
<td>从日期或日期时间表达式中提取日期值</td>
<td>SELECT  DATE(“2017-06-15”);    -&gt;  2017-06-15</td>
</tr>
<tr>
<td><strong>DATEDIFF(d1,d2)</strong></td>
<td>计算日期 d1-&gt;d2 之间相隔的天数</td>
<td>SELECT  DATEDIFF(‘2001-01-01’,’2001-02-02’)  -&gt;  -32</td>
</tr>
<tr>
<td><strong>TIMEDIFF(time1, time2)</strong></td>
<td>计算时间差值</td>
<td>SELECT TIMEDIFF(“13:10:11”, “13:10:10”);  -&gt; 00:00:01</td>
</tr>
<tr>
<td><strong>DATE_FORMAT(d,f)</strong></td>
<td>按表达式 f的要求显示日期 d</td>
<td>SELECT  DATE_FORMAT(‘2011-11-11 11:11:11’,’%Y-%m-%d %r’)  -&gt;  2011-11-11 11:11:11 AM</td>
</tr>
<tr>
<td><strong>STR_TO_DATE(string, format_mask)</strong></td>
<td>将字符串转变为日期</td>
<td>SELECT  STR_TO_DATE(“August 10 2017”, “%M %d %Y”);  -&gt;  2017-08-10</td>
</tr>
<tr>
<td><strong>DATE_SUB(date,INTERVAL expr type)</strong></td>
<td>函数从日期减去指定的时间间隔。</td>
<td>Orders 表中 OrderDate 字段减去 2 天：  SELECT  OrderId,DATE_SUB(OrderDate,INTERVAL 2  DAY) AS OrderPayDate  FROM  Orders</td>
</tr>
<tr>
<td><strong>ADDDATE/DATE_ADD(d，INTERVAL expr type)</strong></td>
<td>计算起始日期 d 加上一个时间段后的日期，type 值可以是<br/>·MICROSECOND  <br/>·SECOND  <br/>·MINUTE<br/>·HOUR <br/>·DAY<br/>·WEEK<br/>·MONTH<br/>·QUARTER<br/>·YEAR<br/>·DAY_MINUTE  <br/>·DAY_HOUR <br/>·YEAR_MONTH</td>
<td>SELECT DATE_ADD(“2017-06-15”, INTERVAL 10 DAY);    -&gt; 2017-06-25     <br/><br/>SELECT DATE_ADD(“2017-06-15 09:34:21”, INTERVAL 15 MINUTE);  -&gt; 2017-06-15 09:49:21     <br/><br/>SELECT DATE_ADD(“2017-06-15 09:34:21”, INTERVAL -3 HOUR);  -&gt;2017-06-15 06:34:21<br/><br/>SELECT DATE_ADD(“2017-06-15 09:34:21”, INTERVAL -3 HOUR);  -&gt;2017-04-15</td>
</tr>
<tr>
<td><strong>DATE_ADD(d，INTERVAL expr type)</strong></td>
<td>计算起始日期 d 加上一个时间段后的日期，type 值可以是： <br/>·SECOND_MICROSECOND  <br/>·MINUTE_MICROSECOND<br/>·MINUTE_SECOND  <br/>·HOUR_MICROSECOND  <br/>·HOUR_SECOND  <br/>·HOUR_MINUTE  <br/>·DAY_MICROSECOND  <br/>·DAY_SECOND<br/>·DAY_MINUTE  <br/>·DAY_HOUR<br/>·YEAR_MONTH</td>
<td>SELECT DATE_ADD(“2017-06-15”, INTERVAL 10 DAY);    -&gt; 2017-06-25<br/><br/>SELECT DATE_ADD(“2017-06-15 09:34:21”, INTERVAL 15 MINUTE);  -&gt; 2017-06-15 09:49:21     <br/><br/>SELECT DATE_ADD(“2017-06-15 09:34:21”, INTERVAL -3 HOUR);  -&gt;2017-06-15 06:34:21<br/><br/>SELECT DATE_ADD(“2017-06-15 09:34:21”, INTERVAL -3 HOUR);  -&gt;2017-04-15</td>
</tr>
<tr>
<td><strong>EXTRACT(type FROM d)</strong></td>
<td>从日期 d 中获取指定的值，type 指定返回的值。type可取值为：<br/>·MICROSECOND  <br/>·SECOND  <br/>·MINUTE  <br/>·HOUR  …..</td>
<td>SELECT EXTRACT(MINUTE FROM ‘2011-11-11 11:11:11’)   -&gt; 11</td>
</tr>
<tr>
<td><strong>LAST_DAY(d)</strong></td>
<td>返回给给定日期的那一月份的最后一天</td>
<td>SELECT  LAST_DAY(“2017-06-20”);  -&gt;  2017-06-30</td>
</tr>
<tr>
<td><strong>MAKEDATE(year, day-of-year)</strong></td>
<td>基于给定参数年份 year 和所在年中的天数序号  day-of-year 返回一个日期</td>
<td>SELECT  MAKEDATE(2017, 3);  -&gt;  2017-01-03</td>
</tr>
<tr>
<td><strong>YEAR(d)</strong></td>
<td>返回年份</td>
<td>SELECT YEAR(“2017-06-15”);  -&gt; 2017</td>
</tr>
<tr>
<td><strong>MONTH(d)</strong></td>
<td>回日期d中的月份值，1 到 12</td>
<td>SELECT  MONTH(‘2011-11-11 11:11:11’)  -&gt;11</td>
</tr>
<tr>
<td><strong>DAY(d)</strong></td>
<td>返回日期值 d 的日期部分</td>
<td>SELECT  DAY(“2017-06-15”);   -&gt;  15</td>
</tr>
<tr>
<td><strong>HOUR(t)</strong></td>
<td>返回 t 中的小时值</td>
<td>SELECT  HOUR(‘1:2:3’)  -&gt;  1</td>
</tr>
<tr>
<td><strong>MINUTE(t)</strong></td>
<td>返回 t 中的分钟值</td>
<td>SELECT  MINUTE(‘1:2:3’)  -&gt;  2</td>
</tr>
<tr>
<td><strong>SECOND(t)</strong></td>
<td>返回 t 中的秒钟值</td>
<td>SELECT  SECOND(‘1:2:3’)  -&gt;  3</td>
</tr>
<tr>
<td><strong>QUARTER(d)</strong></td>
<td>返回日期d是第几季节，返回 1 到 4</td>
<td>SELECT  QUARTER(‘2011-11-11 11:11:11’)  -&gt;  4</td>
</tr>
<tr>
<td><strong>YEAR(d)</strong></td>
<td>返回年份</td>
<td>SELECT YEAR(“2017-06-15”);  -&gt; 2017</td>
</tr>
<tr>
<td><strong>MONTH(d)</strong></td>
<td>返回日期d中的月份值，1 到 12</td>
<td>SELECT  MONTH(‘2011-11-11 11:11:11’)  -&gt;11</td>
</tr>
<tr>
<td><strong>DAY(d)</strong></td>
<td>返回日期值 d 的日期部分</td>
<td>SELECT  DAY(“2017-06-15”);   -&gt;  15</td>
</tr>
<tr>
<td><strong>HOUR(t)</strong></td>
<td>返回 t 中的小时值</td>
<td>SELECT  HOUR(‘1:2:3’)  -&gt;  1</td>
</tr>
<tr>
<td><strong>MINUTE(t)</strong></td>
<td>返回 t 中的分钟值</td>
<td>SELECT  MINUTE(‘1:2:3’)  -&gt;  2</td>
</tr>
<tr>
<td><strong>SECOND(t)</strong></td>
<td>返回 t 中的秒钟值</td>
<td>SELECT  SECOND(‘1:2:3’)  -&gt;  3</td>
</tr>
<tr>
<td><strong>WEEK(d)</strong></td>
<td>计算日期 d 是本年的第几个星期，范围是 0 到 53</td>
<td>SELECT WEEK(‘2011-11-11 11:11:11’)  -&gt; 45</td>
</tr>
<tr>
<td><strong>WEEKDAY(d)</strong></td>
<td>日期 d 是星期几，0 表示星期一，1 表示星期二</td>
<td>SELECT  WEEKDAY(“2017-06-15”);  -&gt;  3</td>
</tr>
<tr>
<td><strong>WEEKOFYEAR(d)</strong></td>
<td>计算日期 d 是本年的第几个星期，范围是 0 到 53</td>
<td>SELECT  WEEKOFYEAR(‘2011-11-11 11:11:11’)  -&gt;  45</td>
</tr>
<tr>
<td><strong>YEARWEEK(date, mode)</strong></td>
<td>返回年份及第几周（0到53），mode 中 0 表示周天，1表示周一，以此类推</td>
<td>SELECT  YEARWEEK(“2017-06-15”);  -&gt;  201724</td>
</tr>
<tr>
<td><strong>NOW()</strong></td>
<td>返回当前日期和时间</td>
<td>SELECT  NOW()  -&gt;  2018-09-19 20:57:43</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>控制流函数</p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>格式</strong></th>
<th><strong>解释</strong></th>
<th><strong>案例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>IF(expr,v1,v2)</strong></td>
<td>如果表达式 expr 成立，返回结果 v1；否则，返回结果 v2。</td>
<td>SELECT  IF(1 &gt; 0,’正确’,’错误’)    -&gt;正确</td>
</tr>
<tr>
<td><strong>IFNULL(v1,v2)</strong></td>
<td>如果 v1 的值不为  NULL，则返回 v1，否则返回 v2。</td>
<td>SELECT  IFNULL(null,’Hello Word’)  -&gt;Hello  Word</td>
</tr>
<tr>
<td><strong>ISNULL(expression)</strong></td>
<td>判断表达式是否为 NULL</td>
<td>SELECT  ISNULL(NULL);  -&gt;1</td>
</tr>
<tr>
<td><strong>NULLIF(expr1, expr2)</strong></td>
<td>比较两个字符串，如果字符串  expr1 与  expr2 相等  返回  NULL，否则返回  expr1</td>
<td>SELECT  NULLIF(25, 25);  -&gt;</td>
</tr>
<tr>
<td><strong>CASE expression</strong>    <br/>  <strong>WHEN condition1 THEN  result1</strong>    <br/>  <strong>WHEN condition2 THEN  result2</strong>    <strong>…</strong>    <br/>  <strong>WHEN conditionN THEN resultN</strong> <br/>  <strong>ELSE result</strong>  <br/><strong>END</strong></td>
<td>CASE 表示函数开始，END 表示函数结束。如果 condition1 成立，则返回 result1, 如果 condition2 成立，则返回 result2，当全部不成立则返回 result，而当有一个成立之后，后面的就不执行了。</td>
<td>select case 100 when 50 then ‘tom’ when 100 then ‘mary’else ‘tim’ end ;        <br/>select case when 1=2 then ‘tom’  when 2=2 then ‘mary’ else’tim’ end ;</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 方式1</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="operator">*</span>  ,</span><br><span class="line"><span class="keyword">case</span> </span><br><span class="line">  	<span class="keyword">when</span> payType<span class="operator">=</span><span class="number">1</span> <span class="keyword">then</span> <span class="string">&#x27;微信支付&#x27;</span> </span><br><span class="line">    <span class="keyword">when</span> payType<span class="operator">=</span><span class="number">2</span> <span class="keyword">then</span> <span class="string">&#x27;支付宝支付&#x27;</span> </span><br><span class="line">    <span class="keyword">when</span> payType<span class="operator">=</span><span class="number">3</span> <span class="keyword">then</span> <span class="string">&#x27;银行卡支付&#x27;</span> </span><br><span class="line">    <span class="keyword">else</span> <span class="string">&#x27;其他支付方式&#x27;</span> </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">as</span> payTypeStr</span><br><span class="line"><span class="keyword">from</span> orders;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 方式2</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="operator">*</span>  ,</span><br><span class="line"><span class="keyword">case</span> payType</span><br><span class="line">  	<span class="keyword">when</span> <span class="number">1</span> <span class="keyword">then</span> <span class="string">&#x27;微信支付&#x27;</span> </span><br><span class="line">    <span class="keyword">when</span> <span class="number">2</span> <span class="keyword">then</span> <span class="string">&#x27;支付宝支付&#x27;</span> </span><br><span class="line">    <span class="keyword">when</span> <span class="number">3</span> <span class="keyword">then</span> <span class="string">&#x27;银行卡支付&#x27;</span> </span><br><span class="line">    <span class="keyword">else</span> <span class="string">&#x27;其他支付方式&#x27;</span> </span><br><span class="line"><span class="keyword">end</span> <span class="keyword">as</span> payTypeStr</span><br><span class="line"><span class="keyword">from</span> orders;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>窗口函数</p>
</blockquote>
<ul>
<li>MySQL 8.0 新增窗口函数</li>
<li>又被称为开窗函数</li>
<li>非聚合窗口函数是相对于聚函数来说的. 聚合函数是对一组数据计算后返回单个值（即分组），非聚合函数一次只会处理一行数据</li>
<li>窗口聚合函数在行记录上计算某个字段的结果时，可将窗口范围内的数据输入到聚合函数中，并不改变行数<strong>。</strong></li>
</ul>
<p><img src="../../../images/image-20230609115417254.png" alt="image-20230609115417254"></p>
<p><img src="../../../images/image-20230609115435569.png" alt="image-20230609115435569"></p>
<ul>
<li>另外还有开窗聚合函数: SUM,AVG,MIN,MAX</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">window_function ( expr ) <span class="keyword">OVER</span> ( </span><br><span class="line">  <span class="keyword">PARTITION</span> <span class="keyword">BY</span> ... </span><br><span class="line">  <span class="keyword">ORDER</span> <span class="keyword">BY</span> ... </span><br><span class="line">  frame_clause </span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># window_function 是窗口函数的名称；expr 是参数，有些函数不需要参数；</span><br><span class="line"># <span class="keyword">OVER</span>子句包含三个选项</span><br><span class="line"># 分区（<span class="keyword">PARTITION</span> <span class="keyword">BY</span>）</span><br><span class="line"># <span class="keyword">PARTITION</span> <span class="keyword">BY</span>选项用于将数据行拆分成多个分区（组），它的作用类似于<span class="keyword">GROUP</span> <span class="keyword">BY</span>分组。如果省略了 <span class="keyword">PARTITION</span> <span class="keyword">BY</span>，所有的数据作为一个组进行计算</span><br><span class="line"># 排序（<span class="keyword">ORDER</span> <span class="keyword">BY</span>）</span><br><span class="line"># <span class="keyword">OVER</span> 子句中的<span class="keyword">ORDER</span> <span class="keyword">BY</span>选项用于指定分区内的排序方式，与 <span class="keyword">ORDER</span> <span class="keyword">BY</span> 子句的作用类似</span><br><span class="line"># 以及窗口大小（frame_clause）</span><br><span class="line"># frame_clause选项用于在当前分区内指定一个计算窗口，也就是一个与当前行相关的数据子集。 </span><br></pre></td></tr></table></figure>
<blockquote>
<p>序号函数</p>
</blockquote>
<ul>
<li>序号函数有三个：ROW_NUMBER()、RANK()、DENSE_RANK()，可以用来实现分组排序，并添加序号。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">row_number</span>()<span class="operator">|</span><span class="built_in">rank</span>()<span class="operator">|</span><span class="built_in">dense_rank</span>() <span class="keyword">over</span> ( </span><br><span class="line">  <span class="keyword">partition</span> <span class="keyword">by</span> ... </span><br><span class="line">  <span class="keyword">order</span> <span class="keyword">by</span> ... </span><br><span class="line">) </span><br><span class="line"></span><br><span class="line">use mydb4; </span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> employee( </span><br><span class="line">   dname <span class="type">varchar</span>(<span class="number">20</span>), <span class="comment">-- 部门名 </span></span><br><span class="line">   eid <span class="type">varchar</span>(<span class="number">20</span>), </span><br><span class="line">   ename <span class="type">varchar</span>(<span class="number">20</span>), </span><br><span class="line">   hiredate <span class="type">date</span>, <span class="comment">-- 入职日期 </span></span><br><span class="line">   salary <span class="keyword">double</span> <span class="comment">-- 薪资</span></span><br><span class="line">); </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="string">&#x27;研发部&#x27;</span>,<span class="string">&#x27;1001&#x27;</span>,<span class="string">&#x27;刘备&#x27;</span>,<span class="string">&#x27;2021-11-01&#x27;</span>,<span class="number">3000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="string">&#x27;研发部&#x27;</span>,<span class="string">&#x27;1002&#x27;</span>,<span class="string">&#x27;关羽&#x27;</span>,<span class="string">&#x27;2021-11-02&#x27;</span>,<span class="number">5000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="string">&#x27;研发部&#x27;</span>,<span class="string">&#x27;1003&#x27;</span>,<span class="string">&#x27;张飞&#x27;</span>,<span class="string">&#x27;2021-11-03&#x27;</span>,<span class="number">7000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="string">&#x27;研发部&#x27;</span>,<span class="string">&#x27;1004&#x27;</span>,<span class="string">&#x27;赵云&#x27;</span>,<span class="string">&#x27;2021-11-04&#x27;</span>,<span class="number">7000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="string">&#x27;研发部&#x27;</span>,<span class="string">&#x27;1005&#x27;</span>,<span class="string">&#x27;马超&#x27;</span>,<span class="string">&#x27;2021-11-05&#x27;</span>,<span class="number">4000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="string">&#x27;研发部&#x27;</span>,<span class="string">&#x27;1006&#x27;</span>,<span class="string">&#x27;黄忠&#x27;</span>,<span class="string">&#x27;2021-11-06&#x27;</span>,<span class="number">4000</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="string">&#x27;销售部&#x27;</span>,<span class="string">&#x27;1007&#x27;</span>,<span class="string">&#x27;曹操&#x27;</span>,<span class="string">&#x27;2021-11-01&#x27;</span>,<span class="number">2000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="string">&#x27;销售部&#x27;</span>,<span class="string">&#x27;1008&#x27;</span>,<span class="string">&#x27;许褚&#x27;</span>,<span class="string">&#x27;2021-11-02&#x27;</span>,<span class="number">3000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="string">&#x27;销售部&#x27;</span>,<span class="string">&#x27;1009&#x27;</span>,<span class="string">&#x27;典韦&#x27;</span>,<span class="string">&#x27;2021-11-03&#x27;</span>,<span class="number">5000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="string">&#x27;销售部&#x27;</span>,<span class="string">&#x27;1010&#x27;</span>,<span class="string">&#x27;张辽&#x27;</span>,<span class="string">&#x27;2021-11-04&#x27;</span>,<span class="number">6000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="string">&#x27;销售部&#x27;</span>,<span class="string">&#x27;1011&#x27;</span>,<span class="string">&#x27;徐晃&#x27;</span>,<span class="string">&#x27;2021-11-05&#x27;</span>,<span class="number">9000</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> employee <span class="keyword">values</span>(<span class="string">&#x27;销售部&#x27;</span>,<span class="string">&#x27;1012&#x27;</span>,<span class="string">&#x27;曹洪&#x27;</span>,<span class="string">&#x27;2021-11-06&#x27;</span>,<span class="number">6000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 对每个部门的员工按照薪资排序，并给出排名</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">dname,</span><br><span class="line">ename,</span><br><span class="line">salary,</span><br><span class="line"><span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> dname <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>) <span class="keyword">as</span> rn </span><br><span class="line"><span class="keyword">from</span> employee;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 对每个部门的员工按照薪资排序，并给出排名 rank</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">dname,</span><br><span class="line">ename,</span><br><span class="line">salary,</span><br><span class="line"><span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> dname <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>) <span class="keyword">as</span> rn </span><br><span class="line"><span class="keyword">from</span> employee;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 对每个部门的员工按照薪资排序，并给出排名 dense-rank</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">dname,</span><br><span class="line">ename,</span><br><span class="line">salary,</span><br><span class="line"><span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> dname <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>) <span class="keyword">as</span> rn </span><br><span class="line"><span class="keyword">from</span> employee;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 求出每个部门薪资排在前三名的员工- 分组求TOPN</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> </span><br><span class="line">     dname,</span><br><span class="line">     ename,</span><br><span class="line">     salary,</span><br><span class="line">     <span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> dname <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>)  <span class="keyword">as</span> rn</span><br><span class="line">    <span class="keyword">from</span> employee</span><br><span class="line">)t</span><br><span class="line"><span class="keyword">where</span> t.rn <span class="operator">&lt;=</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 对所有员工进行全局排序（不分组）</span></span><br><span class="line"><span class="comment">-- 不加partition by表示全局排序</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">     dname,</span><br><span class="line">     ename,</span><br><span class="line">     salary,</span><br><span class="line">     <span class="built_in">dense_rank</span>() <span class="keyword">over</span>( <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>)  <span class="keyword">as</span> rn</span><br><span class="line"><span class="keyword">from</span> employee;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 求出每个部门薪资排在前三名的员工- 分组求TOPN</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> </span><br><span class="line">(</span><br><span class="line">    <span class="keyword">select</span> </span><br><span class="line">     dname,</span><br><span class="line">     ename,</span><br><span class="line">     salary,</span><br><span class="line">     <span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> dname <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span>)  <span class="keyword">as</span> rn</span><br><span class="line">    <span class="keyword">from</span> employee</span><br><span class="line">)t</span><br><span class="line"><span class="keyword">where</span> t.rn <span class="operator">&lt;=</span> <span class="number">3</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>开窗聚合函数 SUM,AVG,MIN,MAX</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  </span><br><span class="line"> dname,</span><br><span class="line"> ename,</span><br><span class="line"> salary,</span><br><span class="line"> <span class="built_in">sum</span>(salary) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> dname <span class="keyword">order</span> <span class="keyword">by</span> hiredate  <span class="keyword">rows</span> <span class="keyword">between</span> unbounded preceding <span class="keyword">and</span> <span class="keyword">current</span> <span class="type">row</span>) <span class="keyword">as</span> c1 </span><br><span class="line"><span class="keyword">from</span> employee;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">select</span>  </span><br><span class="line"> dname,</span><br><span class="line"> ename,</span><br><span class="line"> salary,</span><br><span class="line"> <span class="built_in">sum</span>(salary) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> dname <span class="keyword">order</span> <span class="keyword">by</span> hiredate   <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">3</span> preceding <span class="keyword">and</span> <span class="keyword">current</span> <span class="type">row</span>) <span class="keyword">as</span> c1 </span><br><span class="line"><span class="keyword">from</span> employee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span>  </span><br><span class="line"> dname,</span><br><span class="line"> ename,</span><br><span class="line"> salary,</span><br><span class="line"> <span class="built_in">sum</span>(salary) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> dname <span class="keyword">order</span> <span class="keyword">by</span> hiredate   <span class="keyword">rows</span> <span class="keyword">between</span> <span class="number">3</span> preceding <span class="keyword">and</span> <span class="number">1</span> following) <span class="keyword">as</span> c1 </span><br><span class="line"><span class="keyword">from</span> employee;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span>  </span><br><span class="line"> dname,</span><br><span class="line"> ename,</span><br><span class="line"> salary,</span><br><span class="line"> <span class="built_in">sum</span>(salary) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> dname <span class="keyword">order</span> <span class="keyword">by</span> hiredate   <span class="keyword">rows</span> <span class="keyword">between</span> <span class="keyword">current</span> <span class="type">row</span> <span class="keyword">and</span> unbounded following) <span class="keyword">as</span> c1</span><br><span class="line"><span class="keyword">from</span> employee;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>分布函数- CUME_DIST和PERCENT_RANK</p>
</blockquote>
<ul>
<li>CUME_DIST<ul>
<li>分组内小于、等于当前rank值的行数 / 分组内总行数</li>
<li>查询小于等于当前薪资（salary）的比例</li>
</ul>
</li>
<li>PERCENT_RANK<ul>
<li>每行按照公式(rank-1) / (rows-1)进行计算。其中，rank为RANK()函数产生的序号，rows为当前窗口的记录总行数</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span>  </span><br><span class="line"> dname,</span><br><span class="line"> ename,</span><br><span class="line"> salary,</span><br><span class="line"> <span class="built_in">cume_dist</span>() <span class="keyword">over</span>(<span class="keyword">order</span> <span class="keyword">by</span> salary) <span class="keyword">as</span> rn1, <span class="comment">-- 没有partition语句 所有的数据位于一组</span></span><br><span class="line"> <span class="built_in">cume_dist</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> dept <span class="keyword">order</span> <span class="keyword">by</span> salary) <span class="keyword">as</span> rn2 </span><br><span class="line"><span class="keyword">from</span> employee;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">rn1: 没有partition,所有数据均为1组，总行数为12，</span></span><br><span class="line"><span class="comment">     第一行：小于等于3000的行数为3，因此，3/12=0.25</span></span><br><span class="line"><span class="comment">     第二行：小于等于4000的行数为5，因此，5/12=0.4166666666666667</span></span><br><span class="line"><span class="comment">rn2: 按照部门分组，dname=&#x27;研发部&#x27;的行数为6,</span></span><br><span class="line"><span class="comment">     第一行：研发部小于等于3000的行数为1，因此，1/6=0.16666666666666666</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"> dname,</span><br><span class="line"> ename,</span><br><span class="line"> salary,</span><br><span class="line"> <span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> dname <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span> ) <span class="keyword">as</span> rn,</span><br><span class="line"> <span class="built_in">percent_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> dname <span class="keyword">order</span> <span class="keyword">by</span> salary <span class="keyword">desc</span> ) <span class="keyword">as</span> rn2</span><br><span class="line"><span class="keyword">from</span> employee;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>前后函数-LAG和LEAD</p>
</blockquote>
<ul>
<li>返回位于当前行的前n行（LAG(expr,n)）或后n行（LEAD(expr,n)）的expr的值</li>
<li>查询前1名同学的成绩和当前同学成绩的差值</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- lag的用法</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"> dname,</span><br><span class="line"> ename,</span><br><span class="line"> hiredate,</span><br><span class="line"> salary,</span><br><span class="line"> <span class="built_in">lag</span>(hiredate,<span class="number">1</span>,<span class="string">&#x27;2000-01-01&#x27;</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> dname <span class="keyword">order</span> <span class="keyword">by</span> hiredate) <span class="keyword">as</span> last_1_time,</span><br><span class="line"> <span class="built_in">lag</span>(hiredate,<span class="number">2</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> dname <span class="keyword">order</span> <span class="keyword">by</span> hiredate) <span class="keyword">as</span> last_2_time </span><br><span class="line"><span class="keyword">from</span> employee;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">last_1_time: 指定了往上第1行的值，default为&#x27;2000-01-01&#x27;  </span></span><br><span class="line"><span class="comment">                         第一行，往上1行为null,因此取默认值 &#x27;2000-01-01&#x27;</span></span><br><span class="line"><span class="comment">                         第二行，往上1行值为第一行值，2021-11-01 </span></span><br><span class="line"><span class="comment">                         第三行，往上1行值为第二行值，2021-11-02 </span></span><br><span class="line"><span class="comment">last_2_time: 指定了往上第2行的值，为指定默认值</span></span><br><span class="line"><span class="comment">                         第一行，往上2行为null</span></span><br><span class="line"><span class="comment">                         第二行，往上2行为null</span></span><br><span class="line"><span class="comment">                         第四行，往上2行为第二行值，2021-11-01 </span></span><br><span class="line"><span class="comment">                         第七行，往上2行为第五行值，2021-11-02 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- lead的用法</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line"> dname,</span><br><span class="line"> ename,</span><br><span class="line"> hiredate,</span><br><span class="line"> salary,</span><br><span class="line"> <span class="built_in">lead</span>(hiredate,<span class="number">1</span>,<span class="string">&#x27;2000-01-01&#x27;</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> dname <span class="keyword">order</span> <span class="keyword">by</span> hiredate) <span class="keyword">as</span> last_1_time,</span><br><span class="line"> <span class="built_in">lead</span>(hiredate,<span class="number">2</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> dname <span class="keyword">order</span> <span class="keyword">by</span> hiredate) <span class="keyword">as</span> last_2_time </span><br><span class="line"><span class="keyword">from</span> employee;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>头尾函数-FIRST_VALUE和LAST_VALUE</p>
</blockquote>
<ul>
<li>返回第一个（FIRST_VALUE(expr)）或最后一个（LAST_VALUE(expr)）expr的值</li>
<li>截止到当前，按照日期排序查询第1个入职和最后1个入职员工的薪资</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 注意,  如果不指定ORDER BY，则进行排序混乱，会出现错误的结果</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">  dname,</span><br><span class="line">  ename,</span><br><span class="line">  hiredate,</span><br><span class="line">  salary,</span><br><span class="line">  <span class="built_in">first_value</span>(salary) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> dname <span class="keyword">order</span> <span class="keyword">by</span> hiredate) <span class="keyword">as</span> <span class="keyword">first</span>,</span><br><span class="line">  <span class="built_in">last_value</span>(salary) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> dname <span class="keyword">order</span> <span class="keyword">by</span>  hiredate) <span class="keyword">as</span> <span class="keyword">last</span> </span><br><span class="line"><span class="keyword">from</span>  employee;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其他函数-NTH_VALUE(expr, n)、NTILE(n)</p>
</blockquote>
<ul>
<li><p>NTH_VALUE(expr,n)</p>
<ul>
<li><p>返回窗口中第n个expr的值。expr可以是表达式，也可以是列名</p>
</li>
<li><p>截止到当前薪资，显示每个员工的薪资中排名第2或者第3的薪资</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询每个部门截止目前薪资排在第二和第三的员工信息</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">  dname,</span><br><span class="line">  ename,</span><br><span class="line">  hiredate,</span><br><span class="line">  salary,</span><br><span class="line">  <span class="built_in">nth_value</span>(salary,<span class="number">2</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> dname <span class="keyword">order</span> <span class="keyword">by</span> hiredate) <span class="keyword">as</span> second_score,</span><br><span class="line">  <span class="built_in">nth_value</span>(salary,<span class="number">3</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> dname <span class="keyword">order</span> <span class="keyword">by</span> hiredate) <span class="keyword">as</span> third_score</span><br><span class="line"><span class="keyword">from</span> employee</span><br></pre></td></tr></table></figure>
<ul>
<li>NTILE(n)<ul>
<li>将分区中的有序数据分为n个等级，记录等级数</li>
<li>将每个部门员工按照入职日期分成3组</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 根据入职日期将每个部门的员工分成3组</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">  dname,</span><br><span class="line">  ename,</span><br><span class="line">  hiredate,</span><br><span class="line">  salary,</span><br><span class="line"><span class="built_in">ntile</span>(<span class="number">3</span>) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> dname <span class="keyword">order</span> <span class="keyword">by</span>  hiredate  ) <span class="keyword">as</span> rn </span><br><span class="line"><span class="keyword">from</span> employee;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 取出每个部门的第一组员工</span></span><br><span class="line"><span class="keyword">select</span></span><br><span class="line"><span class="operator">*</span></span><br><span class="line"><span class="keyword">from</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span> </span><br><span class="line">        dname,</span><br><span class="line">        ename,</span><br><span class="line">        hiredate,</span><br><span class="line">        salary,</span><br><span class="line">    <span class="built_in">NTILE</span>(<span class="number">3</span>) <span class="keyword">OVER</span>(<span class="keyword">PARTITION</span> <span class="keyword">BY</span> dname <span class="keyword">ORDER</span> <span class="keyword">BY</span>  hiredate  ) <span class="keyword">AS</span> rn </span><br><span class="line">    <span class="keyword">FROM</span> employee</span><br><span class="line">)t</span><br><span class="line"><span class="keyword">where</span> t.rn <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span>,字段<span class="number">2</span>… <span class="keyword">from</span> 表名 <span class="keyword">group</span> <span class="keyword">by</span> 分组字段 <span class="keyword">having</span> 分组条件;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1 统计各个分类商品的个数</span></span><br><span class="line"><span class="keyword">select</span> category_id ,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> product <span class="keyword">group</span> <span class="keyword">by</span> category_id ;</span><br><span class="line"><span class="comment">-- 2.统计各个分类商品的个数,且只显示个数大于4的信息</span></span><br><span class="line"><span class="keyword">select</span> category_id ,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> product <span class="keyword">group</span> <span class="keyword">by</span> category_id <span class="keyword">having</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="operator">&gt;</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>分组之后的条件筛选-having</p>
</blockquote>
<ol>
<li>分组之后对统计结果进行筛选的话必须使用having，不能使用where</li>
<li>where子句用来筛选 FROM 子句中指定的操作所产生的行</li>
<li>group by 子句用来分组 WHERE 子句的输出</li>
<li>having 子句用来从分组的结果中筛选行</li>
</ol>
<h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 方式1-显示前n条</span></span><br><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span>，字段<span class="number">2.</span>.. <span class="keyword">from</span> 表明 limit n</span><br><span class="line"><span class="comment">-- 方式2-分页显示</span></span><br><span class="line"><span class="keyword">select</span> 字段<span class="number">1</span>，字段<span class="number">2.</span>.. <span class="keyword">from</span> 表明 limit m,n</span><br><span class="line">m: 整数，表示从第几条索引开始，计算方式 （当前页<span class="number">-1</span>）<span class="operator">*</span>每页显示条数</span><br><span class="line">n: 整数，表示查询多少条数据</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询product表的前5条记录 </span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product limit <span class="number">5</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从第4条开始显示，显示5条 </span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> product limit <span class="number">3</span>,<span class="number">5</span></span><br></pre></td></tr></table></figure>
<h3 id="INSERT-INTO-SELECT语句"><a href="#INSERT-INTO-SELECT语句" class="headerlink" title="INSERT INTO SELECT语句"></a>INSERT INTO SELECT语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Table2(field1,field2,…) <span class="keyword">select</span> value1,value2,… <span class="keyword">from</span> Table1 或者：</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> Table2 <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Table1</span><br></pre></td></tr></table></figure>
<ul>
<li>将一张表的数据导入到另一张表中，可以使用INSERT INTO SELECT语句 </li>
<li>要求目标表Table2必须存在</li>
</ul>
<h3 id="SELECT-INTO-FROM语句"><a href="#SELECT-INTO-FROM语句" class="headerlink" title="SELECT INTO FROM语句"></a>SELECT INTO FROM语句</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vale1, value2 <span class="keyword">into</span> Table2 <span class="keyword">from</span> Table1</span><br></pre></td></tr></table></figure>
<ul>
<li>将一张表的数据导入到另一张表中，有两种选择 SELECT INTO 和 INSERT INTO SELECT </li>
<li>要求目标表Table2不存在，因为在插入时会自动创建表Table2，并将Table1中指定字段数据复制到Table2中</li>
</ul>
<h3 id="多表联合查询"><a href="#多表联合查询" class="headerlink" title="多表联合查询"></a>多表联合查询</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 交叉连接查询 [产生笛卡尔积，了解]</span><br><span class="line">      语法：<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A,B;  </span><br><span class="line"></span><br><span class="line"># 内连接查询(使用的关键字 <span class="keyword">inner</span> <span class="keyword">join</span>  <span class="comment">-- inner可以省略)</span></span><br><span class="line">    隐式内连接（SQL92标准）：<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A,B <span class="keyword">where</span> 条件;</span><br><span class="line">    显示内连接（SQL99标准）：<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">inner</span> <span class="keyword">join</span> B <span class="keyword">on</span> 条件;</span><br><span class="line"></span><br><span class="line"># 外连接查询(使用的关键字 <span class="keyword">outer</span> <span class="keyword">join</span> <span class="comment">-- outer可以省略)</span></span><br><span class="line">        左外连接：<span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span></span><br><span class="line">            <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> B <span class="keyword">on</span> 条件;</span><br><span class="line">        右外连接：<span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span></span><br><span class="line">            <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> B <span class="keyword">on</span> 条件;</span><br><span class="line">        满外连接: <span class="keyword">full</span> <span class="keyword">outer</span> <span class="keyword">join</span></span><br><span class="line">             <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">full</span> <span class="keyword">outer</span> <span class="keyword">join</span> B <span class="keyword">on</span> 条件;</span><br><span class="line"># 子查询</span><br><span class="line">       <span class="keyword">select</span>的嵌套</span><br><span class="line"># 表自关联：</span><br><span class="line">       将一张表当成多张表来用</span><br></pre></td></tr></table></figure>
<p><img src="../../../images/image-20230608143410762.png" alt="image-20230608143410762"></p>
<blockquote>
<p>交叉连接查询</p>
</blockquote>
<ul>
<li>交叉连接查询返回被连接的两个表所有数据行的笛卡尔积</li>
<li>笛卡尔积可以理解为一张表的每一行去和另外一张表的任意一行进行匹配</li>
<li>假如A表有m行数据，B表有n行数据，则返回m*n行数据</li>
<li>笛卡尔积会产生很多冗余的数据，后期的其他查询可以在该集合的基础上进行条件筛选</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> 表<span class="number">1</span>,表<span class="number">2</span>,表<span class="number">3</span>….; </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept3,emp3;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>内连接</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">隐式内连接（SQL92标准）：<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A,B <span class="keyword">where</span> 条件; </span><br><span class="line">显示内连接（SQL99标准）：<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> A <span class="keyword">inner</span> <span class="keyword">join</span> B <span class="keyword">on</span> 条件;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询每个部门的所属员工</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept3,emp3 <span class="keyword">where</span> dept3.deptno <span class="operator">=</span> emp3.dept_id;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept3 <span class="keyword">inner</span> <span class="keyword">join</span> emp3 <span class="keyword">on</span> dept3.deptno <span class="operator">=</span> emp3.dept_id;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>外连接</p>
</blockquote>
<p>外连接分为左外连接（left outer join）、右外连接(right outer join)，满外连接(full outer join)。</p>
<p>注意：oracle里面有full join,可是在mysql对full join支持的不好。我们可以使用union来达到目的。</p>
<blockquote>
<p>子查询</p>
</blockquote>
<p>子查询就是指的在一个完整的查询语句之中，嵌套若干个不同功能的小查询，从而一起完成复杂查询的一种编写形式，通俗一点就是包含select嵌套的查询。</p>
<p>子查询可以返回的数据类型一共分为四种：</p>
<ul>
<li>单行单列：返回的是一个具体列的内容，可以理解为一个单值数据</li>
<li>单行多列：返回一行数据中多个列的内容；</li>
<li>多行单列：返回多行记录之中同一列的内容，相当于给出了一个操作范围</li>
<li>多行多列：查询返回的结果是一张临时表</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查询年龄最大的员工信息，显示信息包含员工号、员工名字，员工年龄</span></span><br><span class="line"><span class="keyword">select</span> eid,ename,age <span class="keyword">from</span> emp3 <span class="keyword">where</span> age <span class="operator">=</span> (<span class="keyword">select</span> <span class="built_in">max</span>(age) <span class="keyword">from</span> emp3);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 查询年研发部和销售部的员工信息，包含员工号、员工名字</span></span><br><span class="line"><span class="keyword">select</span> eid,ename,t.name <span class="keyword">from</span> emp3 <span class="keyword">where</span> dept_id <span class="keyword">in</span> (<span class="keyword">select</span> deptno,name <span class="keyword">from</span> dept3 <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span>) ;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 查询研发部20岁以下的员工信息,包括员工号、员工名字，部门名字</span></span><br><span class="line"><span class="keyword">select</span> eid,age,ename,name <span class="keyword">from</span> (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;研发部 &#x27;</span>)t1,(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp3 <span class="keyword">where</span> age <span class="operator">&lt;</span><span class="number">20</span>)t2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>子查询关键字：</p>
<ul>
<li>ALL关键字<ul>
<li>与子查询返回的所有值比较为true 则返回true</li>
<li>可以与=、&gt;、&gt;=、&lt;、&lt;=、&lt;&gt;结合是来使用，分别表示等于、大于、大于等于、小于、小于等于、不等于其中的其中的所有数据。</li>
<li>表示指定列中的值必须要大于子查询集的每一个值，即必须要大于子查询集的最大值；如果是小于号即小于子查询集的最小值。同理可以推出其它的比较运算符的情况。</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> …<span class="keyword">from</span> …<span class="keyword">where</span> c <span class="operator">&gt;</span> <span class="keyword">all</span>(查询语句)</span><br><span class="line"><span class="comment">--等价于：</span></span><br><span class="line"><span class="keyword">select</span> ...<span class="keyword">from</span> ... <span class="keyword">where</span> c <span class="operator">&gt;</span> result1 <span class="keyword">and</span> c <span class="operator">&gt;</span> result2 <span class="keyword">and</span> c <span class="operator">&gt;</span> result3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询年龄大于‘1003’部门所有年龄的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp3 <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="keyword">all</span>(<span class="keyword">select</span> age <span class="keyword">from</span> emp3 <span class="keyword">where</span> dept_id <span class="operator">=</span> <span class="string">&#x27;1003&#x27;</span>);</span><br><span class="line"><span class="comment">-- 查询不属于任何一个部门的员工信息 </span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp3 <span class="keyword">where</span> dept_id <span class="operator">!=</span> <span class="keyword">all</span>(<span class="keyword">select</span> deptno <span class="keyword">from</span> dept3); </span><br></pre></td></tr></table></figure>
<ul>
<li>ANY / SOME关键字<ul>
<li>与子查询返回的任何值比较为true 则返回true</li>
<li>可以与=、&gt;、&gt;=、&lt;、&lt;=、&lt;&gt;结合是来使用，分别表示等于、大于、大于等于、小于、小于等于、不等于其中的其中的任何一个数据。</li>
<li>表示制定列中的值要大于子查询中的任意一个值，即必须要大于子查询集中的最小值。同理可以推出其它的比较运算符的情况</li>
<li>SOME和ANY的作用一样，SOME可以理解为ANY的别名</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> …<span class="keyword">from</span> …<span class="keyword">where</span> c <span class="operator">&gt;</span> <span class="keyword">any</span>(查询语句)</span><br><span class="line"><span class="comment">--等价于：</span></span><br><span class="line"><span class="keyword">select</span> ...<span class="keyword">from</span> ... <span class="keyword">where</span> c <span class="operator">&gt;</span> result1 <span class="keyword">or</span> c <span class="operator">&gt;</span> result2 <span class="keyword">or</span> c <span class="operator">&gt;</span> result3</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询年龄大于‘1003’部门任意一个员工年龄的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp3 <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="keyword">all</span>(<span class="keyword">select</span> age <span class="keyword">from</span> emp3 <span class="keyword">where</span> dept_id <span class="operator">=</span> <span class="string">&#x27;1003&#x27;</span>);</span><br><span class="line">                                   </span><br><span class="line"><span class="comment">-- 查询年龄大于‘1003’部门任意一个员工年龄的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp3 <span class="keyword">where</span> age <span class="operator">&gt;</span> <span class="keyword">all</span>(<span class="keyword">select</span> age <span class="keyword">from</span> emp3 <span class="keyword">where</span> dept_id <span class="operator">=</span> <span class="string">&#x27;1003&#x27;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>IN关键字<ul>
<li>IN关键字，用于判断某个记录的值，是否在指定的集合中</li>
<li>在IN关键字前边加上not可以将条件反过来</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> …<span class="keyword">from</span> …<span class="keyword">where</span> c <span class="keyword">in</span>(查询语句)</span><br><span class="line"><span class="comment">--等价于：</span></span><br><span class="line"><span class="keyword">select</span> ...<span class="keyword">from</span> ... <span class="keyword">where</span> c <span class="operator">=</span> result1 <span class="keyword">or</span> c <span class="operator">=</span> result2 <span class="keyword">or</span> c <span class="operator">=</span> result3</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询研发部和销售部的员工信息，包含员工号、员工名字</span></span><br><span class="line"><span class="keyword">select</span> eid,ename,t.name <span class="keyword">from</span> emp3 <span class="keyword">where</span> dept_id <span class="keyword">in</span> (<span class="keyword">select</span> deptno <span class="keyword">from</span> dept3 <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;研发部&#x27;</span> <span class="keyword">or</span> name <span class="operator">=</span> <span class="string">&#x27;销售部&#x27;</span>) ;</span><br></pre></td></tr></table></figure>
<ul>
<li>EXISTS关键字<ul>
<li>子查询如果“有数据结果”(至少返回一行数据)， 则该EXISTS() 的结果为“true”，外层查询执行</li>
<li>子查询如果“没有数据结果”（没有任何数据返回），则该EXISTS()的结果为“false”，外层查询不执行</li>
<li>EXISTS后面的子查询不返回任何实际数据，只返回真或假，当返回真时 where条件成立</li>
<li>EXISTS关键字，比IN关键字的运算效率高，因此，在实际开发中，特别是大数据量时，推荐使用EXISTS关键字</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> …<span class="keyword">from</span> …<span class="keyword">where</span> <span class="keyword">exists</span>(查询语句)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询公司是否有大于60岁的员工，有则输出</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp3 a <span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp3 b <span class="keyword">where</span> a.age <span class="operator">&gt;</span> <span class="number">60</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 查询有所属部门的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp3 a <span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept3 b <span class="keyword">where</span> a.dept_id <span class="operator">=</span> b.deptno);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查询公司是否有大于60岁的员工，有则输出</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp3 a <span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp3 b <span class="keyword">where</span> a.age <span class="operator">&gt;</span> <span class="number">60</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 查询有所属部门的员工信息</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> emp3 a <span class="keyword">where</span> <span class="keyword">exists</span>(<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> dept3 b <span class="keyword">where</span> a.dept_id <span class="operator">=</span> b.deptno);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>自关联查询</p>
</blockquote>
<ul>
<li>MySQL有时在信息查询时需要进行对表自身进行关联查询，即一张表自己和自己关联，一张表当成多张表来用。注意自关联时表必须给表起别名</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> a , 表<span class="number">1</span> b <span class="keyword">where</span> 条件;</span><br><span class="line">或者 </span><br><span class="line"><span class="keyword">select</span> 字段列表 <span class="keyword">from</span> 表<span class="number">1</span> a [<span class="keyword">left</span>] <span class="keyword">join</span> 表<span class="number">1</span> b <span class="keyword">on</span> 条件;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建表,并建立自关联约束</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_sanguo(</span><br><span class="line">    eid <span class="type">int</span> <span class="keyword">primary</span> key ,</span><br><span class="line">    ename <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    manager_id <span class="type">int</span>,</span><br><span class="line"> <span class="keyword">foreign</span> key (manager_id) <span class="keyword">references</span> t_sanguo (eid)  <span class="comment">-- 添加自关联约束</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">-- 添加数据 </span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_sanguo <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;刘协&#x27;</span>,<span class="keyword">NULL</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_sanguo <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;刘备&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_sanguo <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;关羽&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_sanguo <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;张飞&#x27;</span>,<span class="number">2</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_sanguo <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;曹操&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_sanguo <span class="keyword">values</span>(<span class="number">6</span>,<span class="string">&#x27;许褚&#x27;</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_sanguo <span class="keyword">values</span>(<span class="number">7</span>,<span class="string">&#x27;典韦&#x27;</span>,<span class="number">5</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_sanguo <span class="keyword">values</span>(<span class="number">8</span>,<span class="string">&#x27;孙权&#x27;</span>,<span class="number">1</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_sanguo <span class="keyword">values</span>(<span class="number">9</span>,<span class="string">&#x27;周瑜&#x27;</span>,<span class="number">8</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t_sanguo <span class="keyword">values</span>(<span class="number">10</span>,<span class="string">&#x27;鲁肃&#x27;</span>,<span class="number">8</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 进行关联查询</span></span><br><span class="line"><span class="comment">-- 1.查询每个三国人物及他的上级信息，如:  关羽  刘备 </span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> t_sanguo a, t_sanguo b <span class="keyword">where</span> a.manager_id <span class="operator">=</span> b.eid;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库系统</title>
    <url>/posts/53592.html</url>
    <content><![CDATA[<h1 id="关系型数据库RDBMS"><a href="#关系型数据库RDBMS" class="headerlink" title="关系型数据库RDBMS"></a>关系型数据库RDBMS</h1><ol>
<li>Oracle数据库 （老大，最挣钱的数据库）</li>
<li>MySQL数据库 （最流行中型数据库））</li>
<li>SQL server数据库 （Windows上最好的数据库）</li>
<li>PostgreSQL（功能最强大的开源数据库）</li>
<li>SQLite（最流行的嵌入式数据库）</li>
</ol>
<h1 id="非关系型数据库-NoSQL"><a href="#非关系型数据库-NoSQL" class="headerlink" title="非关系型数据库 NoSQL"></a>非关系型数据库 NoSQL</h1><ol>
<li>Redis（最好的缓存数据库）</li>
<li>MongoDB（最好的文档型数据库）</li>
<li>Elasticsearch（最好的搜索服务）</li>
<li>Cassandra（最好的列式数据库）</li>
<li>HBase（优秀的分布式、列式数据库）</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql (一)</title>
    <url>/posts/6358.html</url>
    <content><![CDATA[<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>①MySQL数据库是用C和C++语言编写的，以保证源码的可移植性</p>
<p>②支持多个操作系统例如：Windows、Linux、Mac OS等等</p>
<p>③支持多线程，可以充分的利用CPU资源</p>
<p>④为多种编程语言提供API，包括C语言，Java，PHP。Python语言等</p>
<p>⑤MySQL优化了SQL算法，有效的提高了查询速度</p>
<p>⑥MySQL开放源代码且无版权制约，自主性强、使用成本低。</p>
<p>⑧MySQL历史悠久、社区及用户非常活跃，遇到问题，可以很快获取到帮助。</p>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>解压配置</p>
<p>my.ini 文件中配置</p>
<p><img src="../../../images/image-20230607111115742.png" alt="image-20230607111115742"></p>
<p>配置环境变量</p>
<p>图形化界面工具navicat / SQLyog / Workbench / DataGrip </p>
<h1 id="约束-constraint"><a href="#约束-constraint" class="headerlink" title="约束 constraint"></a>约束 constraint</h1><p>表中数据的限制条件</p>
<p>加入约束，保证表中的记录完整性和有效性</p>
<h2 id="主键约束-primary-key-PK"><a href="#主键约束-primary-key-PK" class="headerlink" title="主键约束(primary key) PK"></a>主键约束(primary key) PK</h2><ul>
<li><p>主键约束列不允许重复，也不允许出现空值</p>
</li>
<li><p>每个表最多只允许一个主键</p>
</li>
<li>创建主键时，默认会在所在的列和列组合上建立对应的唯一索引</li>
<li>操作：添加单列主键，添加多列联合主键，删除主键</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 操作<span class="operator">-</span>添加单列主键</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">   ...</span><br><span class="line">   <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> <span class="keyword">primary</span> key </span><br><span class="line">   ...</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp1(</span><br><span class="line">    eid <span class="type">int</span> primay key,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    deptId <span class="type">int</span>,</span><br><span class="line">    salary <span class="keyword">double</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">   ...</span><br><span class="line">   [<span class="keyword">constraint</span> <span class="operator">&lt;</span>约束名<span class="operator">&gt;</span>] <span class="keyword">primary</span> key [字段名]</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp2(</span><br><span class="line">    eid <span class="type">INT</span>,</span><br><span class="line">    name <span class="type">VARCHAR</span>(<span class="number">20</span>),</span><br><span class="line">    deptId <span class="type">INT</span>,</span><br><span class="line">    salary <span class="keyword">double</span>,</span><br><span class="line">    <span class="keyword">constraint</span>  pk1 <span class="keyword">primary</span> key(id)</span><br><span class="line"> );</span><br><span class="line"></span><br><span class="line"># 操作<span class="operator">-</span>添加多列主键(联合主键）</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">   ...</span><br><span class="line">   <span class="keyword">primary</span> key （字段<span class="number">1</span>，字段<span class="number">2</span>，…,字段n)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp3( </span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">20</span>), </span><br><span class="line">  deptId <span class="type">int</span>, </span><br><span class="line">  salary <span class="keyword">double</span>, </span><br><span class="line">  <span class="keyword">primary</span> key(name,deptId) </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 通过修改表结构添加主键</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">   ...</span><br><span class="line">);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">add</span> <span class="keyword">primary</span> key（字段列表);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> emp4(</span><br><span class="line">  eid <span class="type">int</span>, </span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">20</span>), </span><br><span class="line">  deptId <span class="type">int</span>, </span><br><span class="line">  salary <span class="keyword">double</span>, </span><br><span class="line">);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp4 <span class="keyword">add</span> <span class="keyword">primary</span> key（eid);</span><br><span class="line"></span><br><span class="line"># 删除主键约束</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>数据表名<span class="operator">&gt;</span> <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp1 <span class="keyword">drop</span> <span class="keyword">primary</span> key;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="自增长约束-auto-increment"><a href="#自增长约束-auto-increment" class="headerlink" title="自增长约束(auto_increment)"></a>自增长约束(auto_increment)</h2><ul>
<li>每增加一条记录，主键会自动以相同的步长进行增长。</li>
<li>通过给字段添加 auto_increment 属性来实现主键自增长</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 自增</span><br><span class="line">字段名 数据类型 auto_increment</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_user1( </span><br><span class="line">  id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment, </span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">20</span>) </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 指定自增字段初始值</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_user2 ( </span><br><span class="line">  id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment, </span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">)auto_increment<span class="operator">=</span><span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_user3 ( </span><br><span class="line">  id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment, </span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t_user2 auto_increment<span class="operator">=</span><span class="number">100</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>特点</p>
<ul>
<li>auto_increment的初始值是 1，每新增一条记录，字段值自动加 1</li>
<li>一个表中只能有一个字段使用 auto_increment约束，且该字段必须有唯一索引，以避免序号重复（即为主键或主键的一部分）</li>
<li>auto_increment约束的字段必须具备 NOT NULL 属性</li>
<li>auto_increment约束的字段只能是整数类型（TINYINT、SMALLINT、INT、BIGINT 等</li>
<li>auto_increment约束字段的最大值受该字段的数据类型约束，如果达到上限，auto_increment就会失效</li>
<li>delete数据之后自动增长从断点开始</li>
<li>truncate数据之后自动增长从默认起始值开始</li>
</ul>
<h2 id="非空约束-not-null"><a href="#非空约束-not-null" class="headerlink" title="非空约束(not null)"></a>非空约束(not null)</h2><ul>
<li>字段的值不能为空</li>
<li>使用了非空约束的字段，如果用户在添加数据时没有指定值，数据库系统就会报错。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 添加非空约束</span><br><span class="line">方式<span class="number">1</span>：<span class="operator">&lt;</span>字段名<span class="operator">&gt;</span><span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line">方式<span class="number">2</span>：<span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify 字段 类型 <span class="keyword">not</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_user6 ( </span><br><span class="line">  id <span class="type">int</span> , </span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>, </span><br><span class="line">  address <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span> </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_user7 ( </span><br><span class="line">  id <span class="type">int</span> , </span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">20</span>) , <span class="comment">-- 指定非空约束 </span></span><br><span class="line">  address <span class="type">varchar</span>(<span class="number">20</span>) <span class="comment">-- 指定非空约束 </span></span><br><span class="line">); </span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t_user7 modify name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">not</span> <span class="keyword">null</span>; </span><br><span class="line"></span><br><span class="line"># 删除非空约束</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t_user7 modify name <span class="type">varchar</span>(<span class="number">20</span>) ; </span><br></pre></td></tr></table></figure>
<h2 id="唯一性约束-unique"><a href="#唯一性约束-unique" class="headerlink" title="唯一性约束(unique)"></a>唯一性约束(unique)</h2><ul>
<li>所有记录中字段的值不能重复出现</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 添加唯一约束	</span><br><span class="line">方式<span class="number">1</span>：<span class="operator">&lt;</span>字段名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> <span class="keyword">unique</span></span><br><span class="line">方式<span class="number">2</span>： <span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> <span class="keyword">constraint</span> 约束名 <span class="keyword">unique</span>(列);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_user8 ( </span><br><span class="line"> id <span class="type">int</span> , </span><br><span class="line"> name <span class="type">varchar</span>(<span class="number">20</span>) , </span><br><span class="line"> phone_number <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">unique</span> <span class="comment">-- 指定唯一约束 </span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_user9 ( </span><br><span class="line">  id <span class="type">int</span> , </span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">20</span>) , </span><br><span class="line">  phone_number <span class="type">varchar</span>(<span class="number">20</span>) <span class="comment">-- 指定唯一约束 </span></span><br><span class="line">); </span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t_user9 <span class="keyword">add</span> <span class="keyword">constraint</span> unique_ph <span class="keyword">unique</span>(phone_number);</span><br><span class="line"></span><br><span class="line"># 删除唯一约束</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">drop</span> index <span class="operator">&lt;</span>唯一约束名<span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t_user9 <span class="keyword">drop</span> index unique_ph;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="默认约束-default"><a href="#默认约束-default" class="headerlink" title="默认约束(default)"></a>默认约束(default)</h2><ul>
<li>默认值约束用来指定某列的默认值</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 添加默认约束</span><br><span class="line">方式<span class="number">1</span>： <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span> <span class="operator">&lt;</span>数据类型<span class="operator">&gt;</span> <span class="keyword">default</span> <span class="operator">&lt;</span>默认值<span class="operator">&gt;</span>;</span><br><span class="line">方式<span class="number">2</span>: <span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify 列名 类型 <span class="keyword">default</span> 默认值; </span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_user10 ( </span><br><span class="line">  id <span class="type">int</span> , </span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">20</span>) , </span><br><span class="line">  address <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> ‘北京’ <span class="comment">-- 指定默认约束 </span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_user11 ( </span><br><span class="line">  id <span class="type">int</span> , </span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">20</span>) , </span><br><span class="line">  address <span class="type">varchar</span>(<span class="number">20</span>)  </span><br><span class="line">);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t_user11 modify address <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span>  ‘北京’;</span><br><span class="line"></span><br><span class="line"># 删除默认约束</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> modify <span class="keyword">column</span> <span class="operator">&lt;</span>字段名<span class="operator">&gt;</span> <span class="operator">&lt;</span>类型<span class="operator">&gt;</span> <span class="keyword">default</span> <span class="keyword">null</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t_user11 modify <span class="keyword">column</span> address <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">default</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="零填充约束-zerofill"><a href="#零填充约束-zerofill" class="headerlink" title="零填充约束(zerofill)"></a>零填充约束(zerofill)</h2><ul>
<li>插入数据时，当该字段的值的长度小于定义的长度时，会在该值的前面补上相应的0</li>
<li>zerofill默认为int(10)</li>
<li>当使用zerofill 时，默认会自动加unsigned（无符号）属性，使用unsigned属性后，数值范围是原值的2倍，例如，有符号为-128~+127，无符号为0~256</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 添加</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_user12 ( </span><br><span class="line">  id <span class="type">int</span> zerofill , <span class="comment">-- 零填充约束</span></span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">20</span>)   </span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 删除</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> t_user12 modify id <span class="type">int</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="外键约束-foreign-key-FK"><a href="#外键约束-foreign-key-FK" class="headerlink" title="外键约束(foreign key) FK"></a>外键约束(foreign key) FK</h2><p>多表关系： 一对一、一对多/多对一关系，多对多</p>
<p>定义一个外键时，需要遵守下列规则：</p>
<ul>
<li>主表必须已经存在于数据库中，或者是当前正在创建的表。</li>
<li>必须为主表定义主键。</li>
<li>主键不能包含空值，但允许在外键中出现空值。也就是说，只要外键的每个非空值出现在指定的主键中，这 个外键的内容就是正确的。</li>
<li>在主表的表名后面指定列名或列名的组合。这个列或列的组合必须是主表的主键或候选键。</li>
<li>外键中列的数目必须和主表的主键中列的数目相同。</li>
<li>外键中列的数据类型必须和主表主键中对应列的数据类型相同。</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">[<span class="keyword">constraint</span> <span class="operator">&lt;</span>外键名<span class="operator">&gt;</span>] <span class="keyword">foreign</span> key 字段名 [，字段名<span class="number">2</span>，…] <span class="keyword">references</span> <span class="operator">&lt;</span>主表名<span class="operator">&gt;</span> 主键列<span class="number">1</span> [，主键列<span class="number">2</span>，…]</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> database mydb3; </span><br><span class="line">use mydb3;</span><br><span class="line"><span class="comment">-- 创建部门表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> dept(</span><br><span class="line">  deptno <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">primary</span> key ,  <span class="comment">-- 部门号</span></span><br><span class="line">  name <span class="type">varchar</span>(<span class="number">20</span>) <span class="comment">-- 部门名字</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"># 设置外键</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> emp(</span><br><span class="line">  eid <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">primary</span> key , <span class="comment">-- 员工编号</span></span><br><span class="line">  ename <span class="type">varchar</span>(<span class="number">20</span>), <span class="comment">-- 员工名字</span></span><br><span class="line">  age <span class="type">int</span>,  <span class="comment">-- 员工年龄</span></span><br><span class="line">  dept_id <span class="type">varchar</span>(<span class="number">20</span>),  <span class="comment">-- 员工所属部门</span></span><br><span class="line">  <span class="keyword">constraint</span> emp_fk <span class="keyword">foreign</span> key (dept_id) <span class="keyword">references</span> dept (deptno) –<span class="operator">-</span> 外键约束</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>数据表名<span class="operator">&gt;</span> <span class="keyword">add</span> <span class="keyword">constraint</span> <span class="operator">&lt;</span>外键名<span class="operator">&gt;</span> <span class="keyword">foreign</span> key(<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>) <span class="keyword">references</span> </span><br><span class="line"><span class="operator">&lt;</span>主表名<span class="operator">&gt;</span> (<span class="operator">&lt;</span>列名<span class="operator">&gt;</span>);</span><br><span class="line"></span><br><span class="line"># 删除外键约束</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> <span class="operator">&lt;</span>表名<span class="operator">&gt;</span> <span class="keyword">drop</span> <span class="keyword">foreign</span> key <span class="operator">&lt;</span>外键约束名<span class="operator">&gt;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> emp2 <span class="keyword">drop</span> <span class="keyword">foreign</span> key dept_id_fk;</span><br><span class="line"></span><br><span class="line"># 多对多关系</span><br><span class="line"><span class="comment">-- 学生表和课程表(多对多)</span></span><br><span class="line">  <span class="comment">-- 1 创建学生表student(左侧主表)</span></span><br><span class="line">   <span class="keyword">create</span> <span class="keyword">table</span> if <span class="keyword">not</span> <span class="keyword">exists</span> student(</span><br><span class="line">    sid <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    age <span class="type">int</span>,</span><br><span class="line">    gender <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">   );</span><br><span class="line">  <span class="comment">-- 2 创建课程表course(右侧主表)</span></span><br><span class="line">  <span class="keyword">create</span> <span class="keyword">table</span> course(</span><br><span class="line">   cid  <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">   cidname <span class="type">varchar</span>(<span class="number">20</span>)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 3创建中间表student_course/score(从表)</span></span><br><span class="line">  <span class="keyword">create</span> <span class="keyword">table</span> score(</span><br><span class="line">    sid <span class="type">int</span>,</span><br><span class="line">    cid <span class="type">int</span>,</span><br><span class="line">    score <span class="keyword">double</span></span><br><span class="line">  );</span><br><span class="line">    </span><br><span class="line"><span class="comment">-- 4建立外键约束(2次)</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> score <span class="keyword">add</span> <span class="keyword">foreign</span> key(sid) <span class="keyword">references</span> student(sid);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> score <span class="keyword">add</span> <span class="keyword">foreign</span> key(cid) <span class="keyword">references</span> course(cid);</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 5给学生表添加数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;小龙女&#x27;</span>,<span class="number">18</span>,<span class="string">&#x27;女&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;阿紫&#x27;</span>,<span class="number">19</span>,<span class="string">&#x27;女&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;周芷若&#x27;</span>,<span class="number">20</span>,<span class="string">&#x27;男&#x27;</span>);</span><br><span class="line"><span class="comment">-- 6给课程表添加数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> course <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;语文&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;数学&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;英语&#x27;</span>);</span><br><span class="line"><span class="comment">-- 7给中间表添加数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> score <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">3</span>),(<span class="number">3</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>注意给从表添加数据时，外键列的值不能随便写，必须依赖主表的主键列</li>
<li>主表的数据被从表依赖时，不能删除，否则可以删除</li>
<li>从表的数据可以随便删除</li>
</ul>
<h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1><h2 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h2><ul>
<li>视图（view）是一个虚拟表，非真实存在，其本质是根据SQL语句获取动态的数据集，并为其命名，用户使用时只需使用视图名称即可获取结果集，并可以将其当作表来使用。</li>
<li>数据库中只存放了视图的定义，而并没有存放视图中的数据。这些数据存放在原来的表中</li>
<li>视图中的数据是依赖于原来的表中的数据的。一旦表中的数据发生改变，显示在视图中的数据也会发生改变。</li>
<li>把重复使用的查询封装成视图重复使用，同时可以使复杂的查询易于理解和使用。</li>
<li>安全原因，如果一张表中有很多数据，很多信息不希望让所有人看到，此时可以使用视图视，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，可以对不同的用户，设定不同的视图。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create [or replace] [algorithm = &#123;undefined | merge | temptable&#125;]</span><br><span class="line"> </span><br><span class="line">view view_name [(column_list)]</span><br><span class="line"> </span><br><span class="line">as select_statement</span><br><span class="line"> </span><br><span class="line">[with [cascaded | local] check option]</span><br><span class="line"></span><br><span class="line"># 参数说明：</span><br><span class="line">#（1）algorithm：可选项，表示视图选择的算法。</span><br><span class="line">#（2）view_name ：表示要创建的视图名称。</span><br><span class="line">#（3）column_list：可选项，指定视图中各个属性的名词，默认情况下与SELECT语句中的查询的属性相同。</span><br><span class="line">#（4）select_statement</span><br><span class="line"># ：表示一个完整的查询语句，将查询记录导入视图中。</span><br><span class="line">#（5）[with [cascaded | local] check option]：可选项，表示更新视图时要保证在该视图的权限范围之内。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create database mydb6_view;</span><br><span class="line"></span><br><span class="line">create or replace view view1_emp</span><br><span class="line">as </span><br><span class="line">select ename,job from emp; </span><br><span class="line"></span><br><span class="line">-- 查看表和视图 </span><br><span class="line">show full tables;</span><br><span class="line"></span><br><span class="line">-- 修改视图</span><br><span class="line">alter view 视图名 as select语句</span><br><span class="line"></span><br><span class="line">alter view view1_emp as </span><br><span class="line">select a.deptno,a.dname,a.loc,b.ename,b.sal from dept a, emp b where a.deptno = b.deptno;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h2><p>某些视图是可更新的。也就是说，可以在UPDATE、DELETE或INSERT等语句中使用它们，以更新基表的内容</p>
<p>对于可更新的视图，在视图中的行和基表中的行之间必须具有一对一的关系</p>
<p>如果视图包含下述结构中的任何一种，那么它就是不可更新的：</p>
<ul>
<li>聚合函数（SUM(), MIN(), MAX(), COUNT()等）</li>
<li>DISTINCT</li>
<li>GROUP BY</li>
<li>HAVING</li>
<li>UNION或UNION ALL</li>
<li>位于选择列表中的子查询</li>
<li>JOIN</li>
<li>FROM子句中的不可更新视图</li>
<li>WHERE子句中的子查询，引用FROM子句中的表。</li>
<li>仅引用文字值（在该情况下，没有要更新的基本表）</li>
</ul>
<p>视图中虽然可以更新数据，但是有很多的限制。一般情况下，最好将视图作为查询数据的虚拟表，而不要通过视图更新数据。因为，使用视图更新数据时，如果没有全面考虑在视图中更新数据的限制，就可能会造成数据更新失败。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--  ---------更新视图-------</span><br><span class="line">create or replace view view1_emp</span><br><span class="line">as </span><br><span class="line">select ename,job from emp;</span><br><span class="line"> </span><br><span class="line">update view1_emp set ename = &#x27;周瑜&#x27; where ename = &#x27;鲁肃&#x27;;  -- 可以修改</span><br><span class="line">insert into view1_emp values(&#x27;孙权&#x27;,&#x27;文员&#x27;);  -- 不可以插入</span><br><span class="line"></span><br><span class="line">-- ----------视图包含聚合函数不可更新--------------</span><br><span class="line">create or replace view view2_emp</span><br><span class="line">as </span><br><span class="line">select count(*) cnt from emp;</span><br><span class="line"> </span><br><span class="line">insert into view2_emp values(100);</span><br><span class="line">update view2_emp set cnt = 100; </span><br><span class="line"></span><br><span class="line">-- ----------视图包含distinct不可更新---------</span><br><span class="line">create or replace view view3_emp</span><br><span class="line">as </span><br><span class="line">select distinct job from emp;</span><br><span class="line"> </span><br><span class="line">insert into view3_emp values(&#x27;财务&#x27;);</span><br><span class="line"> </span><br><span class="line">-- ----------视图包含goup by 、having不可更新------------------</span><br><span class="line"> </span><br><span class="line">create or replace view view4_emp</span><br><span class="line">as </span><br><span class="line">select deptno ,count(*) cnt from emp group by deptno having  cnt &gt; 2;</span><br><span class="line"> </span><br><span class="line">insert into view4_emp values(30,100);</span><br><span class="line"></span><br><span class="line">-- ----------------视图包含union或者union all不可更新----------------</span><br><span class="line">create or replace view view5_emp</span><br><span class="line">as </span><br><span class="line">select empno,ename from emp where empno &lt;= 1005</span><br><span class="line">union </span><br><span class="line">select empno,ename from emp where empno &gt; 1005;</span><br><span class="line"> </span><br><span class="line">insert into view5_emp values(1015,&#x27;韦小宝&#x27;);</span><br><span class="line"></span><br><span class="line">-- -------------------视图包含子查询不可更新--------------------</span><br><span class="line">create or replace view view6_emp</span><br><span class="line">as </span><br><span class="line">select empno,ename,sal from emp where sal = (select max(sal) from emp);</span><br><span class="line"> </span><br><span class="line">insert into view6_emp values(1015,&#x27;韦小宝&#x27;,30000);</span><br><span class="line">-- ----------------------视图包含join不可更新-----------------</span><br><span class="line">create or replace view view7_emp</span><br><span class="line">as </span><br><span class="line">select dname,ename,sal from emp a join  dept b  on a.deptno = b.deptno;</span><br><span class="line"> </span><br><span class="line">insert into view7_emp(dname,ename,sal) values(&#x27;行政部&#x27;,&#x27;韦小宝&#x27;,30000);</span><br><span class="line"> </span><br><span class="line">-- --------------------视图包含常量文字值不可更新-------------------</span><br><span class="line">create or replace view view8_emp</span><br><span class="line">as </span><br><span class="line">select &#x27;行政部&#x27; dname,&#x27;杨过&#x27;  ename;</span><br><span class="line"> </span><br><span class="line">insert into view8_emp values(&#x27;行政部&#x27;,&#x27;韦小宝&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><p>删除视图时，只能删除视图的定义，不会删除数据。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 重命名视图　　</span><br><span class="line">-- rename table 视图名 to 新视图名; </span><br><span class="line">rename table view1_emp to my_view1</span><br><span class="line"></span><br><span class="line">-- 删除视图</span><br><span class="line">-- drop view 视图名[,视图名…];</span><br><span class="line">drop view if exists view_student;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><p>MySQL 5.0 版本开始支持存储过程</p>
<p>存储过程就是一组SQL语句集，功能强大，可以实现一些比较复杂的逻辑功能，类似于JAVA语言中的方法</p>
<p>存储过就是数据库 SQL 语言层面的代码封装与重用。</p>
<p>特性：</p>
<ul>
<li>有输入输出参数，可以声明变量，有if/else, case,while等控制语句，通过编写存储过程，可以实现复杂的逻辑功能；</li>
<li>函数的普遍特性：模块化，封装，代码复用</li>
<li>速度快，只有首次执行需经过编译和优化步骤，后续被调用可以直接执行，省去以上步骤</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 格式</span><br><span class="line">delimiter 自定义结束符号</span><br><span class="line">create procedure 储存名([ in ,out ,inout ] 参数名 数据类形...)</span><br><span class="line">begin</span><br><span class="line">  sql语句</span><br><span class="line">end 自定义的结束符合</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc01()</span><br><span class="line">begin</span><br><span class="line">  select empno,ename from emp; </span><br><span class="line">end  $$</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line">-- 调用存储过程</span><br><span class="line">call proc01(); </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 局部变量</span><br><span class="line">-- 语法： 声明变量 declare var_name type [default var_value]; </span><br><span class="line">-- 举例：declare nickname varchar(32);</span><br><span class="line"></span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc02()</span><br><span class="line">begin</span><br><span class="line">    declare var_name01 varchar(20) default ‘aaa’;  -- 定义局部变量</span><br><span class="line">    set var_name01 = ‘zhangsan’;  </span><br><span class="line">    select var_name01;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line">-- 调用存储过程</span><br><span class="line">call proc02();</span><br><span class="line"></span><br><span class="line">--  SELECT..INTO 语句为变量赋值</span><br><span class="line">select col_name [...] into var_name[,...] </span><br><span class="line">from table_name wehre condition </span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">其中：</span><br><span class="line">col_name 参数表示查询的字段名称；</span><br><span class="line">var_name 参数是变量的名称；</span><br><span class="line">table_name 参数指表的名称；</span><br><span class="line">condition 参数指查询条件。</span><br><span class="line">注意：当将查询结果赋值给变量时，该查询语句的返回结果只能是单行单列。</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc03()</span><br><span class="line">begin</span><br><span class="line">  declare my_ename varchar(20) ;</span><br><span class="line">  select ename into my_ename from emp where empno=1001;</span><br><span class="line">  select my_ename;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line">-- 调用存储过程</span><br><span class="line">call proc03();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">用户变量</span><br><span class="line">用户自定义，当前会话（连接）有效。类比java的成员变量 </span><br><span class="line">语法： </span><br><span class="line">@var_name</span><br><span class="line">不需要提前声明，使用即声明</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc04()</span><br><span class="line">begin</span><br><span class="line">    set @var_name01  = &#x27;ZS&#x27;;</span><br><span class="line">end $$</span><br><span class="line">delimiter;</span><br><span class="line">call proc04() ;</span><br><span class="line">select @var_name01  ;  --可以看到结果</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h2><p>分为全局变量与会话变量</p>
<p>全局变量在MYSQL启动的时候由服务器自动将它们初始化为默认值，这些默认值可以通过更改my.ini这个文件来更改</p>
<p>会话变量在每次建立一个新的连接的时候，由MYSQL来初始化。MYSQL会将当前所有全局变量的值复制一份。来做为会话变量。</p>
<p>如果在建立会话以后，没有手动更改过会话变量与全局变量的值，那所有这些变量的值都是一样的</p>
<p>全局变量与会话变量的区别就在于，对全局变量的修改会影响到整个服务器，但是对会话变量的修改，只会影响到当前的会话（也就是当前的数据库连接）</p>
<p>有些系统变量的值是可以利用语句来动态进行更改的，但是有些系统变量的值却是只读的，对于那些可以更改的系统变量，我们可以利用set语句进行更改</p>
<blockquote>
<p>全局变量</p>
</blockquote>
<p>由系统提供，在整个数据库有效。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 语法：</span><br><span class="line">@@global.var_name</span><br><span class="line"></span><br><span class="line">-- 查看全局变量 </span><br><span class="line">show global variables; </span><br><span class="line">-- 查看某全局变量 </span><br><span class="line">select @@global.auto_increment_increment; </span><br><span class="line">-- 修改全局变量的值 </span><br><span class="line">set global sort_buffer_size = 40000; </span><br><span class="line">set @@global.sort_buffer_size = 40000;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>会话变量</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@@session.var_name</span><br><span class="line"></span><br><span class="line">-- 查看会话变量</span><br><span class="line">show session variables;</span><br><span class="line">-- 查看某会话变量 </span><br><span class="line">select @@session.auto_increment_increment;</span><br><span class="line">-- 修改会话变量的值</span><br><span class="line">set session sort_buffer_size = 50000; </span><br><span class="line">set @@session.sort_buffer_size = 50000 ;</span><br></pre></td></tr></table></figure>
<h2 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h2><p>in 表示传入的参数， 可以传入数值或者变量，即使传入变量，并不会更改变量的值，可以内部更改，仅仅作用在函数范围内。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 封装有参数的存储过程，传入员工编号，查找员工信息</span><br><span class="line">delimiter $$</span><br><span class="line">create procedure dec_param01(in param_empno varchar(20))</span><br><span class="line">begin</span><br><span class="line">        select * from emp where empno = param_empno;</span><br><span class="line">end $$</span><br><span class="line"> </span><br><span class="line">delimiter ;</span><br><span class="line">call dec_param01(&#x27;1001&#x27;);</span><br><span class="line"></span><br><span class="line">-- 封装有参数的存储过程，可以通过传入部门名和薪资，查询指定部门，并且薪资大于指定值的员工信息</span><br><span class="line">delimiter $$</span><br><span class="line">create procedure dec_param0x(in dname varchar(50),in sal decimal(7,2),)</span><br><span class="line">begin</span><br><span class="line">        select * from dept a, emp b where b.sal &gt; sal and a.dname = dname;</span><br><span class="line">end $$</span><br><span class="line"> </span><br><span class="line">delimiter ;</span><br><span class="line">call dec_param0x(&#x27;学工部&#x27;,20000);</span><br></pre></td></tr></table></figure>
<p>out 表示从存储过程内部传值给调用者</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- ---------传出参数：out---------------------------------</span><br><span class="line">use mysql7_procedure;</span><br><span class="line">-- 封装有参数的存储过程，传入员工编号，返回员工名字</span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc08(in empno int ,out out_ename varchar(50) )</span><br><span class="line">begin</span><br><span class="line">  select ename into out_ename from emp where emp.empno = empno;</span><br><span class="line">end $$</span><br><span class="line"> </span><br><span class="line">delimiter ;</span><br><span class="line"> </span><br><span class="line">call proc08(1001, @o_ename);</span><br><span class="line">select @o_ename;</span><br><span class="line"></span><br><span class="line">-- 封装有参数的存储过程，传入员工编号，返回员工名字和薪资</span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc09(in empno int ,out out_ename varchar(50) ,out out_sal decimal(7,2))</span><br><span class="line">begin</span><br><span class="line">  select ename,sal into out_ename,out_sal from emp where emp.empno = empno;</span><br><span class="line">end $$</span><br><span class="line"> </span><br><span class="line">delimiter ;</span><br><span class="line"> </span><br><span class="line">call proc09(1001, @o_dname,@o_sal);</span><br><span class="line">select @o_dname;</span><br><span class="line">select @o_sal;</span><br></pre></td></tr></table></figure>
<p>inout 表示从外部传入的参数经过修改后可以返回的变量，既可以使用传入变量的值也可以修改变量的值（即使函数执行完）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 传入员工名，拼接部门号，传入薪资，求出年薪</span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc10(inout inout_ename varchar(50),inout inout_sal int)</span><br><span class="line">begin</span><br><span class="line">  select  concat(deptno,&quot;_&quot;,inout_ename) into inout_ename from emp where ename = inout_ename;</span><br><span class="line">  set inout_sal = inout_sal * 12;  </span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line">set @inout_ename = &#x27;关羽&#x27;;</span><br><span class="line">set @inout_sal = 3000;</span><br><span class="line">call proc10(@inout_ename, @inout_sal) ;</span><br><span class="line">select @inout_ename ;</span><br><span class="line">select @inout_sal ;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>IF语句包含多个条件判断，根据结果为TRUE、FALSE执行语句，与编程语言中的if、else if、else语法类似，其语法格式如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 语法</span><br><span class="line">if search_condition_1 then statement_list_1</span><br><span class="line">    [elseif search_condition_2 then statement_list_2] ...</span><br><span class="line">    [else statement_list_n]</span><br><span class="line">end if</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 输入学生的成绩，来判断成绩的级别：</span><br><span class="line">/*</span><br><span class="line">  score &lt; 60 :不及格</span><br><span class="line">  score &gt;= 60  , score &lt;80 :及格</span><br><span class="line">    score &gt;= 80 , score &lt; 90 :良好</span><br><span class="line">    score &gt;= 90 , score &lt;= 100 :优秀</span><br><span class="line">    score &gt; 100 :成绩错误</span><br><span class="line">*/</span><br><span class="line">delimiter  $$</span><br><span class="line">create procedure proc_12_if(in score int)</span><br><span class="line">begin</span><br><span class="line">  if score &lt; 60 </span><br><span class="line">      then</span><br><span class="line">          select &#x27;不及格&#x27;;</span><br><span class="line">    elseif  score &lt; 80</span><br><span class="line">      then</span><br><span class="line">          select &#x27;及格&#x27; ;</span><br><span class="line">    elseif score &gt;= 80 and score &lt; 90</span><br><span class="line">       then </span><br><span class="line">           select &#x27;良好&#x27;;</span><br><span class="line">  elseif score &gt;= 90 and score &lt;= 100</span><br><span class="line">       then </span><br><span class="line">           select &#x27;优秀&#x27;;</span><br><span class="line">     else</span><br><span class="line">       select &#x27;成绩错误&#x27;;</span><br><span class="line">  end if;</span><br><span class="line">end $$</span><br><span class="line">delimiter  ;</span><br><span class="line">call proc_12_if(120)</span><br><span class="line"></span><br><span class="line">-- 输入员工的名字，判断工资的情况。</span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc12_if(in in_ename varchar(50))</span><br><span class="line">begin</span><br><span class="line">    declare result varchar(20);</span><br><span class="line">    declare var_sal decimal(7,2);</span><br><span class="line">        select sal into  var_sal from emp where ename = in_ename;</span><br><span class="line">    if var_sal &lt; 10000 </span><br><span class="line">        then set result = &#x27;试用薪资&#x27;;</span><br><span class="line">    elseif var_sal &lt; 30000</span><br><span class="line">        then set result = &#x27;转正薪资&#x27;;</span><br><span class="line">    else </span><br><span class="line">        set result = &#x27;元老薪资&#x27;;</span><br><span class="line">    end if;</span><br><span class="line">    select result;</span><br><span class="line">end$$</span><br><span class="line">delimiter ;</span><br><span class="line">call proc12_if(&#x27;庞统&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>CASE是另一个条件判断的语句，类似于编程语言中的switch语法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 语法一（类比java的switch）：</span><br><span class="line">case case_value</span><br><span class="line">    when when_value then statement_list</span><br><span class="line">    [when when_value then statement_list] ...</span><br><span class="line">    [else statement_list]</span><br><span class="line">end case</span><br><span class="line">-- 语法二：</span><br><span class="line">case</span><br><span class="line">    when search_condition then statement_list</span><br><span class="line">    [when search_condition then statement_list] ...</span><br><span class="line">    [else statement_list]</span><br><span class="line">end case</span><br><span class="line"></span><br><span class="line">-- 语法一</span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc14_case(in pay_type int)</span><br><span class="line">begin</span><br><span class="line">  case pay_type</span><br><span class="line">        when  1 </span><br><span class="line">          then </span><br><span class="line">              select &#x27;微信支付&#x27; ;</span><br><span class="line">        when  2 then select &#x27;支付宝支付&#x27; ;</span><br><span class="line">        when  3 then select &#x27;银行卡支付&#x27;;</span><br><span class="line">      else select &#x27;其他方式支付&#x27;;</span><br><span class="line">    end case ;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line"> </span><br><span class="line">call proc14_case(2);</span><br><span class="line">call proc14_case(4);</span><br><span class="line"></span><br><span class="line">-- 语法二</span><br><span class="line">delimiter  $$</span><br><span class="line">create procedure proc_15_case(in score int)</span><br><span class="line">begin</span><br><span class="line">  case</span><br><span class="line">  when score &lt; 60 </span><br><span class="line">      then</span><br><span class="line">          select &#x27;不及格&#x27;;</span><br><span class="line">    when  score &lt; 80</span><br><span class="line">      then</span><br><span class="line">          select &#x27;及格&#x27; ;</span><br><span class="line">    when score &gt;= 80 and score &lt; 90</span><br><span class="line">       then </span><br><span class="line">           select &#x27;良好&#x27;;</span><br><span class="line">  when score &gt;= 90 and score &lt;= 100</span><br><span class="line">       then </span><br><span class="line">           select &#x27;优秀&#x27;;</span><br><span class="line">     else</span><br><span class="line">       select &#x27;成绩错误&#x27;;</span><br><span class="line">  end case;</span><br><span class="line">end $$</span><br><span class="line">delimiter  ;</span><br><span class="line"> </span><br><span class="line">call proc_15_case(88);</span><br></pre></td></tr></table></figure>
<p>循环是一段在程序中只出现一次,但可能会连续运行多次的代码</p>
<p>循环中的代码会运行特定的次数,或者是运行到特定条件成立时结束循环</p>
<p>分类：while repeat loop</p>
<p>循环控制</p>
<ul>
<li>leave 类似于 break，跳出，结束当前所在的循环</li>
<li>iterate类似于 continue，继续，结束本次循环，继续下一次</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- while</span><br><span class="line">/*</span><br><span class="line">【标签:】while 循环条件 do</span><br><span class="line">    循环体;</span><br><span class="line">end while【 标签】;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">-- 创建测试表</span><br><span class="line">create table user (</span><br><span class="line">    uid int primary_key,</span><br><span class="line">    username varchar ( 50 ),</span><br><span class="line">    password varchar ( 50 )</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- -------存储过程-while</span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc16_while1(in insertcount int)</span><br><span class="line">begin</span><br><span class="line">    declare i int default 1;</span><br><span class="line">    label:while i&lt;=insertcount do</span><br><span class="line">        insert into user(uid,username,`password`) values(i,concat(&#x27;user-&#x27;,i),&#x27;123456&#x27;);</span><br><span class="line">        set i=i+1;</span><br><span class="line">    end while label;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line"> </span><br><span class="line">call proc16_while(10);</span><br><span class="line"></span><br><span class="line">-- -------存储过程-while + leave</span><br><span class="line">truncate table user;</span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc16_while2(in insertcount int)</span><br><span class="line">begin</span><br><span class="line">    declare i int default 1;</span><br><span class="line">    label:while i&lt;=insertcount do</span><br><span class="line">        insert into user(uid,username,`password`) values(i,concat(&#x27;user-&#x27;,i),&#x27;123456&#x27;);</span><br><span class="line">        if i=5 then leave label;</span><br><span class="line">        end if;</span><br><span class="line">        set i=i+1;</span><br><span class="line">    end while label;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line"> </span><br><span class="line">call proc16_while2(10);</span><br><span class="line"></span><br><span class="line">-- -------存储过程-while+iterate</span><br><span class="line">truncate table user;</span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc16_while3(in insertcount int)</span><br><span class="line">begin</span><br><span class="line">    declare i int default 1;</span><br><span class="line">    label:while i&lt;=insertcount do</span><br><span class="line">        set i=i+1;</span><br><span class="line">        if i=5 then iterate label;</span><br><span class="line">        end if;</span><br><span class="line">        insert into user(uid,username,`password`) values(i,concat(&#x27;user-&#x27;,i),&#x27;123456&#x27;);</span><br><span class="line">    end while label;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line">call proc16_while3(10);</span><br><span class="line"></span><br><span class="line">-- repeat</span><br><span class="line">/*</span><br><span class="line">[标签:]repeat </span><br><span class="line"> 循环体;</span><br><span class="line">until 条件表达式</span><br><span class="line">end repeat [标签];</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">-- -------存储过程-循环控制-repeat </span><br><span class="line">use mysql7_procedure;</span><br><span class="line">truncate table user;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc18_repeat(in insertCount int)</span><br><span class="line">begin</span><br><span class="line">     declare i int default 1;</span><br><span class="line">     label:repeat</span><br><span class="line">         insert into user(uid, username, password) values(i,concat(&#x27;user-&#x27;,i),&#x27;123456&#x27;);</span><br><span class="line">         set i = i + 1;</span><br><span class="line">         until  i  &gt; insertCount</span><br><span class="line">     end repeat label;</span><br><span class="line">     select &#x27;循环结束&#x27;;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line"> </span><br><span class="line">call proc18_repeat(100);</span><br><span class="line"></span><br><span class="line">-- loop</span><br><span class="line">/*</span><br><span class="line">[标签:] loop</span><br><span class="line">  循环体;</span><br><span class="line">  if 条件表达式 then </span><br><span class="line">     leave [标签]; </span><br><span class="line">  end if;</span><br><span class="line">end loop;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">-- -------存储过程-循环控制-loop</span><br><span class="line">truncate table user;</span><br><span class="line"> </span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc19_loop(in insertCount int) </span><br><span class="line">begin</span><br><span class="line">     declare i int default 1;</span><br><span class="line">     label:loop</span><br><span class="line">         insert into user(uid, username, password) values(i,concat(&#x27;user-&#x27;,i),&#x27;123456&#x27;);</span><br><span class="line">         set i = i + 1;</span><br><span class="line">         if i &gt; 5 </span><br><span class="line">          then </span><br><span class="line">           leave label;</span><br><span class="line">         end if;</span><br><span class="line">     end loop label;</span><br><span class="line">     select &#x27;循环结束&#x27;;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line"> </span><br><span class="line">call proc19_loop(10);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>游标(cursor)是用来存储查询结果集的数据类型 , 在存储过程和函数中可以使用光标对结果集进行循环的处理。光标的使用包括光标的声明、OPEN、FETCH 和 CLOSE.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 声明语法</span><br><span class="line">declare cursor_name cursor for select_statement</span><br><span class="line">-- 打开语法</span><br><span class="line">open cursor_name</span><br><span class="line">-- 取值语法</span><br><span class="line">fetch cursor_name into var_name [, var_name] ...</span><br><span class="line">-- 关闭语法</span><br><span class="line">close cursor_name</span><br><span class="line"></span><br><span class="line">use mysql7_procedure;</span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc20_cursor(in in_dname varchar(50))</span><br><span class="line">begin</span><br><span class="line"> -- 定义局部变量</span><br><span class="line"> declare var_empno varchar(50);</span><br><span class="line"> declare var_ename varchar(50);</span><br><span class="line"> declare var_sal  decimal(7,2);</span><br><span class="line"> </span><br><span class="line"> -- 声明游标</span><br><span class="line"> declare my_cursor cursor for</span><br><span class="line">  select empno , ename, sal </span><br><span class="line">    from  dept a ,emp b</span><br><span class="line">    where a.deptno = b.deptno and a.dname = in_dname;</span><br><span class="line">    </span><br><span class="line">    -- 打开游标</span><br><span class="line">  open my_cursor;</span><br><span class="line">  -- 通过游标获取每一行数据</span><br><span class="line">  label:loop</span><br><span class="line">        fetch my_cursor into var_empno, var_ename, var_sal;</span><br><span class="line">        select var_empno, var_ename, var_sal;</span><br><span class="line">    end loop label;</span><br><span class="line">    </span><br><span class="line">    -- 关闭游标</span><br><span class="line">    close my_cursor;</span><br><span class="line">end</span><br><span class="line"> </span><br><span class="line"> -- 调用存储过程</span><br><span class="line"> call proc20_cursor(&#x27;销售部&#x27;);</span><br></pre></td></tr></table></figure>
<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>存储过程也提供了对异常处理的功能：通过定义HANDLER来完成异常声明的实现.</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/declare-handler.html">官方文档：</a><a href="https://dev.mysql.com/doc/refman/5.7/en/declare-handler.html">https://dev.mysql.com/doc/refman/5.7/en/declare-handler.html</a></p>
<p>在语法中，变量声明、游标声明、handler声明是必须按照先后顺序书写的，否则创建存储过程出错。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE handler_action HANDLER</span><br><span class="line">    FOR condition_value [, condition_value] ...</span><br><span class="line">    statement</span><br><span class="line"> </span><br><span class="line">handler_action: &#123;</span><br><span class="line">    CONTINUE</span><br><span class="line">  | EXIT</span><br><span class="line">  | UNDO</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">condition_value: &#123;</span><br><span class="line">    mysql_error_code</span><br><span class="line">  | condition_name</span><br><span class="line">  | SQLWARNING</span><br><span class="line">  | NOT FOUND</span><br><span class="line">  | SQLEXCEPTION</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">use mysql7_procedure;</span><br><span class="line">drop procedure if exists proc21_cursor_handler;</span><br><span class="line">-- 需求：输入一个部门名，查询该部门员工的编号、名字、薪资 ，将查询的结果集添加游标</span><br><span class="line">delimiter $$</span><br><span class="line">create procedure proc20_cursor(in in_dname varchar(50))</span><br><span class="line">begin</span><br><span class="line">  -- 定义局部变量</span><br><span class="line">    declare var_empno int;</span><br><span class="line">    declare var_ename varchar(50);</span><br><span class="line">    declare var_sal decimal(7,2);</span><br><span class="line">    </span><br><span class="line">    declare flag int default 1; -- ---------------------</span><br><span class="line">    </span><br><span class="line">    -- 声明游标</span><br><span class="line">    declare my_cursor cursor for</span><br><span class="line">        select empno,ename,sal</span><br><span class="line">        from dept a, emp b</span><br><span class="line">        where a.deptno = b.deptno and a.dname = in_dname;</span><br><span class="line">    </span><br><span class="line">    -- 定义句柄，当数据未发现时将标记位设置为0</span><br><span class="line">    declare continue handler for NOT FOUND set flag = 0;   </span><br><span class="line">    -- 打开游标</span><br><span class="line">    open my_cursor;</span><br><span class="line">    -- 通过游标获取值</span><br><span class="line">    label:loop</span><br><span class="line">        fetch my_cursor into var_empno, var_ename,var_sal;</span><br><span class="line">        -- 判断标志位</span><br><span class="line">        if flag = 1 then</span><br><span class="line">            select var_empno, var_ename,var_sal;</span><br><span class="line">        else</span><br><span class="line">            leave label;</span><br><span class="line">        end if;</span><br><span class="line">    end loop label;</span><br><span class="line">    </span><br><span class="line">    -- 关闭游标</span><br><span class="line">    close my_cursor;</span><br><span class="line">end $$;</span><br><span class="line"> </span><br><span class="line">delimiter ;</span><br><span class="line">call proc21_cursor_handler(&#x27;销售部&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql (三)</title>
    <url>/posts/18640.html</url>
    <content><![CDATA[<h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>锁是计算机协调多个进程或线程并发访问某一资源的机制（避免争抢）</p>
<p>在数据库中，除传统的计算资源（如 CPU、RAM、I/O 等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。</p>
<p>从对数据操作的粒度分 </p>
<ul>
<li>表锁：操作时，会锁定整个表。</li>
<li>行锁：操作时，会锁定当前操作行。</li>
</ul>
<p>从对数据操作的类型分：</p>
<ul>
<li>读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。</li>
<li>写锁（排它锁）：当前操作没有完成之前，它会阻断其他写锁和读锁。</li>
</ul>
<p>MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不同的锁机制。</p>
<p><img src="../../../images/image-20230613141316570.png" alt="image-20230613141316570"></p>
<p>MySQL锁的特性可大致归纳如下 ：</p>
<p><img src="../../../images/image-20230613141428795.png" alt="image-20230613141428795"></p>
<p>表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web 应用；</p>
<p>行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并查询的应用，如一些在线事务处理（OLTP）系统。</p>
<h2 id="MyIsam-表锁"><a href="#MyIsam-表锁" class="headerlink" title="MyIsam 表锁"></a>MyIsam 表锁</h2><p>MyISAM 在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作（UPDATE、DELETE、INSERT 等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用 LOCK TABLE 命令给 MyISAM 表显式加锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">加读锁 ： lock table table_name read; </span><br><span class="line"></span><br><span class="line">加写锁 ： lock table table_name write；</span><br></pre></td></tr></table></figure>
<p>表锁特点</p>
<ul>
<li>对MyISAM 表的读操作，不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求；</li>
<li>对MyISAM 表的写操作，则会阻塞其他用户对同一表的读和写操作；</li>
</ul>
<p>读锁会阻塞写，但是不会阻塞读。而写锁，则既会阻塞读，又会阻塞写。</p>
<p>MyISAM 的读写锁调度是写优先，这也是MyISAM不适合做写为主的表的存储引擎的原因。因为写锁后，其他线程不能做任何操作，大量的更新会使查询很难得到锁，从而造成永远阻塞。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- MySQL的锁机制</span><br><span class="line">drop database if exists  mydb14_lock;</span><br><span class="line">create database mydb14_lock ;</span><br><span class="line"> </span><br><span class="line">use mydb14_lock;</span><br><span class="line">  </span><br><span class="line">create table `tb_book` (</span><br><span class="line">  `id` int(11) auto_increment,</span><br><span class="line">  `name` varchar(50) default null,</span><br><span class="line">  `publish_time` date default null,</span><br><span class="line">  `status` char(1) default null,</span><br><span class="line">  primary key (`id`)</span><br><span class="line">) engine=myisam default charset=utf8 ;</span><br><span class="line"> </span><br><span class="line">insert into tb_book (id, name, publish_time, status) values(null,&#x27;java编程思想&#x27;,&#x27;2088-08-01&#x27;,&#x27;1&#x27;);</span><br><span class="line">insert into tb_book (id, name, publish_time, status) values(null,&#x27;solr编程思想&#x27;,&#x27;2088-08-08&#x27;,&#x27;0&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">create table `tb_user` (</span><br><span class="line">  `id` int(11) auto_increment,</span><br><span class="line">  `name` varchar(50) default null,</span><br><span class="line">  primary key (`id`)</span><br><span class="line">) engine=myisam default charset=utf8 ;</span><br><span class="line"> </span><br><span class="line">insert into tb_user (id, name) values(null,&#x27;令狐冲&#x27;);</span><br><span class="line">insert into tb_user (id, name) values(null,&#x27;田伯光&#x27;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="InnoDB行锁"><a href="#InnoDB行锁" class="headerlink" title="InnoDB行锁"></a>InnoDB行锁</h2><p>行锁特点 ：偏向InnoDB 存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</p>
<p>InnoDB 与 MyISAM 的最大不同有两点：一是支持事务；二是 采用了行级锁。</p>
<p>InnoDB 实现了以下两种类型的行锁。</p>
<p>共享锁（S）：又称为读锁，简称S锁，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。</p>
<p>排他锁（X）：又称为写锁，简称X锁，排他锁就是不能与其他锁并存，如一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据就行读取和修改。</p>
<p>对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；</p>
<p>对于普通SELECT语句，InnoDB不会加任何锁；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE </span><br><span class="line">排他锁（X) ：SELECT * FROM table_name WHERE ... FOR UPDATE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 行锁 </span><br><span class="line">drop table if exists test_innodb_lock;</span><br><span class="line">create table test_innodb_lock(</span><br><span class="line">    id int(11),</span><br><span class="line">    name varchar(16),</span><br><span class="line">    sex varchar(1)</span><br><span class="line">)engine = innodb ;</span><br><span class="line"> </span><br><span class="line">insert into test_innodb_lock values(1,&#x27;100&#x27;,&#x27;1&#x27;);</span><br><span class="line">insert into test_innodb_lock values(3,&#x27;3&#x27;,&#x27;1&#x27;);</span><br><span class="line">insert into test_innodb_lock values(4,&#x27;400&#x27;,&#x27;0&#x27;);</span><br><span class="line">insert into test_innodb_lock values(5,&#x27;500&#x27;,&#x27;1&#x27;);</span><br><span class="line">insert into test_innodb_lock values(6,&#x27;600&#x27;,&#x27;0&#x27;);</span><br><span class="line">insert into test_innodb_lock values(7,&#x27;700&#x27;,&#x27;0&#x27;);</span><br><span class="line">insert into test_innodb_lock values(8,&#x27;800&#x27;,&#x27;1&#x27;);</span><br><span class="line">insert into test_innodb_lock values(9,&#x27;900&#x27;,&#x27;1&#x27;);</span><br><span class="line">insert into test_innodb_lock values(1,&#x27;200&#x27;,&#x27;0&#x27;);</span><br><span class="line"> </span><br><span class="line">create index idx_test_innodb_lock_id on test_innodb_lock(id);</span><br><span class="line">create index idx_test_innodb_lock_name on test_innodb_lock(name);</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<h2 id="MVCC-多版本并发控制"><a href="#MVCC-多版本并发控制" class="headerlink" title="MVCC 多版本并发控制"></a>MVCC 多版本并发控制</h2><p><img src="../../../images/image-20230614144741031.png" alt="image-20230614144741031"></p>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>在任何一种数据库中，都会有各种各样的日志，记录着数据库工作的方方面面，以帮助数据库管理员追踪数据库曾经发生过的各种事件</p>
<h2 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h2><p>错误日志是 MySQL 中最重要的日志之一，它记录了当 mysqld 启动和停止时，以及服务器在运行过程中发生任何严重错误时的相关信息。当数据库出现任何故障导致无法正常使用时，可以首先查看此日志。</p>
<p>该日志是默认开启的 ， 默认存放目录为 mysql 的数据目录, 默认的日志文件名为 hostname.err（hostname是主机名）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看日志位置指令</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_error&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h2 id="二进制日志binlog"><a href="#二进制日志binlog" class="headerlink" title="二进制日志binlog"></a>二进制日志binlog</h2><p>二进制日志（BINLOG）记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但是不包括数据查询语句。此日志对于灾难时的数据恢复起着极其重要的作用，MySQL的主从复制， 就是通过该binlog实现的。</p>
<p>二进制日志，MySQl8.0默认已经开启，低版本的MySQL的需要通过配置文件开启，并配置MySQL日志的格式。</p>
<p>Windows系统：my.ini  Linux系统:my.cnf</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">#配置开启binlog日志， 日志的文件前缀为 mysqlbin -----&gt; 生成的文件名如 : mysqlbin.000001,mysqlbin.000002</span></span><br><span class="line"><span class="attr">log_bin</span>=mysqlbin</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置二进制日志的格式</span></span><br><span class="line"><span class="attr">binlog_format</span>=STATEMENT</span><br></pre></td></tr></table></figure>
<p>日志格式</p>
<ul>
<li><p>STATEMENT</p>
<p>该日志格式在日志文件中记录的都是SQL语句（statement），每一条对数据进行修改的SQL都会记录在日志文件中，通过Mysql提供的mysqlbinlog工具，可以清晰的查看到每条语句的文本。主从复制的时候，从库（slave）会将日志解析为原文本，并在从库重新执行一次</p>
</li>
<li><p>ROW</p>
<p>该日志格式在日志文件中记录的是每一行的数据变更，而不是记录SQL语句。比如，执行SQL语句 ： update tb_book set status=’1’ , 如果是STATEMENT 日志格式，在日志中会记录一行SQL文件； 如果是ROW，由于是对全表进行更新，也就是每一行记录都会发生变更，ROW 格式的日志中会记录每一行的数据变更</p>
</li>
<li><p>MIXED</p>
<ul>
<li>混合了STATEMENT 和 ROW两种格式。</li>
</ul>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看MySQL是否开启了binlog日志</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;log_bin&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 查看binlog日志的格式</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;binlog_format&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 查看所有日志</span></span><br><span class="line"><span class="keyword">show</span> binlog events;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 查看最新的日志</span></span><br><span class="line"><span class="keyword">show</span> master status;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 查询指定的binlog日志</span></span><br><span class="line"><span class="keyword">show</span> binlog events <span class="keyword">in</span> <span class="string">&#x27;binlog.000010&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mydb1.emp2;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> mydb1.emp2;</span><br><span class="line"><span class="keyword">update</span> mydb1.emp2 <span class="keyword">set</span> salary <span class="operator">=</span> <span class="number">8000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 从指定的位置开始,查看指定的Binlog日志</span></span><br><span class="line"><span class="keyword">show</span> binlog events <span class="keyword">in</span> <span class="string">&#x27;binlog.000010&#x27;</span> <span class="keyword">from</span> <span class="number">156</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 从指定的位置开始,查看指定的Binlog日志,限制查询的条数</span></span><br><span class="line"><span class="keyword">show</span> binlog events <span class="keyword">in</span> <span class="string">&#x27;binlog.000010&#x27;</span> <span class="keyword">from</span> <span class="number">156</span> limit <span class="number">2</span>;</span><br><span class="line"><span class="comment">--从指定的位置开始，带有偏移，查看指定的Binlog日志,限制查询的条数</span></span><br><span class="line"><span class="keyword">show</span> binlog events <span class="keyword">in</span> <span class="string">&#x27;binlog.000010&#x27;</span> <span class="keyword">from</span> <span class="number">666</span> limit <span class="number">1</span>, <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 清空所有的 binlog 日志文件</span></span><br><span class="line">reset master</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="查询日志"><a href="#查询日志" class="headerlink" title="查询日志"></a>查询日志</h2><p>查询日志中记录了客户端的所有操作语句，而二进制日志不包含查询数据的SQL语句。</p>
<p>默认情况下， 查询日志是未开启的。如果需要开启查询日志，可以设置以下配置 ：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">#该选项用来开启查询日志 ， 可选值 ： 0 或者 1 ； 0 代表关闭， 1 代表开启 </span></span><br><span class="line"><span class="attr">general_log</span>=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#设置日志的文件名 ， 如果没有指定， 默认的文件名为 host_name.log </span></span><br><span class="line"><span class="attr">general_log_file</span>=file_name</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看MySQL是否开启了查询日志</span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;general_log&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 开启查询日志</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span>  general_log<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mydb1.emp2;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> mydb6_view.emp;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> mydb1.emp2;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> mydb6_view.emp;</span><br><span class="line"><span class="keyword">update</span> mydb1.emp2 <span class="keyword">set</span> salary <span class="operator">=</span> <span class="number">9000</span>;</span><br></pre></td></tr></table></figure>
<h2 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h2><p>慢查询日志记录了所有执行时间超过参数 long_query_time 设置值并且扫描记录数不小于 min_examined_row_limit 的所有的SQL语句的日志。long_query_time 默认为 10 秒，最小为 0， 精度可以到微秒。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 该参数用来控制慢查询日志是否开启， 可取值： 1 和 0 ， 1 代表开启， 0 代表关闭</span></span><br><span class="line"><span class="attr">slow_query_log</span>=<span class="number">1</span></span><br><span class="line"></span><br><span class="line"> <span class="comment"># 该参数用来指定慢查询日志的文件名</span></span><br><span class="line"><span class="attr">slow_query_log_file</span>=slow_query.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 该选项用来配置查询的时间限制， 超过这个时间将认为值慢查询， 将需要进行日志记录， 默认10s</span></span><br><span class="line"><span class="attr">long_query_time</span>=<span class="number">10</span></span><br></pre></td></tr></table></figure>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><ul>
<li><p>从设计上优化</p>
</li>
<li><p>从查询上优化</p>
</li>
<li><p>从索引上优化</p>
</li>
<li><p>从存储上优化</p>
</li>
</ul>
<h2 id="查看SQL执行频率"><a href="#查看SQL执行频率" class="headerlink" title="查看SQL执行频率"></a>查看SQL执行频率</h2><p>MySQL 客户端连接成功后，通过 show [session|global] status 命令可以查看服务器状态信息。通过查看状态信息可以查看对当前数据库的主要操作类型。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--下面的命令显示了当前 session 中所有统计参数的值</span></span><br><span class="line"><span class="keyword">show</span> session status <span class="keyword">like</span> <span class="string">&#x27;Com_______&#x27;</span>;  <span class="comment">-- 查看当前会话统计结果</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span>  status  <span class="keyword">like</span> <span class="string">&#x27;Com_______&#x27;</span>;  <span class="comment">-- 查看自数据库上次启动至今统计结果</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">show</span> status <span class="keyword">like</span> <span class="string">&#x27;Innodb_rows_%’;       -- 查看针对Innodb引擎的统计结果</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<p><img src="../../../images/image-20230613145353636.png" alt="image-20230613145353636"></p>
<h2 id="定位低效率执行SQL"><a href="#定位低效率执行SQL" class="headerlink" title="定位低效率执行SQL"></a>定位低效率执行SQL</h2><p>慢查询日志 : 通过慢查询日志定位那些执行效率较低的 SQL 语句。</p>
<p>show processlist：该命令查看当前MySQL在进行的线程，包括线程的状态、是否锁表等，可以实时地查看 SQL 的执行情况，同时对一些锁表操作进行优化。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看慢日志配置信息 </span></span><br><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%slow_query_log%’; </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- 开启慢日志查询 </span></span><br><span class="line"><span class="string">set global slow_query_log=1; </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- 查看慢日志记录SQL的最低阈值时间 </span></span><br><span class="line"><span class="string">show variables like &#x27;</span>long_query_time<span class="operator">%</span>’; </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 修改慢日志记录SQL的最低阈值时间 </span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> long_query_time<span class="operator">=</span><span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<p>show processlist; </p>
<p><img src="../../../images/image-20230613145518066.png" alt="image-20230613145518066"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1） id列，用户登录mysql时，系统分配的&quot;connection_id&quot;，可以使用函数connection_id()查看</span><br><span class="line">2） user列，显示当前用户。如果不是root，这个命令就只显示用户权限范围的sql语句</span><br><span class="line">3） host列，显示这个语句是从哪个ip的哪个端口上发的，可以用来跟踪出现问题语句的用户</span><br><span class="line">4） db列，显示这个进程目前连接的是哪个数据库</span><br><span class="line">5） command列，显示当前连接的执行的命令，一般取值为休眠（sleep），查询（query），连接（connect）等</span><br><span class="line">6） time列，显示这个状态持续的时间，单位是秒</span><br><span class="line">7） state列，显示使用当前连接的sql语句的状态，很重要的列。state描述的是语句执行中的某一个状态。一个sql语句，以查询为例，可能需要经过copying to tmp table、sorting result、sending data等状态才可以完成</span><br><span class="line">8） info列，显示这个sql语句，是判断问题语句的一个重要依据</span><br></pre></td></tr></table></figure>
<h2 id="explain分析执行计划"><a href="#explain分析执行计划" class="headerlink" title="explain分析执行计划"></a>explain分析执行计划</h2><p>通过以上步骤查询到效率低的 SQL 语句后，可以通过 EXPLAIN命令获取 MySQL如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> uid <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><img src="../../../images/image-20230613155817391.png" alt="image-20230613155817391"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> uname <span class="operator">=</span> <span class="string">&#x27;张飞&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p><img src="../../../images/image-20230613155822486.png" alt="image-20230613155822486"></p>
<p><img src="../../../images/image-20230613155827301.png" alt="image-20230613155827301"></p>
<p><img src="../../../images/image-20230613160545902.png" alt="image-20230613160545902"></p>
<p><strong>id 情况有三种:</strong></p>
<p>1、id 相同表示加载表的顺序是从上到下</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> u, user_role ur, role r <span class="keyword">where</span> u.uid <span class="operator">=</span> ur.uid <span class="keyword">and</span> ur.rid <span class="operator">=</span> r.rid ;</span><br></pre></td></tr></table></figure>
<p><img src="../../../images/image-20230613155905534.png" alt="image-20230613155905534"></p>
<p>2、 id 不同id值越大，优先级越高，越先被执行。 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> role <span class="keyword">where</span> rid <span class="operator">=</span> (<span class="keyword">select</span> rid <span class="keyword">from</span> user_role <span class="keyword">where</span> uid <span class="operator">=</span> (<span class="keyword">select</span> uid <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> uname <span class="operator">=</span> <span class="string">&#x27;张飞&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p><img src="../../../images/image-20230613155935286.png" alt="image-20230613155935286"></p>
<p>3、  id 有相同，也有不同，同时存在。id相同的可以认为是一组，从上往下顺序执行；在所有的组中，id的值越大，优先级越高，越先执行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> role r , (<span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> user_role ur <span class="keyword">where</span> ur.uid <span class="operator">=</span> (<span class="keyword">select</span> uid <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> uname <span class="operator">=</span> <span class="string">&#x27;张飞&#x27;</span>)) t <span class="keyword">where</span> r.rid <span class="operator">=</span> t.rid ; </span><br></pre></td></tr></table></figure>
<p><img src="../../../images/image-20230613160003285.png" alt="image-20230613160003285"></p>
<p> <strong>select_type表示 SELECT 的类型，常见的取值，如下表所示：</strong></p>
<p><img src="../../../images/image-20230613160033724.png" alt="image-20230613160033724"></p>
<p><strong>type 显示的是访问类型，是较为重要的一个指标，可取值为：</strong> </p>
<p><img src="../../../images/image-20230613160045178.png" alt="image-20230613160045178"></p>
<p>结果值从最好到最坏以此是：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</p>
<p><strong>extra</strong></p>
<p><img src="../../../images/image-20230613160602801.png" alt="image-20230613160602801"></p>
<h2 id="show-profile分析SQL"><a href="#show-profile分析SQL" class="headerlink" title="show profile分析SQL"></a>show profile分析SQL</h2><p>Mysql从5.0.37版本开始增加了对 show profiles 和 show profile 语句的支持。show profiles 能够在做SQL优化时帮助我们了解时间都耗费到哪里去了</p>
<p>通过 have_profiling 参数，能够看到当前MySQL是否支持profile：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> @<span class="variable">@have_profiling</span>; </span><br><span class="line"><span class="keyword">set</span> profiling<span class="operator">=</span><span class="number">1</span>; <span class="comment">-- 开启profiling 开关； </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> databases;</span><br><span class="line">use mydb13_optimize;</span><br><span class="line"><span class="keyword">show</span> tables;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> id <span class="operator">&lt;</span> <span class="number">2</span>;</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> <span class="keyword">user</span>;</span><br><span class="line"><span class="comment">-- 执行完上述命令之后，再执行show profiles 指令， 来查看SQL语句执行的耗时：</span></span><br><span class="line"><span class="keyword">show</span> profiles;</span><br></pre></td></tr></table></figure>
<p><img src="../../../images/image-20230613160924777.png" alt="image-20230613160924777"></p>
<p>通过show profile for query query_id 语句可以查看到该SQL执行过程中每个线程的状态和消耗的时间：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> profile <span class="keyword">for</span> query <span class="number">8</span>;</span><br></pre></td></tr></table></figure>
<p><img src="../../../images/image-20230613160947011.png" alt="image-20230613160947011"></p>
<p>在获取到最消耗时间的线程状态后，MySQL支持进一步选择all、cpu、block io 、context switch、page faults等明细类型类查看MySQL在使用什么资源上耗费了过高的时间。例如，选择查看CPU的耗费时间 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> profile cpu <span class="keyword">for</span> query <span class="number">133</span>;  </span><br></pre></td></tr></table></figure>
<p><img src="../../../images/image-20230613161009143.png" alt="image-20230613161009143"></p>
<p><img src="../../../images/image-20230613161015312.png" alt="image-20230613161015312"></p>
<h2 id="trace分析优化器执行计划"><a href="#trace分析优化器执行计划" class="headerlink" title="trace分析优化器执行计划"></a>trace分析优化器执行计划</h2><p>MySQL5.6提供了对SQL的跟踪trace, 通过trace文件能够进一步了解为什么优化器选择A计划, 而不是选择B计划</p>
<p><img src="../../../images/image-20230613161055516.png" alt="image-20230613161055516"></p>
<p>打开trace ， 设置格式为 JSON，并设置trace最大能够使用的内存大小，避免解析过程中因为默认内存过小而不能够完整展示。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SET</span> optimizer_trace<span class="operator">=</span>&quot;enabled=on&quot;,end_markers_in_json<span class="operator">=</span><span class="keyword">on</span>; </span><br><span class="line"><span class="keyword">set</span> optimizer_trace_max_mem_size<span class="operator">=</span><span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> uid <span class="operator">&lt;</span> <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>最后， 检查information_schema.optimizer_trace就可以知道MySQL是如何执行SQL的 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> information_schema.optimizer_trace\G;</span><br></pre></td></tr></table></figure>
<p><img src="../../../images/image-20230613161322433.png" alt="image-20230613161322433"></p>
<h2 id="使用索引优化"><a href="#使用索引优化" class="headerlink" title="使用索引优化"></a>使用索引优化</h2><p>索引是数据库优化最常用也是最重要的手段之一, 通过索引通常可以帮助用户解决大多数的MySQL的性能优化问题。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `tb_seller` (</span><br><span class="line">    `sellerid` <span class="type">varchar</span> (<span class="number">100</span>),</span><br><span class="line">    `name` <span class="type">varchar</span> (<span class="number">100</span>),</span><br><span class="line">    `nickname` <span class="type">varchar</span> (<span class="number">50</span>),</span><br><span class="line">    `password` <span class="type">varchar</span> (<span class="number">60</span>),</span><br><span class="line">    `status` <span class="type">varchar</span> (<span class="number">1</span>),</span><br><span class="line">    `address` <span class="type">varchar</span> (<span class="number">100</span>),</span><br><span class="line">    `createtime` datetime,</span><br><span class="line">    <span class="keyword">primary</span> key(`sellerid`)</span><br><span class="line">); </span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;alibaba&#x27;</span>,<span class="string">&#x27;阿里巴巴&#x27;</span>,<span class="string">&#x27;阿里小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;baidu&#x27;</span>,<span class="string">&#x27;百度科技有限公司&#x27;</span>,<span class="string">&#x27;百度小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;huawei&#x27;</span>,<span class="string">&#x27;华为科技有限公司&#x27;</span>,<span class="string">&#x27;华为小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;itcast&#x27;</span>,<span class="string">&#x27;传智播客教育科技有限公司&#x27;</span>,<span class="string">&#x27;传智播客&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;itheima&#x27;</span>,<span class="string">&#x27;黑马程序员&#x27;</span>,<span class="string">&#x27;黑马程序员&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;luoji&#x27;</span>,<span class="string">&#x27;罗技科技有限公司&#x27;</span>,<span class="string">&#x27;罗技小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;oppo&#x27;</span>,<span class="string">&#x27;OPPO科技有限公司&#x27;</span>,<span class="string">&#x27;OPPO官方旗舰店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;ourpalm&#x27;</span>,<span class="string">&#x27;掌趣科技股份有限公司&#x27;</span>,<span class="string">&#x27;掌趣小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;qiandu&#x27;</span>,<span class="string">&#x27;千度科技&#x27;</span>,<span class="string">&#x27;千度小店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;sina&#x27;</span>,<span class="string">&#x27;新浪科技有限公司&#x27;</span>,<span class="string">&#x27;新浪官方旗舰店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;xiaomi&#x27;</span>,<span class="string">&#x27;小米科技&#x27;</span>,<span class="string">&#x27;小米官方旗舰店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;西安市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `tb_seller` (`sellerid`, `name`, `nickname`, `password`, `status`, `address`, `createtime`) <span class="keyword">values</span>(<span class="string">&#x27;yijia&#x27;</span>,<span class="string">&#x27;宜家家居&#x27;</span>,<span class="string">&#x27;宜家家居旗舰店&#x27;</span>,<span class="string">&#x27;e10adc3949ba59abbe56e057f20f883e&#x27;</span>,<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;北京市&#x27;</span>,<span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建组合索引 </span></span><br><span class="line"><span class="keyword">create</span> index idx_seller_name_sta_addr <span class="keyword">on</span> tb_seller(name,status,address);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 避免索引失效应用-全局匹配 </span></span><br><span class="line"><span class="comment">-- 该情况下，索引生效，执行效率高。</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;北京市&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 避免索引失效应用-最左前缀法则</span></span><br><span class="line"><span class="comment">-- 该情况下，索引生效，执行效率高。</span></span><br><span class="line"> <span class="comment">-- 如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始，并且不跳过索引中的列。</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span>; <span class="comment">-- 403</span></span><br><span class="line"> </span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span> <span class="keyword">and</span> status<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>; <span class="comment">-- 410</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span>  status<span class="operator">=</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span>; <span class="comment">-- 410</span></span><br><span class="line"><span class="comment">-- 违法最左前缀法则 ， 索引失效：</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> status<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>; <span class="comment">-- nulll</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 如果符合最左法则，但是出现跳跃某一列，只有最左列索引生效：</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span>  <span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;北京市&#x27;</span>; <span class="comment">-- 403</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 避免索引失效应用-其他匹配原则</span></span><br><span class="line"><span class="comment">-- 该情况下，索引生效，执行效率高。</span></span><br><span class="line"><span class="comment">-- 范围查询右边的列，不能使用索引 。 </span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span> <span class="keyword">and</span> status <span class="operator">&gt;</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;北京市’; </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">-- 不要在索引列上进行运算操作， 索引将失效。 </span></span><br><span class="line"><span class="string">explain select * from tb_seller where substring(name,3,2)=&#x27;</span>科技’ </span><br><span class="line"></span><br><span class="line"><span class="comment">-- 字符串不加单引号，造成索引失效。 </span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 1、范围查询右边的列，不能使用索引 。</span></span><br><span class="line"><span class="comment">-- 根据前面的两个字段name ， status 查询是走索引的， 但是最后一个条件address 没有用到索引。</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span> <span class="keyword">and</span> status <span class="operator">&gt;</span><span class="string">&#x27;1&#x27;</span> <span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;北京市&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 2、不要在索引列上进行运算操作， 索引将失效。</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> <span class="built_in">substring</span>(name,<span class="number">3</span>,<span class="number">2</span>)<span class="operator">=</span><span class="string">&#x27;科技&#x27;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 3、字符串不加单引号，造成索引失效。 </span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span> <span class="keyword">and</span> status <span class="operator">=</span> <span class="number">1</span> ;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 4、尽量使用覆盖索引，避免select *</span></span><br><span class="line"><span class="comment">-- 需要从原表及磁盘上读取数据</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span>  <span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;北京市&#x27;</span>;  <span class="comment">-- 效率低</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 从索引树中就可以查询到所有数据</span></span><br><span class="line">explain <span class="keyword">select</span> name <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span>  <span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;北京市&#x27;</span>;  <span class="comment">-- 效率高</span></span><br><span class="line">explain <span class="keyword">select</span> name,status,address <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span>  <span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;北京市&#x27;</span>;  <span class="comment">-- 效率高</span></span><br><span class="line"><span class="comment">-- 如果查询列，超出索引列，也会降低性能。</span></span><br><span class="line">explain <span class="keyword">select</span> name,status,address,password <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span>  <span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;北京市&#x27;</span>;  <span class="comment">-- 效率低</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 尽量使用覆盖索引，避免select *</span></span><br><span class="line"><span class="comment">-- 需要从原表及磁盘上读取数据</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span>  <span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;北京市&#x27;</span>;  <span class="comment">-- 效率低</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 从索引树中就可以查询到所有数据</span></span><br><span class="line">explain <span class="keyword">select</span> name <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span>  <span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;北京市&#x27;</span>;  <span class="comment">-- 效率高</span></span><br><span class="line">explain <span class="keyword">select</span> name,status,address <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span>  <span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;北京市&#x27;</span>;  <span class="comment">-- 效率高</span></span><br><span class="line"><span class="comment">-- 如果查询列，超出索引列，也会降低性能。</span></span><br><span class="line">explain <span class="keyword">select</span> name,status,address,password <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;小米科技&#x27;</span>  <span class="keyword">and</span> address<span class="operator">=</span><span class="string">&#x27;北京市&#x27;</span>;  <span class="comment">-- 效率低</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 用or分割开的条件， 那么涉及的索引都不会被用到。</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;黑马程序员&#x27;</span> <span class="keyword">or</span> createtime <span class="operator">=</span> <span class="string">&#x27;2088-01-01 12:00:00&#x27;</span>; </span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;黑马程序员&#x27;</span> <span class="keyword">or</span> address <span class="operator">=</span> <span class="string">&#x27;西安市&#x27;</span>;  </span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name<span class="operator">=</span><span class="string">&#x27;黑马程序员&#x27;</span> <span class="keyword">or</span> status <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;   </span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 以%开头的Like模糊查询，索引失效。</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;科技%&#x27;</span>; <span class="comment">-- 用索引</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%科技&#x27;</span>; <span class="comment">-- 不用索引</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%科技%&#x27;</span>;<span class="comment">-- 不用索引</span></span><br><span class="line"><span class="comment">-- 弥补不足,不用*，使用索引列</span></span><br><span class="line">explain <span class="keyword">select</span> name <span class="keyword">from</span> tb_seller <span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%科技%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment">--  1、如果MySQL评估使用索引比全表更慢，则不使用索引。</span></span><br><span class="line">  <span class="comment">-- 这种情况是由数据本身的特点来决定的</span></span><br><span class="line"><span class="keyword">create</span> index index_address <span class="keyword">on</span> tb_seller(address);</span><br><span class="line"> </span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> address <span class="operator">=</span> <span class="string">&#x27;北京市&#x27;</span>; <span class="comment">-- 没有使用索引</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> address <span class="operator">=</span> <span class="string">&#x27;西安市&#x27;</span>; <span class="comment">-- 没有使用索引</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">--  2、is  NULL ， is NOT NULL  有时有效，有时索引失效。</span></span><br><span class="line"><span class="keyword">create</span> index index_address <span class="keyword">on</span> tb_seller(nickname);</span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> nickname <span class="keyword">is</span> <span class="keyword">NULL</span>;  <span class="comment">-- 索引有效</span></span><br><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> tb_seller <span class="keyword">where</span> nickname <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">NULL</span>; <span class="comment">-- 无效</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="Sql-优化"><a href="#Sql-优化" class="headerlink" title="Sql 优化"></a>Sql 优化</h2><p>大批量插入数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> `tb_user` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">not</span> <span class="keyword">null</span> auto_increment,</span><br><span class="line">  `username` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  `password` <span class="type">varchar</span>(<span class="number">96</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  `birthday` datetime <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">  `sex` <span class="type">char</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">  `email` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">  `phone` <span class="type">varchar</span>(<span class="number">45</span>) <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">  `qq` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">  `status` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">not</span> <span class="keyword">null</span> comment <span class="string">&#x27;用户状态&#x27;</span>,</span><br><span class="line">  `create_time` datetime <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">  `update_time` datetime <span class="keyword">default</span> <span class="keyword">null</span>,</span><br><span class="line">  <span class="keyword">primary</span> key (`id`),</span><br><span class="line">  <span class="keyword">unique</span> key `unique_user_username` (`username`)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当使用load 命令导入数据的时候，适当的设置可以提高导入的效率。对于 InnoDB 类型的表，有以下几种方式可以提高导入的效率：</p>
<ol>
<li><p>主键顺序插入</p>
<p>因为InnoDB类型的表是按照主键的顺序保存的，所以将导入的数据按照主键的顺序排列，可以有效的提高导入数据的效率。如果InnoDB表没有主键，那么系统会自动默认创建一个内部列作为主键，所以如果可以给表创建一个主键，将可以利用这点，来提高导入数据的效率。</p>
</li>
</ol>
<p><img src="../../../images/image-20230613161801043.png" alt="image-20230613161801043"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 1、首先，检查一个全局系统变量 &#x27;local_infile&#x27; 的状态， 如果得到如下显示 Value=OFF，则说明这是不可用的</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">global</span> variables <span class="keyword">like</span> <span class="string">&#x27;local_infile&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 2、修改local_infile值为on，开启local_infile</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">global</span> local_infile<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 3、加载数据 </span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">脚本文件介绍 :</span></span><br><span class="line"><span class="comment">    sql1.log  ----&gt; 主键有序</span></span><br><span class="line"><span class="comment">    sql2.log  ----&gt; 主键无序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">load data <span class="keyword">local</span> infile <span class="string">&#x27;D:\\sql_data\\sql1.log&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> tb_user fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>关闭唯一性校验</li>
</ol>
<p>在导入数据前执行 SET UNIQUE_CHECKS=0，关闭唯一性校验，在导入结束后执行SET UNIQUE_CHECKS=1，恢复唯一性校验，可以提高导入的效率。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 关闭唯一性校验</span></span><br><span class="line"><span class="keyword">SET</span> UNIQUE_CHECKS<span class="operator">=</span><span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> tb_user;</span><br><span class="line">load data <span class="keyword">local</span> infile <span class="string">&#x27;D:\\sql_data\\sql1.log&#x27;</span> <span class="keyword">into</span> <span class="keyword">table</span> tb_user fields terminated <span class="keyword">by</span> <span class="string">&#x27;,&#x27;</span> lines terminated <span class="keyword">by</span> <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">SET</span> UNIQUE_CHECKS<span class="operator">=</span><span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>优化insert语句</li>
</ol>
<p>当进行数据的insert操作的时候，可以考虑采用以下几种优化方案:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 如果需要同时对一张表插入很多行数据时，应该尽量使用多个值表的insert语句，这种方式将大大的缩减客户端与数据库之间的连接、关闭等消耗。使得效率比分开执行的单个insert语句快。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 原始方式为：</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 优化后的方案为 ： </span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>)，(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在事务中进行数据插入。</span></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">commit</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 数据有序插入</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;Tim&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;Rose&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">-- 优化后</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">1</span>,<span class="string">&#x27;Tom&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">2</span>,<span class="string">&#x27;Cat&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">3</span>,<span class="string">&#x27;Jerry&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">4</span>,<span class="string">&#x27;Tim&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tb_test <span class="keyword">values</span>(<span class="number">5</span>,<span class="string">&#x27;Rose&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>优化order by语句</li>
</ol>
<p>两种排序方式</p>
<ul>
<li>通过对返回数据进行排序，也就是通常说的 filesort 排序，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</li>
<li>通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。</li>
</ul>
<p>Filesort 的优化</p>
<p>通过创建合适的索引，能够减少 Filesort 的出现，但是在某些情况下，条件限制不能让Filesort消失，那就需要加快 Filesort的排序操作。对于Filesort ， MySQL 有两种排序算法：</p>
<ul>
<li>两次扫描算法 ：MySQL4.1 之前，使用该方式排序。首先根据条件取出排序字段和行指针信息，然后在排序区 sort buffer 中排序，如果sort buffer不够，则在临时表 temporary table 中存储排序结果。完成排序之后，再根据行指针回表读取记录，该操作可能会导致大量随机I/O操作。</li>
<li>一次扫描算法：一次性取出满足条件的所有字段，然后在排序区 sort buffer 中排序后直接输出结果集。排序时内存开销较大，但是排序效率比两次扫描算法要高。</li>
</ul>
<p>MySQL 通过比较系统变量 max_length_for_sort_data 的大小和Query语句取出的字段总大小， 来判定是否那种排序算法，如果max_length_for_sort_data 更大，那么使用第二种优化之后的算法；否则使用第一种。</p>
<p>可以适当提高 sort_buffer_size 和 max_length_for_sort_data 系统变量，来增大排序区的大小，提高排序的效率。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `emp` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `age` <span class="type">int</span>(<span class="number">3</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `salary` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span>,<span class="string">&#x27;25&#x27;</span>,<span class="string">&#x27;2300&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;Jerry&#x27;</span>,<span class="string">&#x27;30&#x27;</span>,<span class="string">&#x27;3500&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;Luci&#x27;</span>,<span class="string">&#x27;25&#x27;</span>,<span class="string">&#x27;2800&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;Jay&#x27;</span>,<span class="string">&#x27;36&#x27;</span>,<span class="string">&#x27;3500&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;Tom2&#x27;</span>,<span class="string">&#x27;21&#x27;</span>,<span class="string">&#x27;2200&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;Jerry2&#x27;</span>,<span class="string">&#x27;31&#x27;</span>,<span class="string">&#x27;3300&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;Luci2&#x27;</span>,<span class="string">&#x27;26&#x27;</span>,<span class="string">&#x27;2700&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;Jay2&#x27;</span>,<span class="string">&#x27;33&#x27;</span>,<span class="string">&#x27;3500&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;9&#x27;</span>,<span class="string">&#x27;Tom3&#x27;</span>,<span class="string">&#x27;23&#x27;</span>,<span class="string">&#x27;2400&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;10&#x27;</span>,<span class="string">&#x27;Jerry3&#x27;</span>,<span class="string">&#x27;32&#x27;</span>,<span class="string">&#x27;3100&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;11&#x27;</span>,<span class="string">&#x27;Luci3&#x27;</span>,<span class="string">&#x27;26&#x27;</span>,<span class="string">&#x27;2900&#x27;</span>);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> `emp` (`id`, `name`, `age`, `salary`) <span class="keyword">values</span>(<span class="string">&#x27;12&#x27;</span>,<span class="string">&#x27;Jay3&#x27;</span>,<span class="string">&#x27;37&#x27;</span>,<span class="string">&#x27;4500&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">create</span> index idx_emp_age_salary <span class="keyword">on</span> emp(age,salary);</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li>优化group by</li>
</ol>
<p>于GROUP BY 实际上也同样会进行排序操作，而且与ORDER BY 相比，GROUP BY 主要只是多了排序之后的分组操作。当然，如果在分组的时候还使用了其他的一些聚合函数，那么还需要一些聚合函数的计算。所以，在GROUP BY 的实现过程中，与 ORDER BY 一样也可以利用到索引。</p>
<p>如果查询包含 group by 但是用户想要避免排序结果的消耗， 则可以执行order by null 禁止排序。如下 ：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> index idx_emp_age_salary <span class="keyword">on</span> emp; </span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> age,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> age;</span><br><span class="line"></span><br><span class="line">explain <span class="keyword">select</span> age,<span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">from</span> emp <span class="keyword">group</span> <span class="keyword">by</span> age <span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">create</span> index idx_emp_age_salary <span class="keyword">on</span> emp(age,salary)；</span><br></pre></td></tr></table></figure>
<ol>
<li>优化子查询</li>
</ol>
<p>使用子查询可以一次性的完成很多逻辑上需要多个步骤才能完成的SQL操作，同时也可以避免事务或者表锁死，并且写起来也很容易。但是，有些情况下，子查询是可以被更高效的连接（JOIN）替代。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> uid <span class="keyword">in</span> (<span class="keyword">select</span> uid <span class="keyword">from</span> user_role ); </span><br></pre></td></tr></table></figure>
<p><img src="../../../images/image-20230613162155049.png" alt="image-20230613162155049"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">explain <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">user</span> u , user_role ur <span class="keyword">where</span> u.uid <span class="operator">=</span> ur.uid;</span><br></pre></td></tr></table></figure>
<p><img src="../../../images/image-20230613162415258.png" alt="image-20230613162415258"></p>
<p>system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL</p>
<p>连接(Join)查询之所以更有效率一些 ，是因为MySQL不需要在内存中创建临时表来完成这个逻辑上需要两个步骤的查询工作。</p>
<ol>
<li>优化limit查询</li>
</ol>
<p>一般分页查询时，通过创建覆盖索引能够比较好地提高性能。一个常见又非常头疼的问题就是 limit 900000,10 ，此时需要MySQL排序前900010 记录，仅仅返回900000 - 900010 的记录，其他记录丢弃，查询排序的代价非常大 。</p>
<p>优化</p>
<ul>
<li>在索引上完成排序分页操作，最后根据主键关联回原表查询所需要的其他列内容。</li>
<li>该方案适用于主键自增的表，可以把Limit 查询转换成某个位置的查询 。</li>
</ul>
<h1 id="pymysql使用"><a href="#pymysql使用" class="headerlink" title="pymysql使用"></a>pymysql使用</h1><p>PyMySQL 是一个纯 Python 实现的 MySQL 客户端库，支持兼容 Python 3，用于代替 MySQLdb。。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"> </span><br><span class="line">conn = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">3306</span>, user=<span class="string">&#x27;root&#x27;</span>,password=<span class="string">&#x27;123456&#x27;</span>,database=<span class="string">&#x27;mydb17_pymysql&#x27;</span>, charset=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取游标</span></span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 执行ＳＱＬ语句 返回值就是ＳＱＬ语句在执行过程中影响的行数</span></span><br><span class="line">sql = <span class="string">&quot;select * from student;&quot;</span></span><br><span class="line"> </span><br><span class="line">row_count = cursor.execute(sql)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ＳＱＬ语句执行影响的行数%d&quot;</span> % row_count)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 取出结果集中一行  返回的结果是一行</span></span><br><span class="line"><span class="comment"># print(cursor.fetchone())</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 取出结果集中的所有数据　　返回一行数据</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> cursor.fetchall():</span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line"><span class="comment"># 关闭游标</span></span><br><span class="line">cursor.close()</span><br><span class="line"><span class="comment"># 关闭连接</span></span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"> </span><br><span class="line"><span class="comment">#获取MySQL连接</span></span><br><span class="line">conn = pymysql.connect(host=<span class="string">&#x27;localhost&#x27;</span>, port=<span class="number">3306</span>, user=<span class="string">&#x27;root&#x27;</span>,password=<span class="string">&#x27;123456&#x27;</span>,database=<span class="string">&#x27;mydb17_pymysql&#x27;</span>, charset=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"><span class="comment"># 获取游标</span></span><br><span class="line">cursor = conn.cursor()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 执行ＳＱＬ语句 返回值就是ＳＱＬ语句在执行过程中影响的行数</span></span><br><span class="line">sql = <span class="string">&quot;select * from student;&quot;</span></span><br><span class="line"> </span><br><span class="line">row_count = cursor.execute(sql)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;ＳＱＬ语句执行影响的行数%d&quot;</span> % row_count)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 取出结果集中一行  返回的结果是一行</span></span><br><span class="line"><span class="comment"># print(cursor.fetchone())</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 取出结果集中的所有数据　　返回一行数据</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> cursor.fetchall():</span><br><span class="line">    <span class="built_in">print</span>(line)</span><br><span class="line"><span class="comment"># 关闭游标</span></span><br><span class="line">cursor.close()</span><br><span class="line"><span class="comment"># 关闭连接</span></span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">import pymysql</span><br><span class="line"> </span><br><span class="line">#获取MySQL连接</span><br><span class="line">conn <span class="operator">=</span> pymysql.connect(host<span class="operator">=</span><span class="string">&#x27;localhost&#x27;</span>, port<span class="operator">=</span><span class="number">3306</span>, <span class="keyword">user</span><span class="operator">=</span><span class="string">&#x27;root&#x27;</span>,password<span class="operator">=</span><span class="string">&#x27;123456&#x27;</span>,database<span class="operator">=</span><span class="string">&#x27;mydb17_pymysql&#x27;</span>, charset<span class="operator">=</span><span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"># 获取游标</span><br><span class="line"><span class="keyword">cursor</span> <span class="operator">=</span> conn.cursor()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">#插入数据</span><br><span class="line"># <span class="keyword">sql</span> <span class="operator">=</span> &quot;insert into student values(%s,%s,%s)&quot;</span><br><span class="line"># data <span class="operator">=</span> (<span class="number">4</span>, <span class="string">&#x27;晁盖&#x27;</span>, <span class="number">34</span>)</span><br><span class="line"># cursor.execute(<span class="keyword">sql</span>, data)  #<span class="keyword">sql</span>和data之间以&quot;,&quot;隔开</span><br><span class="line"> </span><br><span class="line"># 修改数据</span><br><span class="line"># <span class="keyword">sql</span> <span class="operator">=</span> &quot;update student set sname=%s where sid=%s&quot;</span><br><span class="line"># data <span class="operator">=</span> (<span class="string">&#x27;李逵&#x27;</span>, <span class="number">4</span>)</span><br><span class="line"># cursor.execute(<span class="keyword">sql</span>, data)</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"># 删除数据</span><br><span class="line"><span class="keyword">sql</span> <span class="operator">=</span> &quot;delete from student where sid=%s&quot;</span><br><span class="line">data <span class="operator">=</span> (<span class="number">4</span>)</span><br><span class="line">cursor.execute(<span class="keyword">sql</span>, data)</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">conn.commit()   # 提交，不然无法保存插入或者修改的数据(这个一定不要忘记加上)</span><br><span class="line"># 关闭游标</span><br><span class="line">cursor.close()</span><br><span class="line"># 关闭连接</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty(一) Nio基础</title>
    <url>/posts/45924.html</url>
    <content><![CDATA[<h1 id="一-NIO-基础"><a href="#一-NIO-基础" class="headerlink" title="一. NIO 基础"></a>一. NIO 基础</h1><p>non-blocking io 非阻塞 IO</p>
<h2 id="1-三大组件"><a href="#1-三大组件" class="headerlink" title="1. 三大组件"></a>1. 三大组件</h2><h3 id="1-1-Channel-amp-Buffer"><a href="#1-1-Channel-amp-Buffer" class="headerlink" title="1.1 Channel &amp; Buffer"></a>1.1 Channel &amp; Buffer</h3><p>channel 有一点类似于 stream，它就是读写数据的<strong>双向通道</strong>，可以从 channel 将数据读入 buffer，也可以将 buffer 的数据写入 channel，而之前的 stream 要么是输入，要么是输出，channel 比 stream 更为底层</p>
<pre class="mermaid">graph LR
channel --> buffer
buffer --> channel</pre>

<p>常见的 Channel 有</p>
<ul>
<li><p>FileChannel</p>
</li>
<li><p>DatagramChannel</p>
</li>
<li><p>SocketChannel</p>
</li>
<li><p>ServerSocketChannel</p>
</li>
</ul>
<p>buffer 则用来缓冲读写数据，常见的 buffer 有</p>
<ul>
<li>ByteBuffer<ul>
<li>MappedByteBuffer</li>
<li>DirectByteBuffer</li>
<li>HeapByteBuffer</li>
</ul>
</li>
<li>ShortBuffer</li>
<li>IntBuffer</li>
<li>LongBuffer</li>
<li>FloatBuffer</li>
<li>DoubleBuffer</li>
<li>CharBuffer</li>
</ul>
<h3 id="1-2-Selector"><a href="#1-2-Selector" class="headerlink" title="1.2 Selector"></a>1.2 Selector</h3><p>selector 单从字面意思不好理解，需要结合服务器的设计演化来理解它的用途</p>
<h4 id="多线程版设计"><a href="#多线程版设计" class="headerlink" title="多线程版设计"></a>多线程版设计</h4><pre class="mermaid">graph TD
subgraph 多线程版
t1(thread) --> s1(socket1)
t2(thread) --> s2(socket2)
t3(thread) --> s3(socket3)
end</pre>
#### ⚠️ 多线程版缺点

* 内存占用高
* 线程上下文切换成本高
* 只适合连接数少的场景

#### 线程池版设计

<pre class="mermaid">graph TD
subgraph 线程池版
t4(thread) --> s4(socket1)
t5(thread) --> s5(socket2)
t4(thread) -.-> s6(socket3)
t5(thread) -.-> s7(socket4)
end</pre>
#### ⚠️ 线程池版缺点

* 阻塞模式下，线程仅能处理一个 socket 连接
* 仅适合短连接场景

#### selector 版设计

selector 的作用就是配合一个线程来管理多个 channel，获取这些 channel 上发生的事件，这些 channel 工作在非阻塞模式下，不会让线程吊死在一个 channel 上。适合连接数特别多，但流量低的场景（low traffic）

<pre class="mermaid">graph TD
subgraph selector 版
thread --> selector
selector --> c1(channel)
selector --> c2(channel)
selector --> c3(channel)
end</pre>



<p>调用 selector 的 select() 会阻塞直到 channel 发生了读写就绪事件，这些事件发生，select 方法就会返回这些事件交给 thread 来处理</p>
<h2 id="2-ByteBuffer"><a href="#2-ByteBuffer" class="headerlink" title="2. ByteBuffer"></a>2. ByteBuffer</h2><p>有一普通文本文件 data.txt，内容为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1234567890abcd</span><br></pre></td></tr></table></figure>
<p>使用 FileChannel 来读取文件内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;helloword/data.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> file.getChannel();</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">// 向 buffer 写入</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> channel.read(buffer);</span><br><span class="line">                log.debug(<span class="string">&quot;读到字节数：&#123;&#125;&quot;</span>, len);</span><br><span class="line">                <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 切换 buffer 读模式</span></span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="keyword">while</span>(buffer.hasRemaining()) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, (<span class="type">char</span>)buffer.get());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 切换 buffer 写模式</span></span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：10</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 1</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 2</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 3</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 4</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 5</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 6</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 7</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 8</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 9</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 0</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：4</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - a</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - b</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - c</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - d</span><br><span class="line">10:39:03 [DEBUG] [main] c.i.n.ChannelDemo1 - 读到字节数：-1</span><br></pre></td></tr></table></figure>
<h3 id="2-1-ByteBuffer-正确使用姿势"><a href="#2-1-ByteBuffer-正确使用姿势" class="headerlink" title="2.1  ByteBuffer 正确使用姿势"></a>2.1  ByteBuffer 正确使用姿势</h3><ol>
<li>向 buffer 写入数据，例如调用 channel.read(buffer)</li>
<li>调用 flip() 切换至<strong>读模式</strong></li>
<li>从 buffer 读取数据，例如调用 buffer.get()</li>
<li>调用 clear() 或 compact() 切换至<strong>写模式</strong></li>
<li>重复 1~4 步骤</li>
</ol>
<h3 id="2-2-ByteBuffer-结构"><a href="#2-2-ByteBuffer-结构" class="headerlink" title="2.2 ByteBuffer 结构"></a>2.2 ByteBuffer 结构</h3><p>ByteBuffer 有以下重要属性</p>
<ul>
<li>capacity</li>
<li>position</li>
<li>limit</li>
</ul>
<p>一开始</p>
<p><img src="../../../images/000021.png" alt=""></p>
<p>写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态</p>
<p><img src="../../../images/0018.png" alt=""></p>
<p>flip 动作发生后，position 切换为读取位置，limit 切换为读取限制</p>
<p><img src="../../../images/0019.png" alt=""></p>
<p>读取 4 个字节后，状态</p>
<p><img src="../../../images/0020.png" alt=""></p>
<p>clear 动作发生后，状态</p>
<p><img src="../../../images/000021.png" alt=""></p>
<p>compact 方法，是把未读完的部分向前压缩，然后切换至写模式</p>
<p><img src="../../../images/0022.png" alt=""></p>
<h4 id="💡-调试工具类"><a href="#💡-调试工具类" class="headerlink" title="💡 调试工具类"></a>💡 调试工具类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ByteBufferUtil</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span>[] BYTE2CHAR = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">char</span>[] HEXDUMP_TABLE = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">256</span> * <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] HEXPADDING = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">16</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] HEXDUMP_ROWPREFIXES = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">65536</span> &gt;&gt;&gt; <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] BYTE2HEX = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] BYTEPADDING = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">char</span>[] DIGITS = <span class="string">&quot;0123456789abcdef&quot;</span>.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">            HEXDUMP_TABLE[i &lt;&lt; <span class="number">1</span>] = DIGITS[i &gt;&gt;&gt; <span class="number">4</span> &amp; <span class="number">0x0F</span>];</span><br><span class="line">            HEXDUMP_TABLE[(i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>] = DIGITS[i &amp; <span class="number">0x0F</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for hex dump paddings</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HEXPADDING.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">padding</span> <span class="operator">=</span> HEXPADDING.length - i;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(padding * <span class="number">3</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; padding; j++) &#123;</span><br><span class="line">                buf.append(<span class="string">&quot;   &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            HEXPADDING[i] = buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for the start-offset header in each row (up to 64KiB).</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; HEXDUMP_ROWPREFIXES.length; i++) &#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">12</span>);</span><br><span class="line">            buf.append(NEWLINE);</span><br><span class="line">            buf.append(Long.toHexString(i &lt;&lt; <span class="number">4</span> &amp; <span class="number">0xFFFFFFFFL</span> | <span class="number">0x100000000L</span>));</span><br><span class="line">            buf.setCharAt(buf.length() - <span class="number">9</span>, <span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">            buf.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">            HEXDUMP_ROWPREFIXES[i] = buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for byte-to-hex-dump conversion</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTE2HEX.length; i++) &#123;</span><br><span class="line">            BYTE2HEX[i] = <span class="string">&#x27; &#x27;</span> + StringUtil.byteToHexStringPadded(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for byte dump paddings</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTEPADDING.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">padding</span> <span class="operator">=</span> BYTEPADDING.length - i;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(padding);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; padding; j++) &#123;</span><br><span class="line">                buf.append(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            BYTEPADDING[i] = buf.toString();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Generate the lookup table for byte-to-char conversion</span></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BYTE2CHAR.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt;= <span class="number">0x1f</span> || i &gt;= <span class="number">0x7f</span>) &#123;</span><br><span class="line">                BYTE2CHAR[i] = <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                BYTE2CHAR[i] = (<span class="type">char</span>) i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印所有内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">debugAll</span><span class="params">(ByteBuffer buffer)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">oldlimit</span> <span class="operator">=</span> buffer.limit();</span><br><span class="line">        buffer.limit(buffer.capacity());</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">origin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">256</span>);</span><br><span class="line">        appendPrettyHexDump(origin, buffer, <span class="number">0</span>, buffer.capacity());</span><br><span class="line">        System.out.println(<span class="string">&quot;+--------+-------------------- all ------------------------+----------------+&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;position: [%d], limit: [%d]\n&quot;</span>, buffer.position(), oldlimit);</span><br><span class="line">        System.out.println(origin);</span><br><span class="line">        buffer.limit(oldlimit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印可读取内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> buffer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">debugRead</span><span class="params">(ByteBuffer buffer)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="number">256</span>);</span><br><span class="line">        appendPrettyHexDump(builder, buffer, buffer.position(), buffer.limit() - buffer.position());</span><br><span class="line">        System.out.println(<span class="string">&quot;+--------+-------------------- read -----------------------+----------------+&quot;</span>);</span><br><span class="line">        System.out.printf(<span class="string">&quot;position: [%d], limit: [%d]\n&quot;</span>, buffer.position(), buffer.limit());</span><br><span class="line">        System.out.println(builder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">appendPrettyHexDump</span><span class="params">(StringBuilder dump, ByteBuffer buf, <span class="type">int</span> offset, <span class="type">int</span> length)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isOutOfBounds(offset, length, buf.capacity())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IndexOutOfBoundsException</span>(</span><br><span class="line">                    <span class="string">&quot;expected: &quot;</span> + <span class="string">&quot;0 &lt;= offset(&quot;</span> + offset + <span class="string">&quot;) &lt;= offset + length(&quot;</span> + length</span><br><span class="line">                            + <span class="string">&quot;) &lt;= &quot;</span> + <span class="string">&quot;buf.capacity(&quot;</span> + buf.capacity() + <span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dump.append(</span><br><span class="line">                <span class="string">&quot;         +-------------------------------------------------+&quot;</span> +</span><br><span class="line">                        NEWLINE + <span class="string">&quot;         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |&quot;</span> +</span><br><span class="line">                        NEWLINE + <span class="string">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">startIndex</span> <span class="operator">=</span> offset;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">fullRows</span> <span class="operator">=</span> length &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">remainder</span> <span class="operator">=</span> length &amp; <span class="number">0xF</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dump the rows which have 16 bytes.</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> <span class="number">0</span>; row &lt; fullRows; row++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rowStartIndex</span> <span class="operator">=</span> (row &lt;&lt; <span class="number">4</span>) + startIndex;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Per-row prefix.</span></span><br><span class="line">            appendHexDumpRowPrefix(dump, row, rowStartIndex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Hex dump</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rowEndIndex</span> <span class="operator">=</span> rowStartIndex + <span class="number">16</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(<span class="string">&quot; |&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// ASCII dump</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Dump the last row which has less than 16 bytes.</span></span><br><span class="line">        <span class="keyword">if</span> (remainder != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rowStartIndex</span> <span class="operator">=</span> (fullRows &lt;&lt; <span class="number">4</span>) + startIndex;</span><br><span class="line">            appendHexDumpRowPrefix(dump, fullRows, rowStartIndex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Hex dump</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">rowEndIndex</span> <span class="operator">=</span> rowStartIndex + remainder;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2HEX[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(HEXPADDING[remainder]);</span><br><span class="line">            dump.append(<span class="string">&quot; |&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Ascii dump</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> rowStartIndex; j &lt; rowEndIndex; j++) &#123;</span><br><span class="line">                dump.append(BYTE2CHAR[getUnsignedByte(buf, j)]);</span><br><span class="line">            &#125;</span><br><span class="line">            dump.append(BYTEPADDING[remainder]);</span><br><span class="line">            dump.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dump.append(NEWLINE +</span><br><span class="line">                <span class="string">&quot;+--------+-------------------------------------------------+----------------+&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">appendHexDumpRowPrefix</span><span class="params">(StringBuilder dump, <span class="type">int</span> row, <span class="type">int</span> rowStartIndex)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (row &lt; HEXDUMP_ROWPREFIXES.length) &#123;</span><br><span class="line">            dump.append(HEXDUMP_ROWPREFIXES[row]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dump.append(NEWLINE);</span><br><span class="line">            dump.append(Long.toHexString(rowStartIndex &amp; <span class="number">0xFFFFFFFFL</span> | <span class="number">0x100000000L</span>));</span><br><span class="line">            dump.setCharAt(dump.length() - <span class="number">9</span>, <span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">            dump.append(<span class="string">&#x27;|&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">short</span> <span class="title function_">getUnsignedByte</span><span class="params">(ByteBuffer buffer, <span class="type">int</span> index)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">short</span>) (buffer.get(index) &amp; <span class="number">0xFF</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-ByteBuffer-常见方法"><a href="#2-3-ByteBuffer-常见方法" class="headerlink" title="2.3 ByteBuffer 常见方法"></a>2.3 ByteBuffer 常见方法</h3><h4 id="分配空间"><a href="#分配空间" class="headerlink" title="分配空间"></a>分配空间</h4><p>可以使用 allocate 方法为 ByteBuffer 分配空间，其它 buffer 类也有该方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Bytebuffer</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br></pre></td></tr></table></figure>
<h4 id="向-buffer-写入数据"><a href="#向-buffer-写入数据" class="headerlink" title="向 buffer 写入数据"></a>向 buffer 写入数据</h4><p>有两种办法</p>
<ul>
<li>调用 channel 的 read 方法</li>
<li>调用 buffer 自己的 put 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> channel.read(buf);</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buf.put((<span class="type">byte</span>)<span class="number">127</span>);</span><br></pre></td></tr></table></figure>
<h4 id="从-buffer-读取数据"><a href="#从-buffer-读取数据" class="headerlink" title="从 buffer 读取数据"></a>从 buffer 读取数据</h4><p>同样有两种办法</p>
<ul>
<li>调用 channel 的 write 方法</li>
<li>调用 buffer 自己的 get 方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">writeBytes</span> <span class="operator">=</span> channel.write(buf);</span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> buf.get();</span><br></pre></td></tr></table></figure>
<p>get 方法会让 position 读指针向后走，如果想重复读取数据</p>
<ul>
<li>可以调用 rewind 方法将 position 重新置为 0</li>
<li>或者调用 get(int i) 方法获取索引 i 的内容，它不会移动读指针</li>
</ul>
<h4 id="mark-和-reset"><a href="#mark-和-reset" class="headerlink" title="mark 和 reset"></a>mark 和 reset</h4><p>mark 是在读取时，做一个标记，即使 position 改变，只要调用 reset 就能回到 mark 的位置</p>
<blockquote>
<p><strong>注意</strong></p>
<p>rewind 和 flip 都会清除 mark 位置</p>
</blockquote>
<h4 id="字符串与-ByteBuffer-互转"><a href="#字符串与-ByteBuffer-互转" class="headerlink" title="字符串与 ByteBuffer 互转"></a>字符串与 ByteBuffer 互转</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer1</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer2</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;utf-8&quot;</span>).encode(<span class="string">&quot;你好&quot;</span>);</span><br><span class="line"></span><br><span class="line">debug(buffer1);</span><br><span class="line">debug(buffer2);</span><br><span class="line"></span><br><span class="line"><span class="type">CharBuffer</span> <span class="variable">buffer3</span> <span class="operator">=</span> StandardCharsets.UTF_8.decode(buffer1);</span><br><span class="line">System.out.println(buffer3.getClass());</span><br><span class="line">System.out.println(buffer3.toString());</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| e4 bd a0 e5 a5 bd                               |......          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| e4 bd a0 e5 a5 bd                               |......          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">class java.nio.HeapCharBuffer</span><br><span class="line">你好</span><br></pre></td></tr></table></figure>
<h4 id="⚠️-Buffer-的线程安全"><a href="#⚠️-Buffer-的线程安全" class="headerlink" title="⚠️ Buffer 的线程安全"></a>⚠️ Buffer 的线程安全</h4><blockquote>
<p>Buffer 是<strong>非线程安全的</strong></p>
</blockquote>
<h3 id="2-4-Scattering-Reads"><a href="#2-4-Scattering-Reads" class="headerlink" title="2.4 Scattering Reads"></a>2.4 Scattering Reads</h3><p>分散读取，有一个文本文件 3parts.txt</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">onetwothree</span><br></pre></td></tr></table></figure>
<p>使用如下方式读取，可以将数据填充至多个 buffer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;helloword/3parts.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> file.getChannel();</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">a</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">b</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">c</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">    channel.read(<span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[]&#123;a, b, c&#125;);</span><br><span class="line">    a.flip();</span><br><span class="line">    b.flip();</span><br><span class="line">    c.flip();</span><br><span class="line">    debug(a);</span><br><span class="line">    debug(b);</span><br><span class="line">    debug(c);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6f 6e 65                                        |one             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 74 77 6f                                        |two             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 74 68 72 65 65                                  |three           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<h3 id="2-5-Gathering-Writes"><a href="#2-5-Gathering-Writes" class="headerlink" title="2.5 Gathering Writes"></a>2.5 Gathering Writes</h3><p>使用如下方式写入，可以将多个 buffer 的数据填充至 channel</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;helloword/3parts.txt&quot;</span>, <span class="string">&quot;rw&quot;</span>)) &#123;</span><br><span class="line">    <span class="type">FileChannel</span> <span class="variable">channel</span> <span class="operator">=</span> file.getChannel();</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">d</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">e</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">4</span>);</span><br><span class="line">    channel.position(<span class="number">11</span>);</span><br><span class="line"></span><br><span class="line">    d.put(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;r&#x27;</span>&#125;);</span><br><span class="line">    e.put(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="string">&#x27;f&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;v&#x27;</span>, <span class="string">&#x27;e&#x27;</span>&#125;);</span><br><span class="line">    d.flip();</span><br><span class="line">    e.flip();</span><br><span class="line">    debug(d);</span><br><span class="line">    debug(e);</span><br><span class="line">    channel.write(<span class="keyword">new</span> <span class="title class_">ByteBuffer</span>[]&#123;d, e&#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 66 6f 75 72                                     |four            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 66 69 76 65                                     |five            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<p>文件内容</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">onetwothreefourfive</span><br></pre></td></tr></table></figure>
<h3 id="2-6-练习"><a href="#2-6-练习" class="headerlink" title="2.6 练习"></a>2.6 练习</h3><p>网络上有多条数据发送给服务端，数据之间使用 \n 进行分隔<br>但由于某种原因这些数据在接收时，被进行了重新组合，例如原始数据有3条为</p>
<ul>
<li>Hello,world\n</li>
<li>I’m zhangsan\n</li>
<li>How are you?\n</li>
</ul>
<p>变成了下面的两个 byteBuffer (黏包，半包)</p>
<ul>
<li>Hello,world\nI’m zhangsan\nHo</li>
<li>w are you?\n</li>
</ul>
<p>现在要求你编写程序，将错乱的数据恢复成原始的按 \n 分隔的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ByteBuffer</span> <span class="variable">source</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line">    <span class="comment">//                     11            24</span></span><br><span class="line">    source.put(<span class="string">&quot;Hello,world\nI&#x27;m zhangsan\nHo&quot;</span>.getBytes());</span><br><span class="line">    split(source);</span><br><span class="line"></span><br><span class="line">    source.put(<span class="string">&quot;w are you?\nhaha!\n&quot;</span>.getBytes());</span><br><span class="line">    split(source);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(ByteBuffer source)</span> &#123;</span><br><span class="line">    source.flip();</span><br><span class="line">    <span class="type">int</span> <span class="variable">oldLimit</span> <span class="operator">=</span> source.limit();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; oldLimit; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (source.get(i) == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            System.out.println(i);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">target</span> <span class="operator">=</span> ByteBuffer.allocate(i + <span class="number">1</span> - source.position());</span><br><span class="line">            <span class="comment">// 0 ~ limit</span></span><br><span class="line">            source.limit(i + <span class="number">1</span>);</span><br><span class="line">            target.put(source); <span class="comment">// 从source 读，向 target 写</span></span><br><span class="line">            debugAll(target);</span><br><span class="line">            source.limit(oldLimit);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    source.compact();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-文件编程"><a href="#3-文件编程" class="headerlink" title="3. 文件编程"></a>3. 文件编程</h2><h3 id="3-1-FileChannel"><a href="#3-1-FileChannel" class="headerlink" title="3.1 FileChannel"></a>3.1 FileChannel</h3><h4 id="⚠️-FileChannel-工作模式"><a href="#⚠️-FileChannel-工作模式" class="headerlink" title="⚠️ FileChannel 工作模式"></a>⚠️ FileChannel 工作模式</h4><blockquote>
<p>FileChannel 只能工作在阻塞模式下</p>
</blockquote>
<h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4><p>不能直接打开 FileChannel，必须通过 FileInputStream、FileOutputStream 或者 RandomAccessFile 来获取 FileChannel，它们都有 getChannel 方法</p>
<ul>
<li>通过 FileInputStream 获取的 channel 只能读</li>
<li>通过 FileOutputStream 获取的 channel 只能写</li>
<li>通过 RandomAccessFile 是否能读写根据构造 RandomAccessFile 时的读写模式决定</li>
</ul>
<h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><p>会从 channel 读取数据填充 ByteBuffer，返回值表示读到了多少字节，-1 表示到达了文件的末尾</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">readBytes</span> <span class="operator">=</span> channel.read(buffer);</span><br></pre></td></tr></table></figure>
<h4 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h4><p>写入的正确姿势如下， SocketChannel</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ...;</span><br><span class="line">buffer.put(...); <span class="comment">// 存入数据</span></span><br><span class="line">buffer.flip();   <span class="comment">// 切换读模式</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(buffer.hasRemaining()) &#123;</span><br><span class="line">    channel.write(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 while 中调用 channel.write 是因为 write 方法并不能保证一次将 buffer 中的内容全部写入 channel</p>
<h4 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h4><p>channel 必须关闭，不过调用了 FileInputStream、FileOutputStream 或者 RandomAccessFile 的 close 方法会间接地调用 channel 的 close 方法</p>
<h4 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h4><p>获取当前位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">pos</span> <span class="operator">=</span> channel.position();</span><br></pre></td></tr></table></figure>
<p>设置当前位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">newPos</span> <span class="operator">=</span> ...;</span><br><span class="line">channel.position(newPos);</span><br></pre></td></tr></table></figure>
<p>设置当前位置时，如果设置为文件的末尾</p>
<ul>
<li>这时读取会返回 -1 </li>
<li>这时写入，会追加内容，但要注意如果 position 超过了文件末尾，再写入时在新内容和原末尾之间会有空洞（00）</li>
</ul>
<h4 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h4><p>使用 size 方法获取文件的大小</p>
<h4 id="强制写入"><a href="#强制写入" class="headerlink" title="强制写入"></a>强制写入</h4><p>操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘。可以调用 force(true)  方法将文件内容和元数据（文件的权限等信息）立刻写入磁盘</p>
<h3 id="3-2-两个-Channel-传输数据"><a href="#3-2-两个-Channel-传输数据" class="headerlink" title="3.2 两个 Channel 传输数据"></a>3.2 两个 Channel 传输数据</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">FROM</span> <span class="operator">=</span> <span class="string">&quot;helloword/data.txt&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">TO</span> <span class="operator">=</span> <span class="string">&quot;helloword/to.txt&quot;</span>;</span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"><span class="keyword">try</span> (<span class="type">FileChannel</span> <span class="variable">from</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(FROM).getChannel();</span><br><span class="line">     <span class="type">FileChannel</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(TO).getChannel();</span><br><span class="line">    ) &#123;</span><br><span class="line">    from.transferTo(<span class="number">0</span>, from.size(), to);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">System.out.println(<span class="string">&quot;transferTo 用时：&quot;</span> + (end - start) / <span class="number">1000_000.0</span>);</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">transferTo 用时：8.2011</span><br></pre></td></tr></table></figure>
<p>超过 2g 大小的文件传输</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestFileChannelTransferTo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">FileChannel</span> <span class="variable">from</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>).getChannel();</span><br><span class="line">                <span class="type">FileChannel</span> <span class="variable">to</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;to.txt&quot;</span>).getChannel();</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="comment">// 效率高，底层会利用操作系统的零拷贝进行优化</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> from.size();</span><br><span class="line">            <span class="comment">// left 变量代表还剩余多少字节</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">left</span> <span class="operator">=</span> size; left &gt; <span class="number">0</span>; ) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;position:&quot;</span> + (size - left) + <span class="string">&quot; left:&quot;</span> + left);</span><br><span class="line">                left -= from.transferTo((size - left), left, to);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际传输一个超大文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">position:0 left:7769948160</span><br><span class="line">position:2147483647 left:5622464513</span><br><span class="line">position:4294967294 left:3474980866</span><br><span class="line">position:6442450941 left:1327497219</span><br></pre></td></tr></table></figure>
<h3 id="3-3-Path"><a href="#3-3-Path" class="headerlink" title="3.3 Path"></a>3.3 Path</h3><p>jdk7 引入了 Path 和 Paths 类</p>
<ul>
<li>Path 用来表示文件路径</li>
<li>Paths 是工具类，用来获取 Path 实例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;1.txt&quot;</span>); <span class="comment">// 相对路径 使用 user.dir 环境变量来定位 1.txt</span></span><br><span class="line"></span><br><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\1.txt&quot;</span>); <span class="comment">// 绝对路径 代表了  d:\1.txt</span></span><br><span class="line"></span><br><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:/1.txt&quot;</span>); <span class="comment">// 绝对路径 同样代表了  d:\1.txt</span></span><br><span class="line"></span><br><span class="line"><span class="type">Path</span> <span class="variable">projects</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\data&quot;</span>, <span class="string">&quot;projects&quot;</span>); <span class="comment">// 代表了  d:\data\projects</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>.</code> 代表了当前路径</li>
<li><code>..</code> 代表了上一级路径</li>
</ul>
<p>例如目录结构如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d:</span><br><span class="line">	|- data</span><br><span class="line">		|- projects</span><br><span class="line">			|- a</span><br><span class="line">			|- b</span><br></pre></td></tr></table></figure>
<p>代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\data\\projects\\a\\..\\b&quot;</span>);</span><br><span class="line">System.out.println(path);</span><br><span class="line">System.out.println(path.normalize()); <span class="comment">// 正常化路径</span></span><br></pre></td></tr></table></figure>
<p>会输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">d:\data\projects\a\..\b</span><br><span class="line">d:\data\projects\b</span><br></pre></td></tr></table></figure>
<h3 id="3-4-Files"><a href="#3-4-Files" class="headerlink" title="3.4 Files"></a>3.4 Files</h3><p>检查文件是否存在</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line">System.out.println(Files.exists(path));</span><br></pre></td></tr></table></figure>
<p>创建一级目录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;helloword/d1&quot;</span>);</span><br><span class="line">Files.createDirectory(path);</span><br></pre></td></tr></table></figure>
<ul>
<li>如果目录已存在，会抛异常 FileAlreadyExistsException</li>
<li>不能一次创建多级目录，否则会抛异常 NoSuchFileException</li>
</ul>
<p>创建多级目录用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;helloword/d1/d2&quot;</span>);</span><br><span class="line">Files.createDirectories(path);</span><br></pre></td></tr></table></figure>
<p>拷贝文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;helloword/target.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">Files.copy(source, target);</span><br></pre></td></tr></table></figure>
<ul>
<li>如果文件已存在，会抛异常 FileAlreadyExistsException</li>
</ul>
<p>如果希望用 source 覆盖掉 target，需要用 StandardCopyOption 来控制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Files.copy(source, target, StandardCopyOption.REPLACE_EXISTING);</span><br></pre></td></tr></table></figure>
<p>移动文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">source</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">Files.move(source, target, StandardCopyOption.ATOMIC_MOVE);</span><br></pre></td></tr></table></figure>
<ul>
<li>StandardCopyOption.ATOMIC_MOVE 保证文件移动的原子性</li>
</ul>
<p>删除文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;helloword/target.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">Files.delete(target);</span><br></pre></td></tr></table></figure>
<ul>
<li>如果文件不存在，会抛异常 NoSuchFileException</li>
</ul>
<p>删除目录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">target</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;helloword/d1&quot;</span>);</span><br><span class="line"></span><br><span class="line">Files.delete(target);</span><br></pre></td></tr></table></figure>
<ul>
<li>如果目录还有内容，会抛异常 DirectoryNotEmptyException</li>
</ul>
<p>遍历目录文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;C:\\Program Files\\Java\\jdk1.8.0_91&quot;</span>);</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">dirCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    <span class="type">AtomicInteger</span> <span class="variable">fileCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    Files.walkFileTree(path, <span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> </span><br><span class="line">            <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(dir);</span><br><span class="line">            dirCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.preVisitDirectory(dir, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> </span><br><span class="line">            <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            System.out.println(file);</span><br><span class="line">            fileCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(dirCount); <span class="comment">// 133</span></span><br><span class="line">    System.out.println(fileCount); <span class="comment">// 1479</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>统计 jar 的数目</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;C:\\Program Files\\Java\\jdk1.8.0_91&quot;</span>);</span><br><span class="line"><span class="type">AtomicInteger</span> <span class="variable">fileCount</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">Files.walkFileTree(path, <span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> </span><br><span class="line">        <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">if</span> (file.toFile().getName().endsWith(<span class="string">&quot;.jar&quot;</span>)) &#123;</span><br><span class="line">            fileCount.incrementAndGet();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(fileCount); <span class="comment">// 724</span></span><br></pre></td></tr></table></figure>
<p>删除多级目录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Path</span> <span class="variable">path</span> <span class="operator">=</span> Paths.get(<span class="string">&quot;d:\\a&quot;</span>);</span><br><span class="line">Files.walkFileTree(path, <span class="keyword">new</span> <span class="title class_">SimpleFileVisitor</span>&lt;Path&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> FileVisitResult <span class="title function_">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> </span><br><span class="line">        <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Files.delete(file);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.visitFile(file, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> FileVisitResult <span class="title function_">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span> </span><br><span class="line">        <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        Files.delete(dir);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.postVisitDirectory(dir, exc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="⚠️-删除很危险"><a href="#⚠️-删除很危险" class="headerlink" title="⚠️ 删除很危险"></a>⚠️ 删除很危险</h4><blockquote>
<p>删除是危险操作，确保要递归删除的文件夹没有重要内容</p>
</blockquote>
<p>拷贝多级目录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="type">String</span> <span class="variable">source</span> <span class="operator">=</span> <span class="string">&quot;D:\\Snipaste-1.16.2-x64&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">target</span> <span class="operator">=</span> <span class="string">&quot;D:\\Snipaste-1.16.2-x64aaa&quot;</span>;</span><br><span class="line"></span><br><span class="line">Files.walk(Paths.get(source)).forEach(path -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">targetName</span> <span class="operator">=</span> path.toString().replace(source, target);</span><br><span class="line">        <span class="comment">// 是目录</span></span><br><span class="line">        <span class="keyword">if</span> (Files.isDirectory(path)) &#123;</span><br><span class="line">            Files.createDirectory(Paths.get(targetName));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 是普通文件</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Files.isRegularFile(path)) &#123;</span><br><span class="line">            Files.copy(path, Paths.get(targetName));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">System.out.println(end - start);</span><br></pre></td></tr></table></figure>
<h2 id="4-网络编程"><a href="#4-网络编程" class="headerlink" title="4. 网络编程"></a>4. 网络编程</h2><h3 id="4-1-非阻塞-vs-阻塞"><a href="#4-1-非阻塞-vs-阻塞" class="headerlink" title="4.1 非阻塞 vs 阻塞"></a>4.1 非阻塞 vs 阻塞</h3><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><ul>
<li>阻塞模式下，相关方法都会导致线程暂停<ul>
<li>ServerSocketChannel.accept 会在没有连接建立时让线程暂停</li>
<li>SocketChannel.read 会在没有数据可读时让线程暂停</li>
<li>阻塞的表现其实就是线程暂停了，暂停期间不会占用 cpu，但线程相当于闲置</li>
</ul>
</li>
<li>单线程下，阻塞方法之间相互影响，几乎不能正常工作，需要多线程支持</li>
<li>但多线程下，有新的问题，体现在以下方面<ul>
<li>32 位 jvm 一个线程 320k，64 位 jvm 一个线程 1024k，如果连接数过多，必然导致 OOM，并且线程太多，反而会因为频繁上下文切换导致性能降低</li>
<li>可以采用线程池技术来减少线程数和线程上下文切换，但治标不治本，如果有很多连接建立，但长时间 inactive，会阻塞线程池中所有线程，因此不适合长连接，只适合短连接</li>
</ul>
</li>
</ul>
<p>服务器端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 nio 来理解阻塞模式, 单线程</span></span><br><span class="line"><span class="comment">// 0. ByteBuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// 1. 创建了服务器</span></span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 绑定监听端口</span></span><br><span class="line">ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 连接集合</span></span><br><span class="line">List&lt;SocketChannel&gt; channels = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信</span></span><br><span class="line">    log.debug(<span class="string">&quot;connecting...&quot;</span>);</span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept(); <span class="comment">// 阻塞方法，线程停止运行</span></span><br><span class="line">    log.debug(<span class="string">&quot;connected... &#123;&#125;&quot;</span>, sc);</span><br><span class="line">    channels.add(sc);</span><br><span class="line">    <span class="keyword">for</span> (SocketChannel channel : channels) &#123;</span><br><span class="line">        <span class="comment">// 5. 接收客户端发送的数据</span></span><br><span class="line">        log.debug(<span class="string">&quot;before read... &#123;&#125;&quot;</span>, channel);</span><br><span class="line">        channel.read(buffer); <span class="comment">// 阻塞方法，线程停止运行</span></span><br><span class="line">        buffer.flip();</span><br><span class="line">        debugRead(buffer);</span><br><span class="line">        buffer.clear();</span><br><span class="line">        log.debug(<span class="string">&quot;after read...&#123;&#125;&quot;</span>, channel);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">sc.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;waiting...&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h4><ul>
<li>非阻塞模式下，相关方法都会不会让线程暂停<ul>
<li>在 ServerSocketChannel.accept 在没有连接建立时，会返回 null，继续运行</li>
<li>SocketChannel.read 在没有数据可读时，会返回 0，但线程不必阻塞，可以去执行其它 SocketChannel 的 read 或是去执行 ServerSocketChannel.accept </li>
<li>写数据时，线程只是等待数据写入 Channel 即可，无需等 Channel 通过网络把数据发送出去</li>
</ul>
</li>
<li>但非阻塞模式下，即使没有连接建立，和可读数据，线程仍然在不断运行，白白浪费了 cpu</li>
<li>数据复制过程中，线程实际还是阻塞的（AIO 改进的地方）</li>
</ul>
<p>服务器端，客户端代码不变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 nio 来理解非阻塞模式, 单线程</span></span><br><span class="line"><span class="comment">// 0. ByteBuffer</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line"><span class="comment">// 1. 创建了服务器</span></span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">ssc.configureBlocking(<span class="literal">false</span>); <span class="comment">// 非阻塞模式</span></span><br><span class="line"><span class="comment">// 2. 绑定监听端口</span></span><br><span class="line">ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"><span class="comment">// 3. 连接集合</span></span><br><span class="line">List&lt;SocketChannel&gt; channels = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 4. accept 建立与客户端连接， SocketChannel 用来与客户端之间通信</span></span><br><span class="line">    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept(); <span class="comment">// 非阻塞，线程还会继续运行，如果没有连接建立，但sc是null</span></span><br><span class="line">    <span class="keyword">if</span> (sc != <span class="literal">null</span>) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;connected... &#123;&#125;&quot;</span>, sc);</span><br><span class="line">        sc.configureBlocking(<span class="literal">false</span>); <span class="comment">// 非阻塞模式</span></span><br><span class="line">        channels.add(sc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (SocketChannel channel : channels) &#123;</span><br><span class="line">        <span class="comment">// 5. 接收客户端发送的数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer);<span class="comment">// 非阻塞，线程仍然会继续运行，如果没有读到数据，read 返回 0</span></span><br><span class="line">        <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            buffer.flip();</span><br><span class="line">            debugRead(buffer);</span><br><span class="line">            buffer.clear();</span><br><span class="line">            log.debug(<span class="string">&quot;after read...&#123;&#125;&quot;</span>, channel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h4><p>单线程可以配合 Selector 完成对多个 Channel 可读写事件的监控，这称之为多路复用</p>
<ul>
<li>多路复用仅针对网络 IO、普通文件 IO 没法利用多路复用</li>
<li>如果不用 Selector 的非阻塞模式，线程大部分时间都在做无用功，而 Selector 能够保证<ul>
<li>有可连接事件时才去连接</li>
<li>有可读事件才去读取</li>
<li>有可写事件才去写入<ul>
<li>限于网络传输能力，Channel 未必时时可写，一旦 Channel 可写，会触发 Selector 的可写事件</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-2-Selector"><a href="#4-2-Selector" class="headerlink" title="4.2 Selector"></a>4.2 Selector</h3><pre class="mermaid">graph TD
subgraph selector 版
thread --> selector
selector --> c1(channel)
selector --> c2(channel)
selector --> c3(channel)
end</pre>



<p>好处</p>
<ul>
<li>一个线程配合 selector 就可以监控多个 channel 的事件，事件发生线程才去处理。避免非阻塞模式下所做无用功</li>
<li>让这个线程能够被充分利用</li>
<li>节约了线程的数量</li>
<li>减少了线程上下文切换</li>
</ul>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br></pre></td></tr></table></figure>
<h4 id="绑定-Channel-事件"><a href="#绑定-Channel-事件" class="headerlink" title="绑定 Channel 事件"></a>绑定 Channel 事件</h4><p>也称之为注册事件，绑定的事件 selector 才会关心 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"><span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> channel.register(selector, 绑定事件);</span><br></pre></td></tr></table></figure>
<ul>
<li>channel 必须工作在非阻塞模式</li>
<li>FileChannel 没有非阻塞模式，因此不能配合 selector 一起使用</li>
<li>绑定的事件类型可以有<ul>
<li>connect - 客户端连接成功时触发</li>
<li>accept - 服务器端成功接受连接时触发</li>
<li>read - 数据可读入时触发，有因为接收能力弱，数据暂不能读入的情况</li>
<li>write - 数据可写出时触发，有因为发送能力弱，数据暂不能写出的情况</li>
</ul>
</li>
</ul>
<h4 id="监听-Channel-事件"><a href="#监听-Channel-事件" class="headerlink" title="监听 Channel 事件"></a>监听 Channel 事件</h4><p>可以通过下面三种方法来监听是否有事件发生，方法的返回值代表有多少 channel 发生了事件</p>
<p>方法1，阻塞直到绑定事件发生</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br></pre></td></tr></table></figure>
<p>方法2，阻塞直到绑定事件发生，或是超时（时间单位为 ms）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select(<span class="type">long</span> timeout);</span><br></pre></td></tr></table></figure>
<p>方法3，不会阻塞，也就是不管有没有事件，立刻返回，自己根据返回值检查是否有事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.selectNow();</span><br></pre></td></tr></table></figure>
<h4 id="💡-select-何时不阻塞"><a href="#💡-select-何时不阻塞" class="headerlink" title="💡 select 何时不阻塞"></a>💡 select 何时不阻塞</h4><blockquote>
<ul>
<li>事件发生时<ul>
<li>客户端发起连接请求，会触发 accept 事件</li>
<li>客户端发送数据过来，客户端正常、异常关闭时，都会触发 read 事件，另外如果发送的数据大于 buffer 缓冲区，会触发多次读取事件</li>
<li>channel 可写，会触发 write 事件</li>
<li>在 linux 下 nio bug 发生时</li>
</ul>
</li>
<li>调用 selector.wakeup()</li>
<li>调用 selector.close()</li>
<li>selector 所在线程 interrupt</li>
</ul>
</blockquote>
<h3 id="4-3-处理-accept-事件"><a href="#4-3-处理-accept-事件" class="headerlink" title="4.3 处理 accept 事件"></a>4.3 处理 accept 事件</h3><p>客户端代码为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>)) &#123;</span><br><span class="line">            System.out.println(socket);</span><br><span class="line">            socket.getOutputStream().write(<span class="string">&quot;world&quot;</span>.getBytes());</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器端代码为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelDemo6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> ServerSocketChannel.open()) &#123;</span><br><span class="line">            channel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">            System.out.println(channel);</span><br><span class="line">            <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">            channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            channel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br><span class="line"><span class="comment">//                int count = selector.selectNow();</span></span><br><span class="line">                log.debug(<span class="string">&quot;select count: &#123;&#125;&quot;</span>, count);</span><br><span class="line"><span class="comment">//                if(count &lt;= 0) &#123;</span></span><br><span class="line"><span class="comment">//                    continue;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取所有事件</span></span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历所有事件，逐一处理</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                    <span class="comment">// 判断事件类型</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                        <span class="type">ServerSocketChannel</span> <span class="variable">c</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">// 必须处理</span></span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> c.accept();</span><br><span class="line">                        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, sc);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 处理完毕，必须将事件移除</span></span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="💡-事件发生后能否不处理"><a href="#💡-事件发生后能否不处理" class="headerlink" title="💡 事件发生后能否不处理"></a>💡 事件发生后能否不处理</h4><blockquote>
<p>事件发生后，要么处理，要么取消（cancel），不能什么都不做，否则下次该事件仍会触发，这是因为 nio 底层使用的是水平触发</p>
</blockquote>
<h3 id="4-4-处理-read-事件"><a href="#4-4-处理-read-事件" class="headerlink" title="4.4 处理 read 事件"></a>4.4 处理 read 事件</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelDemo6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> ServerSocketChannel.open()) &#123;</span><br><span class="line">            channel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">            System.out.println(channel);</span><br><span class="line">            <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">            channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">            channel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> selector.select();</span><br><span class="line"><span class="comment">//                int count = selector.selectNow();</span></span><br><span class="line">                log.debug(<span class="string">&quot;select count: &#123;&#125;&quot;</span>, count);</span><br><span class="line"><span class="comment">//                if(count &lt;= 0) &#123;</span></span><br><span class="line"><span class="comment">//                    continue;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 获取所有事件</span></span><br><span class="line">                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 遍历所有事件，逐一处理</span></span><br><span class="line">                Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class="line">                <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                    <span class="comment">// 判断事件类型</span></span><br><span class="line">                    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                        <span class="type">ServerSocketChannel</span> <span class="variable">c</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                        <span class="comment">// 必须处理</span></span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> c.accept();</span><br><span class="line">                        sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                        sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                        log.debug(<span class="string">&quot;连接已建立: &#123;&#125;&quot;</span>, sc);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                        <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                        <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> sc.read(buffer);</span><br><span class="line">                        <span class="keyword">if</span>(read == -<span class="number">1</span>) &#123;</span><br><span class="line">                            key.cancel();</span><br><span class="line">                            sc.close();</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            debug(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 处理完毕，必须将事件移除</span></span><br><span class="line">                    iter.remove();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开启两个客户端，修改一下发送文字，输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sun.nio.ch.ServerSocketChannelImpl[/0:0:0:0:0:0:0:0:8080]</span><br><span class="line">21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1</span><br><span class="line">21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60367]</span><br><span class="line">21:16:39 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 65 6c 6c 6f                                  |hello           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1</span><br><span class="line">21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - 连接已建立: java.nio.channels.SocketChannel[connected local=/127.0.0.1:8080 remote=/127.0.0.1:60378]</span><br><span class="line">21:16:59 [DEBUG] [main] c.i.n.ChannelDemo6 - select count: 1</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 77 6f 72 6c 64                                  |world           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<h4 id="💡-为何要-iter-remove"><a href="#💡-为何要-iter-remove" class="headerlink" title="💡 为何要 iter.remove()"></a>💡 为何要 iter.remove()</h4><blockquote>
<p>因为 select 在事件发生后，就会将相关的 key 放入 selectedKeys 集合，但不会在处理完后从 selectedKeys 集合中移除，需要我们自己编码删除。例如</p>
<ul>
<li>第一次触发了 ssckey 上的 accept 事件，没有移除 ssckey </li>
<li>第二次触发了 sckey 上的 read 事件，但这时 selectedKeys 中还有上次的 ssckey ，在处理时因为没有真正的 serverSocket 连上了，就会导致空指针异常</li>
</ul>
</blockquote>
<h4 id="💡-cancel-的作用"><a href="#💡-cancel-的作用" class="headerlink" title="💡 cancel 的作用"></a>💡 cancel 的作用</h4><blockquote>
<p>cancel 会取消注册在 selector 上的 channel，并从 keys 集合中删除 key 后续不会再监听事件</p>
</blockquote>
<h4 id="⚠️-不处理边界的问题"><a href="#⚠️-不处理边界的问题" class="headerlink" title="⚠️  不处理边界的问题"></a>⚠️  不处理边界的问题</h4><p>以前有同学写过这样的代码，思考注释中两个问题，以 bio 为例，其实 nio 道理是一样的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        ServerSocket ss=<span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9000</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">            <span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> s.getInputStream();</span><br><span class="line">            <span class="comment">// 这里这么写，有没有问题</span></span><br><span class="line">            <span class="type">byte</span>[] arr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> in.read(arr);</span><br><span class="line">                <span class="comment">// 这里这么写，有没有问题</span></span><br><span class="line">                <span class="keyword">if</span>(read == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(arr, <span class="number">0</span>, read));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">max</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">9000</span>);</span><br><span class="line">        <span class="type">OutputStream</span> <span class="variable">out</span> <span class="operator">=</span> max.getOutputStream();</span><br><span class="line">        out.write(<span class="string">&quot;hello&quot;</span>.getBytes());</span><br><span class="line">        out.write(<span class="string">&quot;world&quot;</span>.getBytes());</span><br><span class="line">        out.write(<span class="string">&quot;你好&quot;</span>.getBytes());</span><br><span class="line">        max.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hell</span><br><span class="line">owor</span><br><span class="line">ld�</span><br><span class="line">�好</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为什么？</p>
<h4 id="处理消息的边界"><a href="#处理消息的边界" class="headerlink" title="处理消息的边界"></a>处理消息的边界</h4><p><img src="../../../images/00023.png" alt=""></p>
<ul>
<li>一种思路是固定消息长度，数据包大小一样，服务器按预定长度读取，缺点是浪费带宽</li>
<li>另一种思路是按分隔符拆分，缺点是效率低</li>
<li>TLV 格式，即 Type 类型、Length 长度、Value 数据，类型和长度已知的情况下，就可以方便获取消息大小，分配合适的 buffer，缺点是 buffer 需要提前分配，如果内容过大，则影响 server 吞吐量<ul>
<li>Http 1.1 是 TLV 格式</li>
<li>Http 2.0 是 LTV 格式</li>
</ul>
</li>
</ul>
<pre class="mermaid">sequenceDiagram 
participant c1 as 客户端1
participant s as 服务器
participant b1 as ByteBuffer1
participant b2 as ByteBuffer2
c1 ->> s: 发送 01234567890abcdef3333\r
s ->> b1: 第一次 read 存入 01234567890abcdef
s ->> b2: 扩容
b1 ->> b2: 拷贝 01234567890abcdef
s ->> b2: 第二次 read 存入 3333\r
b2 ->> b2: 01234567890abcdef3333\r</pre>

<p>服务器端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">split</span><span class="params">(ByteBuffer source)</span> &#123;</span><br><span class="line">    source.flip();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; source.limit(); i++) &#123;</span><br><span class="line">        <span class="comment">// 找到一条完整消息</span></span><br><span class="line">        <span class="keyword">if</span> (source.get(i) == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> i + <span class="number">1</span> - source.position();</span><br><span class="line">            <span class="comment">// 把这条完整消息存入新的 ByteBuffer</span></span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">target</span> <span class="operator">=</span> ByteBuffer.allocate(length);</span><br><span class="line">            <span class="comment">// 从 source 读，向 target 写</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; length; j++) &#123;</span><br><span class="line">                target.put(source.get());</span><br><span class="line">            &#125;</span><br><span class="line">            debugAll(target);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    source.compact(); <span class="comment">// 0123456789abcdef  position 16 limit 16</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 selector, 管理多个 channel</span></span><br><span class="line">    <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">    <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">    ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">    <span class="comment">// 2. 建立 selector 和 channel 的联系（注册）</span></span><br><span class="line">    <span class="comment">// SelectionKey 就是将来事件发生后，通过它可以知道事件和哪个channel的事件</span></span><br><span class="line">    <span class="type">SelectionKey</span> <span class="variable">sscKey</span> <span class="operator">=</span> ssc.register(selector, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// key 只关注 accept 事件</span></span><br><span class="line">    sscKey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">    log.debug(<span class="string">&quot;sscKey:&#123;&#125;&quot;</span>, sscKey);</span><br><span class="line">    ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 3. select 方法, 没有事件发生，线程阻塞，有事件，线程才会恢复运行</span></span><br><span class="line">        <span class="comment">// select 在事件未处理时，它不会阻塞, 事件发生后要么处理，要么取消，不能置之不理</span></span><br><span class="line">        selector.select();</span><br><span class="line">        <span class="comment">// 4. 处理事件, selectedKeys 内部包含了所有发生的事件</span></span><br><span class="line">        Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator(); <span class="comment">// accept, read</span></span><br><span class="line">        <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">            <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">            <span class="comment">// 处理key 时，要从 selectedKeys 集合中删除，否则下次处理就会有问题</span></span><br><span class="line">            iter.remove();</span><br><span class="line">            log.debug(<span class="string">&quot;key: &#123;&#125;&quot;</span>, key);</span><br><span class="line">            <span class="comment">// 5. 区分事件类型</span></span><br><span class="line">            <span class="keyword">if</span> (key.isAcceptable()) &#123; <span class="comment">// 如果是 accept</span></span><br><span class="line">                <span class="type">ServerSocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> channel.accept();</span><br><span class="line">                sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>); <span class="comment">// attachment</span></span><br><span class="line">                <span class="comment">// 将一个 byteBuffer 作为附件关联到 selectionKey 上</span></span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">scKey</span> <span class="operator">=</span> sc.register(selector, <span class="number">0</span>, buffer);</span><br><span class="line">                scKey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, sc);</span><br><span class="line">                log.debug(<span class="string">&quot;scKey:&#123;&#125;&quot;</span>, scKey);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123; <span class="comment">// 如果是 read</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> (SocketChannel) key.channel(); <span class="comment">// 拿到触发事件的channel</span></span><br><span class="line">                    <span class="comment">// 获取 selectionKey 上关联的附件</span></span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> channel.read(buffer); <span class="comment">// 如果是正常断开，read 的方法的返回值是 -1</span></span><br><span class="line">                    <span class="keyword">if</span>(read == -<span class="number">1</span>) &#123;</span><br><span class="line">                        key.cancel();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        split(buffer);</span><br><span class="line">                        <span class="comment">// 需要扩容</span></span><br><span class="line">                        <span class="keyword">if</span> (buffer.position() == buffer.limit()) &#123;</span><br><span class="line">                            <span class="type">ByteBuffer</span> <span class="variable">newBuffer</span> <span class="operator">=</span> ByteBuffer.allocate(buffer.capacity() * <span class="number">2</span>);</span><br><span class="line">                            buffer.flip();</span><br><span class="line">                            newBuffer.put(buffer); <span class="comment">// 0123456789abcdef3333\n</span></span><br><span class="line">                            key.attach(newBuffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    key.cancel();  <span class="comment">// 因为客户端断开了,因此需要将 key 取消（从 selector 的 keys 集合中真正删除 key）</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">sc.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line"><span class="type">SocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> sc.getLocalAddress();</span><br><span class="line"><span class="comment">// sc.write(Charset.defaultCharset().encode(&quot;hello\nworld\n&quot;));</span></span><br><span class="line">sc.write(Charset.defaultCharset().encode(<span class="string">&quot;0123\n456789abcdef&quot;</span>));</span><br><span class="line">sc.write(Charset.defaultCharset().encode(<span class="string">&quot;0123456789abcdef3333\n&quot;</span>));</span><br><span class="line">System.in.read();</span><br></pre></td></tr></table></figure>
<h4 id="ByteBuffer-大小分配"><a href="#ByteBuffer-大小分配" class="headerlink" title="ByteBuffer 大小分配"></a>ByteBuffer 大小分配</h4><ul>
<li>每个 channel 都需要记录可能被切分的消息，因为 ByteBuffer 不能被多个 channel 共同使用，因此需要为每个 channel 维护一个独立的 ByteBuffer</li>
<li>ByteBuffer 不能太大，比如一个 ByteBuffer 1Mb 的话，要支持百万连接就要 1Tb 内存，因此需要设计大小可变的 ByteBuffer<ul>
<li>一种思路是首先分配一个较小的 buffer，例如 4k，如果发现数据不够，再分配 8k 的 buffer，将 4k buffer 内容拷贝至 8k buffer，优点是消息连续容易处理，缺点是数据拷贝耗费性能，参考实现 <a href="http://tutorials.jenkov.com/java-performance/resizable-array.html">http://tutorials.jenkov.com/java-performance/resizable-array.html</a></li>
<li>另一种思路是用多个数组组成 buffer，一个数组不够，把多出来的内容写入新的数组，与前面的区别是消息存储不连续解析复杂，优点是避免了拷贝引起的性能损耗</li>
</ul>
</li>
</ul>
<h3 id="4-5-处理-write-事件"><a href="#4-5-处理-write-事件" class="headerlink" title="4.5 处理 write 事件"></a>4.5 处理 write 事件</h3><h4 id="一次无法写完例子"><a href="#一次无法写完例子" class="headerlink" title="一次无法写完例子"></a>一次无法写完例子</h4><ul>
<li>非阻塞模式下，无法保证把 buffer 中所有数据都写入 channel，因此需要追踪 write 方法的返回值（代表实际写入字节数）</li>
<li>用 selector 监听所有 channel 的可写事件，每个 channel 都需要一个 key 来跟踪 buffer，但这样又会导致占用内存过多，就有两阶段策略<ul>
<li>当消息处理器第一次写入消息时，才将 channel 注册到 selector 上</li>
<li>selector 检查 channel 上的可写事件，如果所有的数据写完了，就取消 channel 的注册</li>
<li>如果不取消，会每次可写均会触发 write 事件</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteServer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line"></span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                iter.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> ssc.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">sckey</span> <span class="operator">=</span> sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    <span class="comment">// 1. 向客户端发送内容</span></span><br><span class="line">                    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3000000</span>; i++) &#123;</span><br><span class="line">                        sb.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> Charset.defaultCharset().encode(sb.toString());</span><br><span class="line">                    <span class="type">int</span> <span class="variable">write</span> <span class="operator">=</span> sc.write(buffer);</span><br><span class="line">                    <span class="comment">// 3. write 表示实际写了多少字节</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;实际写入字节:&quot;</span> + write);</span><br><span class="line">                    <span class="comment">// 4. 如果有剩余未读字节，才需要关注写事件</span></span><br><span class="line">                    <span class="keyword">if</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                        <span class="comment">// read 1  write 4</span></span><br><span class="line">                        <span class="comment">// 在原有关注事件的基础上，多关注 写事件</span></span><br><span class="line">                        sckey.interestOps(sckey.interestOps() + SelectionKey.OP_WRITE);</span><br><span class="line">                        <span class="comment">// 把 buffer 作为附件加入 sckey</span></span><br><span class="line">                        sckey.attach(buffer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuffer) key.attachment();</span><br><span class="line">                    <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                    <span class="type">int</span> <span class="variable">write</span> <span class="operator">=</span> sc.write(buffer);</span><br><span class="line">                    System.out.println(<span class="string">&quot;实际写入字节:&quot;</span> + write);</span><br><span class="line">                    <span class="keyword">if</span> (!buffer.hasRemaining()) &#123; <span class="comment">// 写完了</span></span><br><span class="line">                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE);</span><br><span class="line">                        key.attach(<span class="literal">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WriteClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open();</span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> SocketChannel.open();</span><br><span class="line">        sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        sc.register(selector, SelectionKey.OP_CONNECT | SelectionKey.OP_READ);</span><br><span class="line">        sc.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                iter.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">                    System.out.println(sc.finishConnect());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                    <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">                    count += sc.read(buffer);</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    System.out.println(count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="💡-write-为何要取消"><a href="#💡-write-为何要取消" class="headerlink" title="💡 write 为何要取消"></a>💡 write 为何要取消</h4><p>只要向 channel 发送数据时，socket 缓冲可写，这个事件会频繁触发，因此应当只在 socket 缓冲区写不下时再关注可写事件，数据写完之后再取消关注</p>
<h3 id="4-6-更进一步"><a href="#4-6-更进一步" class="headerlink" title="4.6 更进一步"></a>4.6 更进一步</h3><h4 id="💡-利用多线程优化"><a href="#💡-利用多线程优化" class="headerlink" title="💡 利用多线程优化"></a>💡 利用多线程优化</h4><blockquote>
<p>现在都是多核 cpu，设计时要充分考虑别让 cpu 的力量被白白浪费</p>
</blockquote>
<p>前面的代码只有一个选择器，没有充分利用多核 cpu，如何改进呢？</p>
<p>分两组选择器</p>
<ul>
<li>单线程配一个选择器，专门处理 accept 事件</li>
<li>创建 cpu 核心数的线程，每个线程配一个选择器，轮流处理 read 事件</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChannelDemo7</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">BossEventLoop</span>().register();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Slf4j</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">BossEventLoop</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Selector boss;</span><br><span class="line">        <span class="keyword">private</span> WorkerEventLoop[] workers;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">start</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">                <span class="type">ServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> ServerSocketChannel.open();</span><br><span class="line">                ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">                ssc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                boss = Selector.open();</span><br><span class="line">                <span class="type">SelectionKey</span> <span class="variable">ssckey</span> <span class="operator">=</span> ssc.register(boss, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">                ssckey.interestOps(SelectionKey.OP_ACCEPT);</span><br><span class="line">                workers = initEventLoops();</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>, <span class="string">&quot;boss&quot;</span>).start();</span><br><span class="line">                log.debug(<span class="string">&quot;boss start...&quot;</span>);</span><br><span class="line">                start = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> WorkerEventLoop[] initEventLoops() &#123;</span><br><span class="line"><span class="comment">//        EventLoop[] eventLoops = new EventLoop[Runtime.getRuntime().availableProcessors()];</span></span><br><span class="line">            WorkerEventLoop[] workerEventLoops = <span class="keyword">new</span> <span class="title class_">WorkerEventLoop</span>[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; workerEventLoops.length; i++) &#123;</span><br><span class="line">                workerEventLoops[i] = <span class="keyword">new</span> <span class="title class_">WorkerEventLoop</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> workerEventLoops;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    boss.select();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = boss.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                        iter.remove();</span><br><span class="line">                        <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                            <span class="type">ServerSocketChannel</span> <span class="variable">c</span> <span class="operator">=</span> (ServerSocketChannel) key.channel();</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> c.accept();</span><br><span class="line">                            sc.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">                            log.debug(<span class="string">&quot;&#123;&#125; connected&quot;</span>, sc.getRemoteAddress());</span><br><span class="line">                            workers[index.getAndIncrement() % workers.length].register(sc);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Slf4j</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WorkerEventLoop</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Selector worker;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">start</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentLinkedQueue&lt;Runnable&gt; tasks = <span class="keyword">new</span> <span class="title class_">ConcurrentLinkedQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">WorkerEventLoop</span><span class="params">(<span class="type">int</span> index)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.index = index;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(SocketChannel sc)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">            <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">                worker = Selector.open();</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="built_in">this</span>, <span class="string">&quot;worker-&quot;</span> + index).start();</span><br><span class="line">                start = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            tasks.add(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="type">SelectionKey</span> <span class="variable">sckey</span> <span class="operator">=</span> sc.register(worker, <span class="number">0</span>, <span class="literal">null</span>);</span><br><span class="line">                    sckey.interestOps(SelectionKey.OP_READ);</span><br><span class="line">                    worker.selectNow();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            worker.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    worker.select();</span><br><span class="line">                    <span class="type">Runnable</span> <span class="variable">task</span> <span class="operator">=</span> tasks.poll();</span><br><span class="line">                    <span class="keyword">if</span> (task != <span class="literal">null</span>) &#123;</span><br><span class="line">                        task.run();</span><br><span class="line">                    &#125;</span><br><span class="line">                    Set&lt;SelectionKey&gt; keys = worker.selectedKeys();</span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iter = keys.iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">                        <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            <span class="type">SocketChannel</span> <span class="variable">sc</span> <span class="operator">=</span> (SocketChannel) key.channel();</span><br><span class="line">                            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">128</span>);</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                <span class="type">int</span> <span class="variable">read</span> <span class="operator">=</span> sc.read(buffer);</span><br><span class="line">                                <span class="keyword">if</span> (read == -<span class="number">1</span>) &#123;</span><br><span class="line">                                    key.cancel();</span><br><span class="line">                                    sc.close();</span><br><span class="line">                                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                    buffer.flip();</span><br><span class="line">                                    log.debug(<span class="string">&quot;&#123;&#125; message:&quot;</span>, sc.getRemoteAddress());</span><br><span class="line">                                    debugAll(buffer);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                                key.cancel();</span><br><span class="line">                                sc.close();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        iter.remove();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="💡-如何拿到-cpu-个数"><a href="#💡-如何拿到-cpu-个数" class="headerlink" title="💡 如何拿到 cpu 个数"></a>💡 如何拿到 cpu 个数</h4><blockquote>
<ul>
<li>Runtime.getRuntime().availableProcessors() 如果工作在 docker 容器下，因为容器不是物理隔离的，会拿到物理 cpu 个数，而不是容器申请时的个数</li>
<li>这个问题直到 jdk 10 才修复，使用 jvm 参数 UseContainerSupport 配置， 默认开启</li>
</ul>
</blockquote>
<h3 id="4-7-UDP"><a href="#4-7-UDP" class="headerlink" title="4.7 UDP"></a>4.7 UDP</h3><ul>
<li>UDP 是无连接的，client 发送数据不会管 server 是否开启</li>
<li>server 这边的 receive 方法会将接收到的数据存入 byte buffer，但如果数据报文超过 buffer 大小，多出来的数据会被默默抛弃</li>
</ul>
<p>首先启动服务器端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UdpServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">DatagramChannel</span> <span class="variable">channel</span> <span class="operator">=</span> DatagramChannel.open()) &#123;</span><br><span class="line">            channel.socket().bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">9999</span>));</span><br><span class="line">            System.out.println(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">32</span>);</span><br><span class="line">            channel.receive(buffer);</span><br><span class="line">            buffer.flip();</span><br><span class="line">            debug(buffer);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">waiting...</span><br></pre></td></tr></table></figure>
<p>运行客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UdpClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">DatagramChannel</span> <span class="variable">channel</span> <span class="operator">=</span> DatagramChannel.open()) &#123;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> StandardCharsets.UTF_8.encode(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">            <span class="type">InetSocketAddress</span> <span class="variable">address</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">9999</span>);</span><br><span class="line">            channel.send(buffer, address);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来服务器端输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 65 6c 6c 6f                                  |hello           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<h2 id="5-NIO-vs-BIO"><a href="#5-NIO-vs-BIO" class="headerlink" title="5. NIO vs BIO"></a>5. NIO vs BIO</h2><h3 id="5-1-stream-vs-channel"><a href="#5-1-stream-vs-channel" class="headerlink" title="5.1 stream vs channel"></a>5.1 stream vs channel</h3><ul>
<li>stream 不会自动缓冲数据，channel 会利用系统提供的发送缓冲区、接收缓冲区（更为底层）</li>
<li>stream 仅支持阻塞 API，channel 同时支持阻塞、非阻塞 API，网络 channel 可配合 selector 实现多路复用</li>
<li>二者均为全双工，即读写可以同时进行</li>
</ul>
<h3 id="5-2-IO-模型"><a href="#5-2-IO-模型" class="headerlink" title="5.2 IO 模型"></a>5.2 IO 模型</h3><p>BIO同步阻塞、NIO同步非阻塞、同步多路复用、异步阻塞（没有此情况）、AIO异步非阻塞</p>
<ul>
<li>同步：线程自己去获取结果（一个线程）</li>
<li>异步：线程自己不去获取结果，而是由其它线程送结果（至少两个线程）</li>
</ul>
<p>当调用一次 channel.read 或 stream.read 后，会切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：</p>
<ul>
<li>等待数据阶段</li>
<li>复制数据阶段</li>
</ul>
<p><img src="../../../images/0033.png" alt=""></p>
<ul>
<li><p>阻塞 IO</p>
<p><img src="../../../images/0039.png" alt=""></p>
</li>
<li><p>非阻塞  IO</p>
<p><img src="../../../images/0035.png" alt=""></p>
</li>
<li><p>多路复用</p>
<p><img src="../../../images/0038.png" alt=""></p>
</li>
<li><p>信号驱动</p>
</li>
<li><p>异步 IO</p>
<p><img src="../../../images/0037.png" alt=""></p>
</li>
<li><p>阻塞 IO vs 多路复用</p>
<p><img src="../../../images/0034.png" alt=""></p>
<p><img src="../../../images/0036.png" alt=""></p>
</li>
</ul>
<h4 id="🔖-参考"><a href="#🔖-参考" class="headerlink" title="🔖 参考"></a>🔖 参考</h4><p>UNIX 网络编程 - 卷 I</p>
<h3 id="5-3-零拷贝"><a href="#5-3-零拷贝" class="headerlink" title="5.3 零拷贝"></a>5.3 零拷贝</h3><h4 id="传统-IO-问题"><a href="#传统-IO-问题" class="headerlink" title="传统 IO 问题"></a>传统 IO 问题</h4><p>传统的 IO 将一个文件通过 socket 写出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">File</span> <span class="variable">f</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;helloword/data.txt&quot;</span>);</span><br><span class="line"><span class="type">RandomAccessFile</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(file, <span class="string">&quot;r&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[(<span class="type">int</span>)f.length()];</span><br><span class="line">file.read(buf);</span><br><span class="line"></span><br><span class="line"><span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ...;</span><br><span class="line">socket.getOutputStream().write(buf);</span><br></pre></td></tr></table></figure>
<p>内部工作流程是这样的：</p>
<p><img src="../../../images/00024.png" alt=""></p>
<ol>
<li><p>java 本身并不具备 IO 读写能力，因此 read 方法调用后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，去调用操作系统（Kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这期间用户线程阻塞，操作系统使用 DMA（Direct Memory Access）来实现文件读，其间也不会使用 cpu</p>
<blockquote>
<p>DMA 也可以理解为硬件单元，用来解放 cpu 完成文件 IO</p>
</blockquote>
</li>
<li><p>从<strong>内核态</strong>切换回<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区</strong>（即 byte[] buf），这期间 cpu 会参与拷贝，无法利用 DMA</p>
</li>
<li><p>调用 write 方法，这时将数据从<strong>用户缓冲区</strong>（byte[] buf）写入 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</p>
</li>
<li><p>接下来要向网卡写数据，这项能力 java 又不具备，因此又得从<strong>用户态</strong>切换至<strong>内核态</strong>，调用操作系统的写能力，使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</p>
</li>
</ol>
<p>可以看到中间环节较多，java 的 IO 实际不是物理设备级别的读写，而是缓存的复制，底层的真正读写是操作系统来完成的</p>
<ul>
<li>用户态与内核态的切换发生了 3 次，这个操作比较重量级</li>
<li>数据拷贝了共 4 次</li>
</ul>
<h4 id="NIO-优化"><a href="#NIO-优化" class="headerlink" title="NIO 优化"></a>NIO 优化</h4><p>通过 DirectByteBuf </p>
<ul>
<li>ByteBuffer.allocate(10)  HeapByteBuffer 使用的还是 java 内存</li>
<li>ByteBuffer.allocateDirect(10)  DirectByteBuffer 使用的是操作系统内存</li>
</ul>
<p><img src="../../../images/00025.png" alt=""></p>
<p>大部分步骤与优化前相同，不再赘述。唯有一点：java 可以使用 DirectByteBuf 将堆外内存映射到 jvm 内存中来直接访问使用</p>
<ul>
<li>这块内存不受 jvm 垃圾回收的影响，因此内存地址固定，有助于 IO 读写</li>
<li>java 中的 DirectByteBuf 对象仅维护了此内存的虚引用，内存回收分成两步<ul>
<li>DirectByteBuf 对象被垃圾回收，将虚引用加入引用队列</li>
<li>通过专门线程访问引用队列，根据虚引用释放堆外内存</li>
</ul>
</li>
<li>减少了一次数据拷贝，用户态与内核态的切换次数没有减少</li>
</ul>
<p>进一步优化（底层采用了 linux 2.1 后提供的 sendFile 方法），java 中对应着两个 channel 调用 transferTo/transferFrom 方法拷贝数据</p>
<p><img src="../../../images/0026.png" alt=""></p>
<ol>
<li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li>
<li>数据从<strong>内核缓冲区</strong>传输到 <strong>socket 缓冲区</strong>，cpu 会参与拷贝</li>
<li>最后使用 DMA 将 <strong>socket 缓冲区</strong>的数据写入网卡，不会使用 cpu</li>
</ol>
<p>可以看到</p>
<ul>
<li>只发生了一次用户态与内核态的切换</li>
<li>数据拷贝了 3 次</li>
</ul>
<p>进一步优化（linux 2.4）</p>
<p><img src="../../../images/0027.png" alt=""></p>
<ol>
<li>java 调用 transferTo 方法后，要从 java 程序的<strong>用户态</strong>切换至<strong>内核态</strong>，使用 DMA将数据读入<strong>内核缓冲区</strong>，不会使用 cpu</li>
<li>只会将一些 offset 和 length 信息拷入 <strong>socket 缓冲区</strong>，几乎无消耗</li>
<li>使用 DMA 将 <strong>内核缓冲区</strong>的数据写入网卡，不会使用 cpu</li>
</ol>
<p>整个过程仅只发生了一次用户态与内核态的切换，数据拷贝了 2 次。所谓的【零拷贝】，并不是真正无拷贝，而是在不会拷贝重复数据到 jvm 内存中，零拷贝的优点有</p>
<ul>
<li>更少的用户态与内核态的切换</li>
<li>不利用 cpu 计算，减少 cpu 缓存伪共享</li>
<li>零拷贝适合小文件传输</li>
</ul>
<h3 id="5-3-AIO"><a href="#5-3-AIO" class="headerlink" title="5.3 AIO"></a>5.3 AIO</h3><p>AIO 用来解决数据复制阶段的阻塞问题</p>
<ul>
<li>同步意味着，在进行读写操作时，线程需要等待结果，还是相当于闲置</li>
<li>异步意味着，在进行读写操作时，线程不必等待结果，而是将来由操作系统来通过回调方式由另外的线程来获得结果</li>
</ul>
<blockquote>
<p>异步模型需要底层操作系统（Kernel）提供支持</p>
<ul>
<li>Windows 系统通过 IOCP 实现了真正的异步 IO</li>
<li>Linux 系统异步 IO 在 2.6 版本引入，但其底层实现还是用多路复用模拟了异步 IO，性能没有优势</li>
</ul>
</blockquote>
<h4 id="文件-AIO"><a href="#文件-AIO" class="headerlink" title="文件 AIO"></a>文件 AIO</h4><p>先来看看 AsynchronousFileChannel</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AioDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="type">AsynchronousFileChannel</span> <span class="variable">s</span> <span class="operator">=</span> </span><br><span class="line">                AsynchronousFileChannel.open(</span><br><span class="line">                	Paths.get(<span class="string">&quot;1.txt&quot;</span>), StandardOpenOption.READ);</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">2</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">            s.read(buffer, <span class="number">0</span>, <span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;read completed...&#123;&#125;&quot;</span>, result);</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    debug(buffer);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;read failed...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.debug(<span class="string">&quot;do other things...&quot;</span>);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - begin...</span><br><span class="line">13:44:56 [DEBUG] [main] c.i.aio.AioDemo1 - do other things...</span><br><span class="line">13:44:56 [DEBUG] [Thread-5] c.i.aio.AioDemo1 - read completed...2</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 0d                                           |a.              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<p>可以看到</p>
<ul>
<li>响应文件读取成功的是另一个线程 Thread-5</li>
<li>主线程并没有 IO 操作阻塞</li>
</ul>
<h4 id="💡-守护线程"><a href="#💡-守护线程" class="headerlink" title="💡 守护线程"></a>💡 守护线程</h4><p>默认文件 AIO 使用的线程都是守护线程，所以最后要执行 <code>System.in.read()</code> 以避免守护线程意外结束</p>
<h4 id="网络-AIO"><a href="#网络-AIO" class="headerlink" title="网络 AIO"></a>网络 AIO</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AioServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">AsynchronousServerSocketChannel</span> <span class="variable">ssc</span> <span class="operator">=</span> AsynchronousServerSocketChannel.open();</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line">        ssc.accept(<span class="literal">null</span>, <span class="keyword">new</span> <span class="title class_">AcceptHandler</span>(ssc));</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">closeChannel</span><span class="params">(AsynchronousSocketChannel sc)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.printf(<span class="string">&quot;[%s] %s close\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class="line">            sc.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">ReadHandler</span> <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AsynchronousSocketChannel sc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">ReadHandler</span><span class="params">(AsynchronousSocketChannel sc)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.sc = sc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (result == -<span class="number">1</span>) &#123;</span><br><span class="line">                    closeChannel(sc);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.printf(<span class="string">&quot;[%s] %s read\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class="line">                attachment.flip();</span><br><span class="line">                System.out.println(Charset.defaultCharset().decode(attachment));</span><br><span class="line">                attachment.clear();</span><br><span class="line">                <span class="comment">// 处理完第一个 read 时，需要再次调用 read 方法来处理下一个 read 事件</span></span><br><span class="line">                sc.read(attachment, attachment, <span class="built_in">this</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            closeChannel(sc);</span><br><span class="line">            exc.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">WriteHandler</span> <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;Integer, ByteBuffer&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AsynchronousSocketChannel sc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="title function_">WriteHandler</span><span class="params">(AsynchronousSocketChannel sc)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.sc = sc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            <span class="comment">// 如果作为附件的 buffer 还有内容，需要再次 write 写出剩余内容</span></span><br><span class="line">            <span class="keyword">if</span> (attachment.hasRemaining()) &#123;</span><br><span class="line">                sc.write(attachment);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> &#123;</span><br><span class="line">            exc.printStackTrace();</span><br><span class="line">            closeChannel(sc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AcceptHandler</span> <span class="keyword">implements</span> <span class="title class_">CompletionHandler</span>&lt;AsynchronousSocketChannel, Object&gt; &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AsynchronousServerSocketChannel ssc;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AcceptHandler</span><span class="params">(AsynchronousServerSocketChannel ssc)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.ssc = ssc;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">completed</span><span class="params">(AsynchronousSocketChannel sc, Object attachment)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.printf(<span class="string">&quot;[%s] %s connected\n&quot;</span>, Thread.currentThread().getName(), sc.getRemoteAddress());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">ByteBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">            <span class="comment">// 读事件由 ReadHandler 处理</span></span><br><span class="line">            sc.read(buffer, buffer, <span class="keyword">new</span> <span class="title class_">ReadHandler</span>(sc));</span><br><span class="line">            <span class="comment">// 写事件由 WriteHandler 处理</span></span><br><span class="line">            sc.write(Charset.defaultCharset().encode(<span class="string">&quot;server hello!&quot;</span>), ByteBuffer.allocate(<span class="number">16</span>), <span class="keyword">new</span> <span class="title class_">WriteHandler</span>(sc));</span><br><span class="line">            <span class="comment">// 处理完第一个 accpet 时，需要再次调用 accept 方法来处理下一个 accept 事件</span></span><br><span class="line">            ssc.accept(<span class="literal">null</span>, <span class="built_in">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">failed</span><span class="params">(Throwable exc, Object attachment)</span> &#123;</span><br><span class="line">            exc.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty(二) 基础组件EventLoop, Channel</title>
    <url>/posts/40045.html</url>
    <content><![CDATA[<h1 id="二-Netty-入门"><a href="#二-Netty-入门" class="headerlink" title="二. Netty 入门"></a>二. Netty 入门</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><h3 id="1-1-Netty-是什么？"><a href="#1-1-Netty-是什么？" class="headerlink" title="1.1 Netty 是什么？"></a>1.1 Netty 是什么？</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Netty is an asynchronous event-driven network application framework</span><br><span class="line">for rapid development of maintainable high performance protocol servers &amp; clients.</span><br></pre></td></tr></table></figure>
<p>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p>
<h3 id="1-2-Netty-的作者"><a href="#1-2-Netty-的作者" class="headerlink" title="1.2 Netty 的作者"></a>1.2 Netty 的作者</h3><p><img src="../../../images/0005.png" alt=""></p>
<p>他还是另一个著名网络应用框架 Mina 的重要贡献者</p>
<h3 id="1-3-Netty-的地位"><a href="#1-3-Netty-的地位" class="headerlink" title="1.3 Netty 的地位"></a>1.3 Netty 的地位</h3><p>Netty 在 Java 网络应用框架中的地位就好比：Spring 框架在 JavaEE 开发中的地位</p>
<p>以下的框架都使用了 Netty，因为它们有网络通信需求！</p>
<ul>
<li>Cassandra - nosql 数据库</li>
<li>Spark - 大数据分布式计算框架</li>
<li>Hadoop - 大数据分布式存储框架</li>
<li>RocketMQ - ali 开源的消息队列</li>
<li>ElasticSearch - 搜索引擎</li>
<li>gRPC - rpc 框架</li>
<li>Dubbo - rpc 框架</li>
<li>Spring 5.x - flux api 完全抛弃了 tomcat ，使用 netty 作为服务器端</li>
<li>Zookeeper - 分布式协调框架</li>
</ul>
<h3 id="1-4-Netty-的优势"><a href="#1-4-Netty-的优势" class="headerlink" title="1.4 Netty 的优势"></a>1.4 Netty 的优势</h3><ul>
<li>Netty vs NIO，工作量大，bug 多<ul>
<li>需要自己构建协议</li>
<li>解决 TCP 传输问题，如粘包、半包</li>
<li>epoll 空轮询导致 CPU 100%</li>
<li>对 API 进行增强，使之更易用，如 FastThreadLocal =&gt; ThreadLocal，ByteBuf =&gt; ByteBuffer</li>
</ul>
</li>
<li>Netty vs 其它网络应用框架<ul>
<li>Mina 由 apache 维护，将来 3.x 版本可能会有较大重构，破坏 API 向下兼容性，Netty 的开发迭代更迅速，API 更简洁、文档更优秀</li>
<li>久经考验，16年，Netty 版本<ul>
<li>2.x 2004</li>
<li>3.x 2008</li>
<li>4.x 2013</li>
<li>5.x 已废弃（没有明显的性能提升，维护成本高）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-Hello-World"><a href="#2-Hello-World" class="headerlink" title="2. Hello World"></a>2. Hello World</h2><h3 id="2-1-目标"><a href="#2-1-目标" class="headerlink" title="2.1 目标"></a>2.1 目标</h3><p>开发一个简单的服务器端和客户端</p>
<ul>
<li>客户端向服务器端发送 hello, world</li>
<li>服务器仅接收，不返回</li>
</ul>
<p>加入依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.39.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-2-服务器端"><a href="#2-2-服务器端" class="headerlink" title="2.2 服务器端"></a>2.2 服务器端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>()) <span class="comment">// 1</span></span><br><span class="line">    .channel(NioServerSocketChannel.class) <span class="comment">// 2</span></span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringDecoder</span>()); <span class="comment">// 5</span></span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;String&gt;() &#123; <span class="comment">// 6</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span> &#123;</span><br><span class="line">                    System.out.println(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .bind(<span class="number">8080</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>代码解读</p>
<ul>
<li><p>1 处，创建 NioEventLoopGroup，可以简单理解为 <code>线程池 + Selector</code> 后面会详细展开</p>
</li>
<li><p>2 处，选择服务 Scoket 实现类，其中 NioServerSocketChannel 表示基于 NIO 的服务器端实现，其它实现还有</p>
<p><img src="../../../images/0006.png" alt=""></p>
</li>
<li><p>3 处，为啥方法叫 childHandler，是接下来添加的处理器都是给 SocketChannel 用的，而不是给 ServerSocketChannel。ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器</p>
</li>
<li><p>4 处，ServerSocketChannel 绑定的监听端口</p>
</li>
<li><p>5 处，SocketChannel 的处理器，解码 ByteBuf =&gt; String</p>
</li>
<li><p>6 处，SocketChannel 的业务处理器，使用上一个处理器的处理结果</p>
</li>
</ul>
<h3 id="2-3-客户端"><a href="#2-3-客户端" class="headerlink" title="2.3 客户端"></a>2.3 客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>()) <span class="comment">// 1</span></span><br><span class="line">    .channel(NioSocketChannel.class) <span class="comment">// 2</span></span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123; <span class="comment">// 3</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>()); <span class="comment">// 8</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>) <span class="comment">// 4</span></span><br><span class="line">    .sync() <span class="comment">// 5</span></span><br><span class="line">    .channel() <span class="comment">// 6</span></span><br><span class="line">    .writeAndFlush(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: hello world!&quot;</span>); <span class="comment">// 7</span></span><br></pre></td></tr></table></figure>
<p>代码解读</p>
<ul>
<li><p>1 处，创建 NioEventLoopGroup，同 Server</p>
</li>
<li><p>2 处，选择客户 Socket 实现类，NioSocketChannel 表示基于 NIO 的客户端实现，其它实现还有</p>
<p><img src="../../../images/0007.png" alt=""></p>
</li>
<li><p>3 处，添加 SocketChannel 的处理器，ChannelInitializer 处理器（仅执行一次），它的作用是待客户端 SocketChannel 建立连接后，执行 initChannel 以便添加更多的处理器</p>
</li>
<li>4 处，指定要连接的服务器和端口</li>
<li>5 处，Netty 中很多方法都是异步的，如 connect，这时需要使用 sync 方法等待 connect 建立连接完毕</li>
<li>6 处，获取 channel 对象，它即为通道抽象，可以进行数据读写操作</li>
<li>7 处，写入消息并清空缓冲区</li>
<li>8 处，消息会经过通道 handler 处理，这里是将 String =&gt; ByteBuf 发出</li>
<li>数据经过网络传输，到达服务器端，服务器端 5 和 6 处的 handler 先后被触发，走完一个流程</li>
</ul>
<h3 id="2-4-流程梳理"><a href="#2-4-流程梳理" class="headerlink" title="2.4 流程梳理"></a>2.4 流程梳理</h3><p><img src="../../../images/0040.png" alt=""></p>
<h4 id="💡-提示"><a href="#💡-提示" class="headerlink" title="💡 提示"></a>💡 提示</h4><blockquote>
<p>一开始需要树立正确的观念</p>
<ul>
<li>把 channel 理解为数据的通道</li>
<li>把 msg 理解为流动的数据，最开始输入是 ByteBuf，但经过 pipeline 的加工，会变成其它类型对象，最后输出又变成 ByteBuf</li>
<li>把 handler 理解为数据的处理工序<ul>
<li>工序有多道，合在一起就是 pipeline，pipeline 负责发布事件（读、读取完成…）传播给每个 handler， handler 对自己感兴趣的事件进行处理（重写了相应事件处理方法）</li>
<li>handler 分 Inbound 和 Outbound 两类</li>
</ul>
</li>
<li>把 eventLoop 理解为处理数据的工人<ul>
<li>工人可以管理多个 channel 的 io 操作，并且一旦工人负责了某个 channel，就要负责到底（绑定）</li>
<li>工人既可以执行 io 操作，也可以进行任务处理，每位工人有任务队列，队列里可以堆放多个 channel 的待处理任务，任务分为普通任务、定时任务</li>
<li>工人按照 pipeline 顺序，依次按照 handler 的规划（代码）处理数据，可以为每道工序指定不同的工人</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="3-组件"><a href="#3-组件" class="headerlink" title="3. 组件"></a>3. 组件</h2><h3 id="3-1-EventLoop"><a href="#3-1-EventLoop" class="headerlink" title="3.1 EventLoop"></a>3.1 EventLoop</h3><p>事件循环对象</p>
<p>EventLoop 本质是一个单线程执行器（同时维护了一个 Selector），里面有 run 方法处理 Channel 上源源不断的 io 事件。</p>
<p>它的继承关系比较复杂</p>
<ul>
<li>一条线是继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</li>
<li>另一条线是继承自 netty 自己的 OrderedEventExecutor，<ul>
<li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop</li>
<li>提供了 parent 方法来看看自己属于哪个 EventLoopGroup</li>
</ul>
</li>
</ul>
<p>事件循环组</p>
<p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）</p>
<ul>
<li>继承自 netty 自己的 EventExecutorGroup<ul>
<li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li>
<li>另有 next 方法获取集合中下一个 EventLoop</li>
</ul>
</li>
</ul>
<p>以一个简单的实现为例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 内部创建了两个 EventLoop, 每个 EventLoop 维护一个线程</span></span><br><span class="line"><span class="type">DefaultEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line">System.out.println(group.next());</span><br><span class="line">System.out.println(group.next());</span><br><span class="line">System.out.println(group.next());</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">io.netty.channel.DefaultEventLoop@60f82f98</span><br><span class="line">io.netty.channel.DefaultEventLoop@35f983a6</span><br><span class="line">io.netty.channel.DefaultEventLoop@60f82f98</span><br></pre></td></tr></table></figure>
<p>也可以使用 for 循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DefaultEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (EventExecutor eventLoop : group) &#123;</span><br><span class="line">    System.out.println(eventLoop);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">io.netty.channel.DefaultEventLoop@60f82f98</span><br><span class="line">io.netty.channel.DefaultEventLoop@35f983a6</span><br></pre></td></tr></table></figure>
<h4 id="💡-优雅关闭"><a href="#💡-优雅关闭" class="headerlink" title="💡 优雅关闭"></a>💡 优雅关闭</h4><p>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</p>
<h4 id="演示-NioEventLoop-处理-io-事件"><a href="#演示-NioEventLoop-处理-io-事件" class="headerlink" title="演示 NioEventLoop 处理 io 事件"></a>演示 NioEventLoop 处理 io 事件</h4><p>服务器端两个 nio worker 工人</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>))</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> msg <span class="keyword">instanceof</span> ByteBuf ? ((ByteBuf) msg) : <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (byteBuf != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">16</span>];</span><br><span class="line">                        <span class="type">ByteBuf</span> <span class="variable">len</span> <span class="operator">=</span> byteBuf.readBytes(buf, <span class="number">0</span>, byteBuf.readableBytes());</span><br><span class="line">                        log.debug(<span class="keyword">new</span> <span class="title class_">String</span>(buf));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).bind(<span class="number">8080</span>).sync();</span><br></pre></td></tr></table></figure>
<p>客户端，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">            .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>))</span><br><span class="line">            .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;init...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .channel(NioSocketChannel.class).connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>)</span><br><span class="line">            .sync()</span><br><span class="line">            .channel();</span><br><span class="line"></span><br><span class="line">    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="string">&quot;wangwu&quot;</span>.getBytes()));</span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    channel.writeAndFlush(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="string">&quot;wangwu&quot;</span>.getBytes()));</span><br></pre></td></tr></table></figure>
<p>最后输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">22:03:34 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       </span><br><span class="line">22:03:36 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - zhangsan       </span><br><span class="line">22:05:36 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           </span><br><span class="line">22:05:38 [DEBUG] [nioEventLoopGroup-3-2] c.i.o.EventLoopTest - lisi           </span><br><span class="line">22:06:09 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu        </span><br><span class="line">22:06:11 [DEBUG] [nioEventLoopGroup-3-1] c.i.o.EventLoopTest - wangwu         </span><br></pre></td></tr></table></figure>
<p>可以看到两个工人轮流处理 channel，但工人与 channel 之间进行了绑定</p>
<p><img src="../../../images/0042.png" alt=""></p>
<p>再增加两个非 nio 工人</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DefaultEventLoopGroup</span> <span class="variable">normalWorkers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>), <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>))</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span>  &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">            ch.pipeline().addLast(normalWorkers,<span class="string">&quot;myhandler&quot;</span>,</span><br><span class="line">              <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> msg <span class="keyword">instanceof</span> ByteBuf ? ((ByteBuf) msg) : <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (byteBuf != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">16</span>];</span><br><span class="line">                        <span class="type">ByteBuf</span> <span class="variable">len</span> <span class="operator">=</span> byteBuf.readBytes(buf, <span class="number">0</span>, byteBuf.readableBytes());</span><br><span class="line">                        log.debug(<span class="keyword">new</span> <span class="title class_">String</span>(buf));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).bind(<span class="number">8080</span>).sync();</span><br></pre></td></tr></table></figure>
<p>客户端代码不变，启动三次，分别修改发送字符串为 zhangsan（第一次），lisi（第二次），wangwu（第三次）</p>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] REGISTERED</span><br><span class="line">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] ACTIVE</span><br><span class="line">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:19:48 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE</span><br><span class="line">22:19:48 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        </span><br><span class="line">22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 7a 68 61 6e 67 73 61 6e                         |zhangsan        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:19:50 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x251562d5, L:/127.0.0.1:8080 - R:/127.0.0.1:52588] READ COMPLETE</span><br><span class="line">22:19:50 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - zhangsan        </span><br><span class="line">22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] REGISTERED</span><br><span class="line">22:20:24 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] ACTIVE</span><br><span class="line">22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6c 69 73 69                                     |lisi            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:20:25 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE</span><br><span class="line">22:20:25 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            </span><br><span class="line">22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ: 4B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6c 69 73 69                                     |lisi            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:20:27 [DEBUG] [nioEventLoopGroup-4-2] i.n.h.l.LoggingHandler - [id: 0x94b2a840, L:/127.0.0.1:8080 - R:/127.0.0.1:52612] READ COMPLETE</span><br><span class="line">22:20:27 [DEBUG] [defaultEventLoopGroup-2-2] c.i.o.EventLoopTest - lisi            </span><br><span class="line">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] REGISTERED</span><br><span class="line">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] ACTIVE</span><br><span class="line">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 77 61 6e 67 77 75                               |wangwu          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:20:38 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE</span><br><span class="line">22:20:38 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          </span><br><span class="line">22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ: 6B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 77 61 6e 67 77 75                               |wangwu          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">22:20:40 [DEBUG] [nioEventLoopGroup-4-1] i.n.h.l.LoggingHandler - [id: 0x79a26af9, L:/127.0.0.1:8080 - R:/127.0.0.1:52625] READ COMPLETE</span><br><span class="line">22:20:40 [DEBUG] [defaultEventLoopGroup-2-1] c.i.o.EventLoopTest - wangwu          </span><br></pre></td></tr></table></figure>
<p>可以看到，nio 工人和 非 nio 工人也分别绑定了 channel（LoggingHandler 由 nio 工人执行，而我们自己的 handler 由非 nio 工人执行）</p>
<p><img src="../../../images/0041.png" alt=""></p>
<h4 id="💡-handler-执行中如何换人？"><a href="#💡-handler-执行中如何换人？" class="headerlink" title="💡 handler 执行中如何换人？"></a>💡 handler 执行中如何换人？</h4><p>关键代码 <code>io.netty.channel.AbstractChannelHandlerContext#invokeChannelRead()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span> next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">&quot;msg&quot;</span>), next);</span><br><span class="line">    <span class="comment">// 下一个 handler 的事件循环是否与当前的事件循环是同一个线程</span></span><br><span class="line">    <span class="type">EventExecutor</span> <span class="variable">executor</span> <span class="operator">=</span> next.executor();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是，直接调用</span></span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">        next.invokeChannelRead(m);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 不是，将要执行的代码作为任务提交给下一个事件循环处理（换人）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                next.invokeChannelRead(m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果两个 handler 绑定的是同一个线程，那么就直接调用</li>
<li>否则，把要调用的代码封装为一个任务对象，由下一个 handler 的线程来调用</li>
</ul>
<h4 id="演示-NioEventLoop-处理普通任务"><a href="#演示-NioEventLoop-处理普通任务" class="headerlink" title="演示 NioEventLoop 处理普通任务"></a>演示 NioEventLoop 处理普通任务</h4><p>NioEventLoop 除了可以处理 io 事件，同样可以向它提交普通任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">NioEventLoopGroup</span> <span class="variable">nioWorkers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&quot;server start...&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">nioWorkers.execute(()-&gt;&#123;</span><br><span class="line">    log.debug(<span class="string">&quot;normal task...&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">22:30:36 [DEBUG] [main] c.i.o.EventLoopTest2 - server start...</span><br><span class="line">22:30:38 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - normal task...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以用来执行耗时较长的任务</p>
</blockquote>
<h4 id="演示-NioEventLoop-处理定时任务"><a href="#演示-NioEventLoop-处理定时任务" class="headerlink" title="演示 NioEventLoop 处理定时任务"></a>演示 NioEventLoop 处理定时任务</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">NioEventLoopGroup</span> <span class="variable">nioWorkers</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&quot;server start...&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">nioWorkers.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">22:35:15 [DEBUG] [main] c.i.o.EventLoopTest2 - server start...</span><br><span class="line">22:35:17 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...</span><br><span class="line">22:35:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...</span><br><span class="line">22:35:19 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...</span><br><span class="line">22:35:20 [DEBUG] [nioEventLoopGroup-2-1] c.i.o.EventLoopTest2 - running...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以用来执行定时任务</p>
</blockquote>
<h3 id="3-2-Channel"><a href="#3-2-Channel" class="headerlink" title="3.2 Channel"></a>3.2 Channel</h3><p>channel 的主要作用</p>
<ul>
<li>close() 可以用来关闭 channel</li>
<li>closeFuture() 用来处理 channel 的关闭<ul>
<li>sync 方法作用是同步等待 channel 关闭</li>
<li>而 addListener 方法是异步等待 channel 关闭</li>
</ul>
</li>
<li>pipeline() 方法添加处理器</li>
<li>write() 方法将数据写入</li>
<li>writeAndFlush() 方法将数据写入并刷出</li>
</ul>
<h4 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h4><p>这时刚才的客户端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>)</span><br><span class="line">    .sync()</span><br><span class="line">    .channel()</span><br><span class="line">    .writeAndFlush(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>现在把它拆开来看</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">channelFuture.sync().channel().writeAndFlush(<span class="keyword">new</span> <span class="title class_">Date</span>() + <span class="string">&quot;: hello world!&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>1 处返回的是 ChannelFuture 对象，它的作用是利用 channel() 方法来获取 Channel 对象</li>
</ul>
<p><strong>注意</strong> connect 方法是异步的，意味着不等连接建立，方法执行就返回了。因此 channelFuture 对象中不能【立刻】获得到正确的 Channel 对象</p>
<p>实验如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(channelFuture.channel()); <span class="comment">// 1</span></span><br><span class="line">channelFuture.sync(); <span class="comment">// 2</span></span><br><span class="line">System.out.println(channelFuture.channel()); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>执行到 1 时，连接未建立，打印 <code>[id: 0x2e1884dd]</code></li>
<li>执行到 2 时，sync 方法是同步等待连接建立完成</li>
<li>执行到 3 时，连接肯定建立了，打印 <code>[id: 0x2e1884dd, L:/127.0.0.1:57191 - R:/127.0.0.1:8080]</code></li>
</ul>
<p>除了用 sync 方法可以让异步操作同步以外，还可以使用回调的方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">System.out.println(channelFuture.channel()); <span class="comment">// 1</span></span><br><span class="line">channelFuture.addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">    System.out.println(future.channel()); <span class="comment">// 2</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>执行到 1 时，连接未建立，打印 <code>[id: 0x749124ba]</code></li>
<li>ChannelFutureListener 会在连接建立时被调用（其中 operationComplete 方法），因此执行到 2 时，连接肯定建立了，打印 <code>[id: 0x749124ba, L:/127.0.0.1:57351 - R:/127.0.0.1:8080]</code></li>
</ul>
<h4 id="CloseFuture"><a href="#CloseFuture" class="headerlink" title="CloseFuture"></a>CloseFuture</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CloseFutureClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        NioEventLoopGroup group <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                .group(group)</span><br><span class="line">                .channel(NioSocketChannel.class)</span><br><span class="line">                .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">                    <span class="meta">@Override</span> <span class="comment">// 在连接建立后被调用</span></span><br><span class="line">                    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                        ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)</span><br><span class="line">                .connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>));</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> channelFuture.sync().channel();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, channel);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">            <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">&quot;q&quot;</span>.equals(line)) &#123;</span><br><span class="line">                    channel.close(); <span class="comment">// close 异步操作 1s 之后</span></span><br><span class="line"><span class="comment">//                    log.debug(&quot;处理关闭之后的操作&quot;); // 不能在这里善后</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                channel.writeAndFlush(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;input&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 CloseFuture 对象， 1) 同步处理关闭， 2) 异步处理关闭</span></span><br><span class="line">        <span class="type">ChannelFuture</span> <span class="variable">closeFuture</span> <span class="operator">=</span> channel.closeFuture();</span><br><span class="line">        <span class="comment">/*log.debug(&quot;waiting close...&quot;);</span></span><br><span class="line"><span class="comment">        closeFuture.sync();</span></span><br><span class="line"><span class="comment">        log.debug(&quot;处理关闭之后的操作&quot;);*/</span></span><br><span class="line">        closeFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;处理关闭之后的操作&quot;</span>);</span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="💡-异步提升的是什么"><a href="#💡-异步提升的是什么" class="headerlink" title="💡 异步提升的是什么"></a>💡 异步提升的是什么</h4><ul>
<li><p>有些同学看到这里会有疑问：为什么不在一个线程中去执行建立连接、去执行关闭 channel，那样不是也可以吗？非要用这么复杂的异步方式：比如一个线程发起建立连接，另一个线程去真正建立连接</p>
</li>
<li><p>还有同学会笼统地回答，因为 netty 异步方式用了多线程、多线程就效率高。其实这些认识都比较片面，多线程和异步所提升的效率并不是所认为的</p>
</li>
</ul>
<p>思考下面的场景，4 个医生给人看病，每个病人花费 20 分钟，而且医生看病的过程中是以病人为单位的，一个病人看完了，才能看下一个病人。假设病人源源不断地来，可以计算一下 4 个医生一天工作 8 小时，处理的病人总数是：<code>4 * 8 * 3 = 96</code></p>
<p><img src="../../../images/0044.png" alt=""></p>
<p>经研究发现，看病可以细分为四个步骤，经拆分后每个步骤需要 5 分钟，如下</p>
<p><img src="../../../images/0048.png" alt=""></p>
<p>因此可以做如下优化，只有一开始，医生 2、3、4 分别要等待 5、10、15 分钟才能执行工作，但只要后续病人源源不断地来，他们就能够满负荷工作，并且处理病人的能力提高到了 <code>4 * 8 * 12</code> 效率几乎是原来的四倍</p>
<p><img src="../../../images/0047.png" alt=""></p>
<p>要点</p>
<ul>
<li>单线程没法异步提高效率，必须配合多线程、多核 cpu 才能发挥异步的优势</li>
<li>异步并没有缩短响应时间，反而有所增加</li>
<li>合理进行任务拆分，也是利用异步的关键</li>
</ul>
<h3 id="3-3-Future-amp-Promise"><a href="#3-3-Future-amp-Promise" class="headerlink" title="3.3 Future &amp; Promise"></a>3.3 Future &amp; Promise</h3><p>在异步处理时，经常用到这两个接口</p>
<p>首先要说明 netty 中的 Future 与 jdk 中的 Future 同名，但是是两个接口，netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展</p>
<ul>
<li>jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果</li>
<li>netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但都是要等任务结束</li>
<li>netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，只作为两个线程间传递结果的容器</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>功能/名称</th>
<th>jdk Future</th>
<th>netty Future</th>
<th>Promise</th>
</tr>
</thead>
<tbody>
<tr>
<td>cancel</td>
<td>取消任务</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>isCanceled</td>
<td>任务是否取消</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>isDone</td>
<td>任务是否完成，不能区分成功失败</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>get</td>
<td>获取任务结果，阻塞等待</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>getNow</td>
<td>-</td>
<td>获取任务结果，非阻塞，还未产生结果时返回 null</td>
<td>-</td>
</tr>
<tr>
<td>await</td>
<td>-</td>
<td>等待任务结束，如果任务失败，不会抛异常，而是通过 isSuccess 判断</td>
<td>-</td>
</tr>
<tr>
<td>sync</td>
<td>-</td>
<td>等待任务结束，如果任务失败，抛出异常</td>
<td>-</td>
</tr>
<tr>
<td>isSuccess</td>
<td>-</td>
<td>判断任务是否成功</td>
<td>-</td>
</tr>
<tr>
<td>cause</td>
<td>-</td>
<td>获取失败信息，非阻塞，如果没有失败，返回null</td>
<td>-</td>
</tr>
<tr>
<td>addLinstener</td>
<td>-</td>
<td>添加回调，异步接收结果</td>
<td>-</td>
</tr>
<tr>
<td>setSuccess</td>
<td>-</td>
<td>-</td>
<td>设置成功结果</td>
</tr>
<tr>
<td>setFailure</td>
<td>-</td>
<td>-</td>
<td>设置失败结果</td>
</tr>
</tbody>
</table>
</div>
<h4 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h4><p>同步处理任务成功</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DefaultEventLoop</span> <span class="variable">eventExecutors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoop</span>();</span><br><span class="line">DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class="line"></span><br><span class="line">eventExecutors.execute(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    log.debug(<span class="string">&quot;set success, &#123;&#125;&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    promise.setSuccess(<span class="number">10</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,promise.getNow()); <span class="comment">// 还没有结果</span></span><br><span class="line">log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,promise.get());</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class="line">11:51:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null</span><br><span class="line">11:51:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10</span><br><span class="line">11:51:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - 10</span><br></pre></td></tr></table></figure>
<h4 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h4><p>异步处理任务成功</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DefaultEventLoop</span> <span class="variable">eventExecutors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoop</span>();</span><br><span class="line">DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置回调，异步接收结果</span></span><br><span class="line">promise.addListener(future -&gt; &#123;</span><br><span class="line">    <span class="comment">// 这里的 future 就是上面的 promise</span></span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,future.getNow());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待 1000 后设置成功结果</span></span><br><span class="line">eventExecutors.execute(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    log.debug(<span class="string">&quot;set success, &#123;&#125;&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    promise.setSuccess(<span class="number">10</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&quot;start...&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">11:49:30 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class="line">11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set success, 10</span><br><span class="line">11:49:31 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - 10</span><br></pre></td></tr></table></figure>
<h4 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h4><p>同步处理任务失败 - sync &amp; get</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DefaultEventLoop</span> <span class="variable">eventExecutors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoop</span>();</span><br><span class="line">        DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class="line"></span><br><span class="line">        eventExecutors.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;error...&quot;</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;set failure, &#123;&#125;&quot;</span>, e.toString());</span><br><span class="line">            promise.setFailure(e);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, promise.getNow());</span><br><span class="line">        promise.get(); <span class="comment">// sync() 也会出现异常，只是 get 会再用 ExecutionException 包一层异常</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class="line">12:11:07 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null</span><br><span class="line">12:11:08 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...</span><br><span class="line">Exception in thread &quot;main&quot; java.util.concurrent.ExecutionException: java.lang.RuntimeException: error...</span><br><span class="line">	at io.netty.util.concurrent.AbstractFuture.get(AbstractFuture.java:41)</span><br><span class="line">	at com.itcast.oio.DefaultPromiseTest2.main(DefaultPromiseTest2.java:34)</span><br><span class="line">Caused by: java.lang.RuntimeException: error...</span><br><span class="line">	at com.itcast.oio.DefaultPromiseTest2.lambda$main$0(DefaultPromiseTest2.java:27)</span><br><span class="line">	at io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)</span><br><span class="line">	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class="line">	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class="line">	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:745)</span><br></pre></td></tr></table></figure>
<h4 id="例4"><a href="#例4" class="headerlink" title="例4"></a>例4</h4><p>同步处理任务失败 - await</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DefaultEventLoop</span> <span class="variable">eventExecutors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoop</span>();</span><br><span class="line">DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class="line"></span><br><span class="line">eventExecutors.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;error...&quot;</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;set failure, &#123;&#125;&quot;</span>, e.toString());</span><br><span class="line">    promise.setFailure(e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, promise.getNow());</span><br><span class="line">promise.await(); <span class="comment">// 与 sync 和 get 区别在于，不会抛异常</span></span><br><span class="line">log.debug(<span class="string">&quot;result &#123;&#125;&quot;</span>, (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class="line">12:18:53 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - null</span><br><span class="line">12:18:54 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...</span><br><span class="line">12:18:54 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error...</span><br></pre></td></tr></table></figure>
<h4 id="例5"><a href="#例5" class="headerlink" title="例5"></a>例5</h4><p>异步处理任务失败</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DefaultEventLoop</span> <span class="variable">eventExecutors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoop</span>();</span><br><span class="line">DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class="line"></span><br><span class="line">promise.addListener(future -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;result &#123;&#125;&quot;</span>, (promise.isSuccess() ? promise.getNow() : promise.cause()).toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">eventExecutors.execute(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">RuntimeException</span> <span class="variable">e</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;error...&quot;</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;set failure, &#123;&#125;&quot;</span>, e.toString());</span><br><span class="line">    promise.setFailure(e);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">log.debug(<span class="string">&quot;start...&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12:04:57 [DEBUG] [main] c.i.o.DefaultPromiseTest2 - start...</span><br><span class="line">12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - set failure, java.lang.RuntimeException: error...</span><br><span class="line">12:04:58 [DEBUG] [defaultEventLoop-1-1] c.i.o.DefaultPromiseTest2 - result java.lang.RuntimeException: error...</span><br></pre></td></tr></table></figure>
<h4 id="例6"><a href="#例6" class="headerlink" title="例6"></a>例6</h4><p>await 死锁检查</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DefaultEventLoop</span> <span class="variable">eventExecutors</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultEventLoop</span>();</span><br><span class="line">DefaultPromise&lt;Integer&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(eventExecutors);</span><br><span class="line"></span><br><span class="line">eventExecutors.submit(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        promise.await();</span><br><span class="line">        <span class="comment">// 注意不能仅捕获 InterruptedException 异常</span></span><br><span class="line">        <span class="comment">// 否则 死锁检查抛出的 BlockingOperationException 会继续向上传播</span></span><br><span class="line">        <span class="comment">// 而提交的任务会被包装为 PromiseTask，它的 run 方法中会 catch 所有异常然后设置为 Promise 的失败结果而不会抛出</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123; </span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">eventExecutors.submit(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        promise.await();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">io.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete)</span><br><span class="line">	at io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384)</span><br><span class="line">	at io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212)</span><br><span class="line">	at com.itcast.oio.DefaultPromiseTest.lambda$main$0(DefaultPromiseTest.java:27)</span><br><span class="line">	at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)</span><br><span class="line">	at io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73)</span><br><span class="line">	at io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)</span><br><span class="line">	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class="line">	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class="line">	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:745)</span><br><span class="line">io.netty.util.concurrent.BlockingOperationException: DefaultPromise@47499c2a(incomplete)</span><br><span class="line">	at io.netty.util.concurrent.DefaultPromise.checkDeadLock(DefaultPromise.java:384)</span><br><span class="line">	at io.netty.util.concurrent.DefaultPromise.await(DefaultPromise.java:212)</span><br><span class="line">	at com.itcast.oio.DefaultPromiseTest.lambda$main$1(DefaultPromiseTest.java:36)</span><br><span class="line">	at io.netty.util.concurrent.PromiseTask$RunnableAdapter.call(PromiseTask.java:38)</span><br><span class="line">	at io.netty.util.concurrent.PromiseTask.run(PromiseTask.java:73)</span><br><span class="line">	at io.netty.channel.DefaultEventLoop.run(DefaultEventLoop.java:54)</span><br><span class="line">	at io.netty.util.concurrent.SingleThreadEventExecutor$5.run(SingleThreadEventExecutor.java:918)</span><br><span class="line">	at io.netty.util.internal.ThreadExecutorMap$2.run(ThreadExecutorMap.java:74)</span><br><span class="line">	at io.netty.util.concurrent.FastThreadLocalRunnable.run(FastThreadLocalRunnable.java:30)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:745)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="3-4-Handler-amp-Pipeline"><a href="#3-4-Handler-amp-Pipeline" class="headerlink" title="3.4 Handler &amp; Pipeline"></a>3.4 Handler &amp; Pipeline</h3><p>ChannelHandler 用来处理 Channel 上的各种事件，分为入站、出站两种。所有 ChannelHandler 被连成一串，就是 Pipeline</p>
<ul>
<li>入站处理器通常是 ChannelInboundHandlerAdapter 的子类，主要用来读取客户端数据，写回结果</li>
<li>出站处理器通常是 ChannelOutboundHandlerAdapter 的子类，主要对写回结果进行加工</li>
</ul>
<p>打个比喻，每个 Channel 是一个产品的加工车间，Pipeline 是车间中的流水线，ChannelHandler 就是流水线上的各道工序，而后面要讲的 ByteBuf 是原材料，经过很多工序的加工：先经过一道道入站工序，再经过一道道出站工序最终变成产品</p>
<p>先搞清楚顺序，服务端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">          	<span class="comment">// 添加处理器 head -&gt; h1 -&gt; h2 -&gt; h3 -&gt; h4 -&gt; h5 -&gt; h6 -&gt; tail</span></span><br><span class="line">            ch.pipeline().addLast(<span class="string">&quot;h1&quot;</span>, <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">1</span>);</span><br><span class="line">                    ctx.fireChannelRead(msg); <span class="comment">// 1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="string">&quot;h2&quot;</span>, <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">2</span>);</span><br><span class="line">                    ctx.fireChannelRead(msg); <span class="comment">// 2</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="string">&quot;h3&quot;</span>, <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">3</span>);</span><br><span class="line">                    ctx.channel().write(msg); <span class="comment">// 3, 没有额外入站处理器，不需要fireChannelRead</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="string">&quot;h4&quot;</span>, <span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class="line"><span class="params">                                  ChannelPromise promise)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">4</span>);</span><br><span class="line">                    ctx.write(msg, promise); <span class="comment">// 4</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="string">&quot;h5&quot;</span>, <span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class="line"><span class="params">                                  ChannelPromise promise)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">5</span>);</span><br><span class="line">                    ctx.write(msg, promise); <span class="comment">// 5</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            ch.pipeline().addLast(<span class="string">&quot;h6&quot;</span>, <span class="keyword">new</span> <span class="title class_">ChannelOutboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, </span></span><br><span class="line"><span class="params">                                  ChannelPromise promise)</span> &#123;</span><br><span class="line">                    System.out.println(<span class="number">6</span>);</span><br><span class="line">                    ctx.write(msg, promise); <span class="comment">// 6</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .bind(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(Channel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>)</span><br><span class="line">    .addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">        future.channel().writeAndFlush(<span class="string">&quot;hello,world&quot;</span>);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>服务器端打印：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">5</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>可以看到，ChannelInboundHandlerAdapter 是按照 addLast 的顺序执行的，而 ChannelOutboundHandlerAdapter 是按照 addLast 的逆序执行的。ChannelPipeline 的实现是一个 ChannelHandlerContext（包装了 ChannelHandler） 组成的双向链表</p>
<p><img src="../../../images/0008.png" style="zoom:67%;" /></p>
<ul>
<li>入站处理器中，ctx.fireChannelRead(msg) 是 <strong>调用下一个入站处理器</strong><ul>
<li>如果注释掉 1 处代码，则仅会打印 1</li>
<li>如果注释掉 2 处代码，则仅会打印 1 2</li>
</ul>
</li>
<li>3 处的 ctx.channel().write(msg) 会 <strong>从尾部开始触发</strong> 后续出站处理器的执行<ul>
<li>如果注释掉 3 处代码，则仅会打印 1 2 3</li>
</ul>
</li>
<li>类似的，出站处理器中，ctx.write(msg, promise) 的调用也会 <strong>触发上一个出站处理器</strong><ul>
<li>如果注释掉 6 处代码，则仅会打印 1 2 3 6</li>
</ul>
</li>
<li>ctx.channel().write(msg) vs ctx.write(msg)<ul>
<li>都是触发出站处理器的执行</li>
<li>ctx.channel().write(msg) 从尾部开始查找出站处理器</li>
<li>ctx.write(msg) 是从当前节点找上一个出站处理器</li>
<li>3 处的 ctx.channel().write(msg) 如果改为 ctx.write(msg) 仅会打印 1 2 3，因为节点3 之前没有其它出站处理器了</li>
<li>6 处的 ctx.write(msg, promise) 如果改为 ctx.channel().write(msg) 会打印 1 2 3 6 6 6… 因为 ctx.channel().write() 是从尾部开始查找，结果又是节点6 自己</li>
</ul>
</li>
</ul>
<p>图1 - 服务端 pipeline 触发的原始流程，图中数字代表了处理步骤的先后次序</p>
<p><img src="../../../images/0009.png" alt=""></p>
<h3 id="3-5-ByteBuf"><a href="#3-5-ByteBuf" class="headerlink" title="3.5 ByteBuf"></a>3.5 ByteBuf</h3><p>是对字节数据的封装</p>
<h4 id="1）创建"><a href="#1）创建" class="headerlink" title="1）创建"></a>1）创建</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>
<p>上面代码创建了一个默认的 ByteBuf（池化基于直接内存的 ByteBuf），初始容量是 10</p>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read index:0 write index:0 capacity:10</span><br></pre></td></tr></table></figure>
<p>其中 log 方法参考如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">log</span><span class="params">(ByteBuf buffer)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> buffer.readableBytes();</span><br><span class="line">    <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> length / <span class="number">16</span> + (length % <span class="number">15</span> == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>) + <span class="number">4</span>;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">buf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(rows * <span class="number">80</span> * <span class="number">2</span>)</span><br><span class="line">        .append(<span class="string">&quot;read index:&quot;</span>).append(buffer.readerIndex())</span><br><span class="line">        .append(<span class="string">&quot; write index:&quot;</span>).append(buffer.writerIndex())</span><br><span class="line">        .append(<span class="string">&quot; capacity:&quot;</span>).append(buffer.capacity())</span><br><span class="line">        .append(NEWLINE);</span><br><span class="line">    appendPrettyHexDump(buf, buffer);</span><br><span class="line">    System.out.println(buf.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2）直接内存-vs-堆内存"><a href="#2）直接内存-vs-堆内存" class="headerlink" title="2）直接内存 vs 堆内存"></a>2）直接内存 vs 堆内存</h4><p>可以使用下面的代码来创建池化基于堆的 ByteBuf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.heapBuffer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>也可以使用下面的代码来创建池化基于直接内存的 ByteBuf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.directBuffer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li>
<li>直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</li>
</ul>
<h4 id="3）池化-vs-非池化"><a href="#3）池化-vs-非池化" class="headerlink" title="3）池化 vs 非池化"></a>3）池化 vs 非池化</h4><p>池化的最大意义在于可以重用 ByteBuf，优点有</p>
<ul>
<li>没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力</li>
<li>有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</li>
<li>高并发时，池化功能更节约内存，减少内存溢出的可能</li>
</ul>
<p>池化功能是否开启，可以通过下面的系统环境变量来设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">-Dio.netty.allocator.type=&#123;unpooled|pooled&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>4.1 以后，非 Android 平台默认启用池化实现，Android 平台启用非池化实现</li>
<li>4.1 之前，池化功能还不成熟，默认是非池化实现</li>
</ul>
<h4 id="4）组成"><a href="#4）组成" class="headerlink" title="4）组成"></a>4）组成</h4><p>ByteBuf 由四部分组成</p>
<p><img src="../../../images/0010.png" alt=""></p>
<p>最开始读写指针都在 0 位置</p>
<h4 id="5）写入"><a href="#5）写入" class="headerlink" title="5）写入"></a>5）写入</h4><p>方法列表，省略一些不重要的方法</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法签名</th>
<th>含义</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>writeBoolean(boolean value)</td>
<td>写入 boolean 值</td>
<td>用一字节 01\</td>
<td>00 代表 true\</td>
<td>false</td>
</tr>
<tr>
<td>writeByte(int value)</td>
<td>写入 byte 值</td>
<td></td>
</tr>
<tr>
<td>writeShort(int value)</td>
<td>写入 short 值</td>
<td></td>
</tr>
<tr>
<td>writeInt(int value)</td>
<td>写入 int 值</td>
<td>Big Endian，即 0x250，写入后 00 00 02 50</td>
</tr>
<tr>
<td>writeIntLE(int value)</td>
<td>写入 int 值</td>
<td>Little Endian，即 0x250，写入后 50 02 00 00</td>
</tr>
<tr>
<td>writeLong(long value)</td>
<td>写入 long 值</td>
<td></td>
</tr>
<tr>
<td>writeChar(int value)</td>
<td>写入 char 值</td>
<td></td>
</tr>
<tr>
<td>writeFloat(float value)</td>
<td>写入 float 值</td>
<td></td>
</tr>
<tr>
<td>writeDouble(double value)</td>
<td>写入 double 值</td>
<td></td>
</tr>
<tr>
<td>writeBytes(ByteBuf src)</td>
<td>写入 netty 的 ByteBuf</td>
<td></td>
</tr>
<tr>
<td>writeBytes(byte[] src)</td>
<td>写入 byte[]</td>
<td></td>
</tr>
<tr>
<td>writeBytes(ByteBuffer src)</td>
<td>写入 nio 的 ByteBuffer</td>
<td></td>
</tr>
<tr>
<td>int writeCharSequence(CharSequence sequence, Charset charset)</td>
<td>写入字符串</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>注意</p>
<ul>
<li>这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用</li>
<li>网络传输，默认习惯是 Big Endian</li>
</ul>
</blockquote>
<p>先写入 4 个字节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>
<p>结果是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read index:0 write index:4 capacity:10</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<p>再写入一个 int 整数，也是 4 个字节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer.writeInt(<span class="number">5</span>);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>
<p>结果是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read index:0 write index:8 capacity:10</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 00 00 00 05                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<p>还有一类方法是 set 开头的一系列方法，也可以写入数据，但不会改变写指针位置</p>
<h4 id="6）扩容"><a href="#6）扩容" class="headerlink" title="6）扩容"></a>6）扩容</h4><p>再写入一个 int 整数时，容量不够了（初始容量是 10），这时会引发扩容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer.writeInt(<span class="number">6</span>);</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>
<p>扩容规则是</p>
<ul>
<li>如何写入后数据大小未超过 512，则选择下一个 16 的整数倍，例如写入后大小为 12 ，则扩容后 capacity 是 16</li>
<li>如果写入后数据大小超过 512，则选择下一个 2^n，例如写入后大小为 513，则扩容后 capacity 是 2^10=1024（2^9=512 已经不够了）</li>
<li>扩容不能超过 max capacity 会报错</li>
</ul>
<p>结果是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read index:0 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 00 00 00 05 00 00 00 06             |............    |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<h4 id="7）读取"><a href="#7）读取" class="headerlink" title="7）读取"></a>7）读取</h4><p>例如读了 4 次，每次一个字节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">System.out.println(buffer.readByte());</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>
<p>读过的内容，就属于废弃部分了，再读只能读那些尚未读取的部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">read index:4 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 05 00 00 00 06                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<p>如果需要重复读取 int 整数 5，怎么办？</p>
<p>可以在 read 前先做个标记 mark</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer.markReaderIndex();</span><br><span class="line">System.out.println(buffer.readInt());</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">read index:8 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 06                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<p>这时要重复读取的话，重置到标记位置 reset</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buffer.resetReaderIndex();</span><br><span class="line">log(buffer);</span><br></pre></td></tr></table></figure>
<p>这时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">read index:4 write index:12 capacity:16</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 05 00 00 00 06                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<p>还有种办法是采用 get 开头的一系列方法，这些方法不会改变 read index</p>
<h4 id="8）retain-amp-release"><a href="#8）retain-amp-release" class="headerlink" title="8）retain &amp; release"></a>8）retain &amp; release</h4><p>由于 Netty 中有堆外内存的 ByteBuf 实现，堆外内存最好是手动来释放，而不是等 GC 垃圾回收。</p>
<ul>
<li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可</li>
<li>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</li>
<li>PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存</li>
</ul>
<blockquote>
<p>回收内存的源码实现，请关注下面方法的不同实现</p>
<p><code>protected abstract void deallocate()</code></p>
</blockquote>
<p>Netty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口</p>
<ul>
<li>每个 ByteBuf 对象的初始计数为 1</li>
<li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li>
<li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收</li>
<li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li>
</ul>
<p>谁来负责 release 呢？</p>
<p>不是我们想象的（一般情况下）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ...</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    buf.release();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请思考，因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在 finally 中 release 了，就失去了传递性（当然，如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）</p>
<p>基本规则是，<strong>谁是最后使用者，谁负责 release</strong>，详细分析如下</p>
<ul>
<li>起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）</li>
<li>入站 ByteBuf 处理原则<ul>
<li>对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release</li>
<li>将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release</li>
<li>如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release</li>
<li>注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</li>
<li>假设消息一直向后传，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）</li>
</ul>
</li>
<li>出站 ByteBuf 处理原则<ul>
<li>出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release</li>
</ul>
</li>
<li>异常处理原则<ul>
<li>有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以循环调用 release 直到返回 true</li>
</ul>
</li>
</ul>
<p>TailContext 释放未处理消息逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// io.netty.channel.DefaultChannelPipeline#onUnhandledInboundMessage(java.lang.Object)</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onUnhandledInboundMessage</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        logger.debug(</span><br><span class="line">            <span class="string">&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. &quot;</span> +</span><br><span class="line">            <span class="string">&quot;Please check your pipeline configuration.&quot;</span>, msg);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ReferenceCountUtil.release(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// io.netty.util.ReferenceCountUtil#release(java.lang.Object)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(Object msg)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (msg <span class="keyword">instanceof</span> ReferenceCounted) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((ReferenceCounted) msg).release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="9）slice"><a href="#9）slice" class="headerlink" title="9）slice"></a>9）slice</h4><p>【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存，切片后的 ByteBuf 维护独立的 read，write 指针</p>
<p><img src="../../../images/0011.png" alt=""></p>
<p>例，原始 ByteBuf 进行一些初始操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">origin</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line">origin.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">origin.readByte();</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 04                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<p>这时调用 slice 进行切片，无参 slice 是从原始 ByteBuf 的 read index 到 write index 之间的内容进行切片，切片后的 max capacity 被固定为这个区间的大小，因此不能追加 write</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">slice</span> <span class="operator">=</span> origin.slice();</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br><span class="line"><span class="comment">// slice.writeByte(5); 如果执行，会报 IndexOutOfBoundsException 异常</span></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 04                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<p>如果原始 ByteBuf 再次读操作（又读了一个字节）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">origin.readByte();</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 03 04                                           |..              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<p>这时的 slice 不受影响，因为它有独立的读写指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 04                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<p>如果 slice 的内容发生了更改</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">slice.setByte(<span class="number">2</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(slice));</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 02 03 05                                        |...             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<p>这时，原始 ByteBuf 也会受影响，因为底层都是同一块内存</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System.out.println(ByteBufUtil.prettyHexDump(origin));</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 03 05                                           |..              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<h4 id="10）duplicate"><a href="#10）duplicate" class="headerlink" title="10）duplicate"></a>10）duplicate</h4><p>【零拷贝】的体现之一，就好比截取了原始 ByteBuf 所有内容，并且没有 max capacity 的限制，也是与原始 ByteBuf 使用同一块底层内存，只是读写指针是独立的</p>
<p><img src="../../../images/0012.png" alt=""></p>
<h4 id="11）copy"><a href="#11）copy" class="headerlink" title="11）copy"></a>11）copy</h4><p>会将底层内存数据进行深拷贝，因此无论读写，都与原始 ByteBuf 无关</p>
<h4 id="12）CompositeByteBuf"><a href="#12）CompositeByteBuf" class="headerlink" title="12）CompositeByteBuf"></a>12）CompositeByteBuf</h4><p>【零拷贝】的体现之一，可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免拷贝</p>
<p>有两个 ByteBuf 如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf1</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf1.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf2</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf2.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf1));</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf2));</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05                                  |.....           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 06 07 08 09 0a                                  |.....           |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<p>现在需要一个新的 ByteBuf，内容来自于刚才的 buf1 和 buf2，如何实现？</p>
<p>方法1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf3</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(buf1.readableBytes()+buf2.readableBytes());</span><br><span class="line">buf3.writeBytes(buf1);</span><br><span class="line">buf3.writeBytes(buf2);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf3));</span><br></pre></td></tr></table></figure>
<p>结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<p>这种方法好不好？回答是不太好，因为进行了数据的内存复制操作</p>
<p>方法2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">CompositeByteBuf</span> <span class="variable">buf3</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.compositeBuffer();</span><br><span class="line"><span class="comment">// true 表示增加新的 ByteBuf 自动递增 write index, 否则 write index 会始终为 0</span></span><br><span class="line">buf3.addComponents(<span class="literal">true</span>, buf1, buf2);</span><br></pre></td></tr></table></figure>
<p>结果是一样的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<p>CompositeByteBuf 是一个组合的 ByteBuf，它内部维护了一个 Component 数组，每个 Component 管理一个 ByteBuf，记录了这个 ByteBuf 相对于整体偏移量等信息，代表着整体中某一段的数据。</p>
<ul>
<li>优点，对外是一个虚拟视图，组合这些 ByteBuf 不会产生内存复制</li>
<li>缺点，复杂了很多，多次操作会带来性能的损耗</li>
</ul>
<h4 id="13）Unpooled"><a href="#13）Unpooled" class="headerlink" title="13）Unpooled"></a>13）Unpooled</h4><p>Unpooled 是一个工具类，类如其名，提供了非池化的 ByteBuf 创建、组合、复制等操作</p>
<p>这里仅介绍其跟【零拷贝】相关的 wrappedBuffer 方法，可以用来包装 ByteBuf</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf1</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf1.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf2</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="number">5</span>);</span><br><span class="line">buf2.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当包装 ByteBuf 个数超过一个时, 底层使用了 CompositeByteBuf</span></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf3</span> <span class="operator">=</span> Unpooled.wrappedBuffer(buf1, buf2);</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf3));</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06 07 08 09 0a                   |..........      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<p>也可以用来包装普通字节数组，底层也不会有拷贝操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf4</span> <span class="operator">=</span> Unpooled.wrappedBuffer(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;, <span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;);</span><br><span class="line">System.out.println(buf4.getClass());</span><br><span class="line">System.out.println(ByteBufUtil.prettyHexDump(buf4));</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class io.netty.buffer.CompositeByteBuf</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 01 02 03 04 05 06                               |......          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br></pre></td></tr></table></figure>
<h4 id="💡-ByteBuf-优势"><a href="#💡-ByteBuf-优势" class="headerlink" title="💡 ByteBuf 优势"></a>💡 ByteBuf 优势</h4><ul>
<li>池化 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li>
<li>读写指针分离，不需要像 ByteBuffer 一样切换读写模式</li>
<li>可以自动扩容</li>
<li>支持链式调用，使用更流畅</li>
<li>很多地方体现零拷贝，例如 slice、duplicate、CompositeByteBuf</li>
</ul>
<h2 id="4-双向通信"><a href="#4-双向通信" class="headerlink" title="4. 双向通信"></a>4. 双向通信</h2><h3 id="4-1-练习"><a href="#4-1-练习" class="headerlink" title="4.1 练习"></a>4.1 练习</h3><p>实现一个 echo server</p>
<p>编写 server</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>()</span><br><span class="line">    .group(<span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>())</span><br><span class="line">    .channel(NioServerSocketChannel.class)</span><br><span class="line">    .childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>()&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                    System.out.println(buffer.toString(Charset.defaultCharset()));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 建议使用 ctx.alloc() 创建 ByteBuf</span></span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">response</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                    response.writeBytes(buffer);</span><br><span class="line">                    ctx.writeAndFlush(response);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 思考：需要释放 buffer 吗</span></span><br><span class="line">                    <span class="comment">// 思考：需要释放 response 吗</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).bind(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>
<p>编写 client</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">    .group(group)</span><br><span class="line">    .channel(NioSocketChannel.class)</span><br><span class="line">    .handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">StringEncoder</span>());</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                    System.out.println(buffer.toString(Charset.defaultCharset()));</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 思考：需要释放 buffer 吗</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>).sync().channel();</span><br><span class="line"></span><br><span class="line">channel.closeFuture().addListener(future -&gt; &#123;</span><br><span class="line">    group.shutdownGracefully();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;q&quot;</span>.equals(line)) &#123;</span><br><span class="line">            channel.close();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        channel.writeAndFlush(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<h3 id="💡-读和写的误解"><a href="#💡-读和写的误解" class="headerlink" title="💡 读和写的误解"></a>💡 读和写的误解</h3><p>我最初在认识上有这样的误区，认为只有在 netty，nio 这样的多路复用 IO 模型时，读写才不会相互阻塞，才可以实现高效的双向通信，但实际上，Java Socket 是全双工的：在任意时刻，线路上存在<code>A 到 B</code> 和 <code>B 到 A</code> 的双向信号传输。即使是阻塞 IO，读和写是可以同时进行的，只要分别采用读线程和写线程即可，读不会阻塞写、写也不会阻塞读</p>
<p>例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> ss.accept();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(s.getInputStream()));</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    System.out.println(reader.readLine());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(s.getOutputStream()));</span><br><span class="line">                <span class="comment">// 例如在这个位置加入 thread 级别断点，可以发现即使不写入数据，也不妨碍前面线程读取客户端数据</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    writer.write(String.valueOf(i));</span><br><span class="line">                    writer.newLine();</span><br><span class="line">                    writer.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">BufferedReader</span> <span class="variable">reader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(s.getInputStream()));</span><br><span class="line">                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                    System.out.println(reader.readLine());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">BufferedWriter</span> <span class="variable">writer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(s.getOutputStream()));</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                    writer.write(String.valueOf(i));</span><br><span class="line">                    writer.newLine();</span><br><span class="line">                    writer.flush();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty(三) 进阶，粘包半包，协议设计</title>
    <url>/posts/1386.html</url>
    <content><![CDATA[<h1 id="三-Netty-进阶"><a href="#三-Netty-进阶" class="headerlink" title="三. Netty 进阶"></a>三. Netty 进阶</h1><h2 id="1-粘包与半包"><a href="#1-粘包与半包" class="headerlink" title="1. 粘包与半包"></a>1. 粘包与半包</h2><h3 id="1-1-粘包现象"><a href="#1-1-粘包现象" class="headerlink" title="1.1 粘包现象"></a>1.1 粘包现象</h3><p>服务端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldServer</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldServer.class);</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;connected &#123;&#125;&quot;</span>, ctx.channel());</span><br><span class="line">                            <span class="built_in">super</span>.channelActive(ctx);</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelInactive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;disconnect &#123;&#125;&quot;</span>, ctx.channel());</span><br><span class="line">                            <span class="built_in">super</span>.channelInactive(ctx);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">8080</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;&#123;&#125; binding...&quot;</span>, channelFuture.channel());</span><br><span class="line">            channelFuture.sync();</span><br><span class="line">            log.debug(<span class="string">&quot;&#123;&#125; bound...&quot;</span>, channelFuture.channel());</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;server error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">            log.debug(<span class="string">&quot;stoped&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">HelloWorldServer</span>().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端代码希望发送 10 个消息，每个消息是 16 字节</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;connetted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">                            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                                buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;);</span><br><span class="line">                                ctx.writeAndFlush(buffer);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器端的某次输出，可以看到一次就接收了 160 个字节，而非分 10 次接收</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5] binding...</span><br><span class="line">08:24:46 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x81e0fda5, L:/0:0:0:0:0:0:0:0:8080] bound...</span><br><span class="line">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] REGISTERED</span><br><span class="line">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] ACTIVE</span><br><span class="line">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177]</span><br><span class="line">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ: 160B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000020| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000030| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000040| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000050| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000060| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000070| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000080| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000090| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">08:24:55 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x94132411, L:/127.0.0.1:8080 - R:/127.0.0.1:58177] READ COMPLETE</span><br></pre></td></tr></table></figure>
<h3 id="1-2-半包现象"><a href="#1-2-半包现象" class="headerlink" title="1.2 半包现象"></a>1.2 半包现象</h3><p>客户端代码希望发送 1 个消息，这个消息是 160 字节，代码改为</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;);</span><br><span class="line">&#125;</span><br><span class="line">ctx.writeAndFlush(buffer);</span><br></pre></td></tr></table></figure>
<p>为现象明显，服务端修改一下接收缓冲区，其它代码不变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">serverBootstrap.option(ChannelOption.SO_RCVBUF, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>服务器端的某次输出，可以看到接收的消息被分为两节，第一次 20 字节，第二次 140 字节</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84] binding...</span><br><span class="line">08:43:49 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0x4d6c6a84, L:/0:0:0:0:0:0:0:0:8080] bound...</span><br><span class="line">08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] REGISTERED</span><br><span class="line">08:44:23 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] ACTIVE</span><br><span class="line">08:44:23 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221]</span><br><span class="line">08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 20B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="line">|00000010| 00 01 02 03                                     |....            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE</span><br><span class="line">08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ: 140B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000020| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000030| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000040| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000050| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000060| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000070| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|</span><br><span class="line">|00000080| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f             |............    |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">08:44:24 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x1719abf7, L:/127.0.0.1:8080 - R:/127.0.0.1:59221] READ COMPLETE</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong></p>
<p>serverBootstrap.option(ChannelOption.SO_RCVBUF, 10) 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 netty 读取的最小单位，netty 实际每次读取的一般是它的整数倍</p>
</blockquote>
<h3 id="1-3-现象分析"><a href="#1-3-现象分析" class="headerlink" title="1.3 现象分析"></a>1.3 现象分析</h3><p>粘包</p>
<ul>
<li>现象，发送 abc def，接收 abcdef</li>
<li>原因<ul>
<li>应用层：接收方 ByteBuf 设置太大（Netty 默认 1024）</li>
<li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且窗口大小足够大，这 256 bytes 字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会粘包</li>
<li>Nagle 算法：会造成粘包</li>
</ul>
</li>
</ul>
<p>半包</p>
<ul>
<li>现象，发送 abcdef，接收 abc def</li>
<li>原因<ul>
<li>应用层：接收方 ByteBuf 小于实际发送数据量</li>
<li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时放不下了，只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</li>
<li>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li>
</ul>
</li>
</ul>
<p>本质是因为 TCP 是流式协议，消息无边界</p>
<blockquote>
<p>滑动窗口</p>
<ul>
<li><p>TCP 以一个段（segment）为单位，每发送一个段就需要进行一次确认应答（ack）处理，但如果这么做，缺点是包的往返时间越长性能就越差</p>
<p><img src="../../../images/0049.png" alt=""></p>
</li>
</ul>
<ul>
<li><p>为了解决此问题，引入了窗口概念，窗口大小即决定了无需等待应答而可以继续发送的数据最大值</p>
<p><img src="../../../images/0051.png" alt=""></p>
</li>
<li><p>窗口实际就起到一个缓冲区的作用，同时也能起到流量控制的作用</p>
<ul>
<li>图中深色的部分即要发送的数据，高亮的部分即窗口</li>
<li>窗口内的数据才允许被发送，当应答未到达前，窗口必须停止滑动</li>
<li>如果 1001~2000 这个段的数据 ack 回来了，窗口就可以向前滑动</li>
<li>接收方也会维护一个窗口，只有落在窗口内的数据才能允许接收</li>
</ul>
</li>
</ul>
<p> MSS 限制</p>
<ul>
<li><p>链路层对一次能够发送的最大数据有限制，这个限制称之为 MTU（maximum transmission unit），不同的链路设备的 MTU 值也有所不同，例如</p>
<ul>
<li>以太网的 MTU 是 1500</li>
<li>FDDI（光纤分布式数据接口）的 MTU 是 4352</li>
<li>本地回环地址的 MTU 是 65535 - 本地测试不走网卡</li>
</ul>
</li>
<li><p>MSS 是最大段长度（maximum segment size），它是 MTU 刨去 tcp 头和 ip 头后剩余能够作为数据传输的字节数</p>
<ul>
<li>ipv4 tcp 头占用 20 bytes，ip 头占用 20 bytes，因此以太网 MSS 的值为 1500 - 40 = 1460</li>
<li>TCP 在传递大量数据时，会按照 MSS 大小将数据进行分割发送</li>
<li>MSS 的值在三次握手时通知对方自己 MSS 的值，然后在两者之间选择一个小值作为 MSS</li>
</ul>
<p><img src="../../../images/0031.jpg" style="zoom:0%;" /></p>
</li>
</ul>
<p>Nagle 算法</p>
<ul>
<li>即使发送一个字节，也需要加入 tcp 头和 ip 头，也就是总字节数会使用 41 bytes，非常不经济。因此为了提高网络利用率，tcp 希望尽可能发送足够大的数据，这就是 Nagle 算法产生的缘由</li>
<li>该算法是指发送端即使还有应该发送的数据，但如果这部分数据很少的话，则进行延迟发送<ul>
<li>如果 SO_SNDBUF 的数据达到 MSS，则需要发送</li>
<li>如果 SO_SNDBUF 中含有 FIN（表示需要连接关闭）这时将剩余数据发送，再关闭</li>
<li>如果 TCP_NODELAY = true，则需要发送</li>
<li>已发送的数据都收到 ack 时，则需要发送</li>
<li>上述条件不满足，但发生超时（一般为 200ms）则需要发送</li>
<li>除上述情况，延迟发送</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="1-4-解决方案"><a href="#1-4-解决方案" class="headerlink" title="1.4 解决方案"></a>1.4 解决方案</h3><ol>
<li>短链接，发一个包建立一次连接，这样连接建立到连接断开之间就是消息的边界，缺点效率太低</li>
<li>每一条消息采用固定长度，缺点浪费空间</li>
<li>每一条消息采用分隔符，例如 \n，缺点需要转义</li>
<li>每一条消息分为 head 和 body，head 中包含 body 的长度</li>
</ol>
<h4 id="方法1，短链接"><a href="#方法1，短链接" class="headerlink" title="方法1，短链接"></a>方法1，短链接</h4><p>以解决粘包为例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 分 10 次发送</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">send</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;conneted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                            buffer.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;);</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                            <span class="comment">// 发完即关</span></span><br><span class="line">                            ctx.close();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出，略</p>
<blockquote>
<p>半包用这种办法还是不好解决，因为接收方的缓冲区大小是有限的</p>
</blockquote>
<h4 id="方法2，固定长度"><a href="#方法2，固定长度" class="headerlink" title="方法2，固定长度"></a>方法2，固定长度</h4><p>让所有数据包长度固定（假设长度为 8 字节），服务器端加入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">FixedLengthFrameDecoder</span>(<span class="number">8</span>));</span><br></pre></td></tr></table></figure>
<p>客户端测试代码，注意, 采用这种方法后，客户端什么时候 flush 都可以</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;connetted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            <span class="comment">// 发送内容随机的数据包</span></span><br><span class="line">                            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">                            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">8</span>];</span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; r.nextInt(<span class="number">8</span>); j++) &#123;</span><br><span class="line">                                    bytes[j] = (<span class="type">byte</span>) c;</span><br><span class="line">                                &#125;</span><br><span class="line">                                c++;</span><br><span class="line">                                buffer.writeBytes(bytes);</span><br><span class="line">                            &#125;</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;192.168.0.103&quot;</span>, <span class="number">9090</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] REGISTERED</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2] CONNECT: /192.168.0.103:9090</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] ACTIVE</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] WRITE: 80B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 61 61 61 00 00 00 00 62 00 00 00 00 00 00 00 |aaaa....b.......|</span><br><span class="line">|00000010| 63 63 00 00 00 00 00 00 64 00 00 00 00 00 00 00 |cc......d.......|</span><br><span class="line">|00000020| 00 00 00 00 00 00 00 00 66 66 66 66 00 00 00 00 |........ffff....|</span><br><span class="line">|00000030| 67 67 67 00 00 00 00 00 68 00 00 00 00 00 00 00 |ggg.....h.......|</span><br><span class="line">|00000040| 69 69 69 69 69 00 00 00 6a 6a 6a 6a 00 00 00 00 |iiiii...jjjj....|</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x3c2ef3c2, L:/192.168.0.103:53155 - R:/192.168.0.103:9090] FLUSH</span><br></pre></td></tr></table></figure>
<p>服务端输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f] binding...</span><br><span class="line">12:06:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xe3d9713f, L:/192.168.0.103:9090] bound...</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] REGISTERED</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] ACTIVE</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155]</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 61 61 61 00 00 00 00                         |aaaa....        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 62 00 00 00 00 00 00 00                         |b.......        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 63 63 00 00 00 00 00 00                         |cc......        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 64 00 00 00 00 00 00 00                         |d.......        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 00 00 00 00 00 00 00 00                         |........        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 66 66 66 66 00 00 00 00                         |ffff....        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 67 67 67 00 00 00 00 00                         |ggg.....        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 00 00 00 00 00 00 00                         |h.......        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 69 69 69 69 69 00 00 00                         |iiiii...        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6a 6a 6a 6a 00 00 00 00                         |jjjj....        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">12:07:00 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0xd739f137, L:/192.168.0.103:9090 - R:/192.168.0.103:53155] READ COMPLETE</span><br></pre></td></tr></table></figure>
<p>缺点是，数据包的大小不好把握</p>
<ul>
<li>长度定的太大，浪费</li>
<li>长度定的太小，对某些数据包又显得不够</li>
</ul>
<h4 id="方法3，固定分隔符"><a href="#方法3，固定分隔符" class="headerlink" title="方法3，固定分隔符"></a>方法3，固定分隔符</h4><p>服务端加入，默认以 \n 或 \r\n 作为分隔符，如果超出指定长度仍未出现分隔符，则抛出异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LineBasedFrameDecoder</span>(<span class="number">1024</span>));</span><br></pre></td></tr></table></figure>
<p>客户端在每条消息之后，加入 \n 分隔符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;connetted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">                            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= r.nextInt(<span class="number">16</span>)+<span class="number">1</span>; j++) &#123;</span><br><span class="line">                                    buffer.writeByte((<span class="type">byte</span>) c);</span><br><span class="line">                                &#125;</span><br><span class="line">                                buffer.writeByte(<span class="number">10</span>);</span><br><span class="line">                                c++;</span><br><span class="line">                            &#125;</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;192.168.0.103&quot;</span>, <span class="number">9090</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] REGISTERED</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755] CONNECT: /192.168.0.103:9090</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] ACTIVE</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] WRITE: 60B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 0a 62 62 62 0a 63 63 63 0a 64 64 0a 65 65 65 |a.bbb.ccc.dd.eee|</span><br><span class="line">|00000010| 65 65 65 65 65 65 65 0a 66 66 0a 67 67 67 67 67 |eeeeeee.ff.ggggg|</span><br><span class="line">|00000020| 67 67 0a 68 68 68 68 0a 69 69 69 69 69 69 69 0a |gg.hhhh.iiiiiii.|</span><br><span class="line">|00000030| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 0a             |jjjjjjjjjjj.    |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0x1282d755, L:/192.168.0.103:63641 - R:/192.168.0.103:9090] FLUSH</span><br></pre></td></tr></table></figure>
<p>服务端输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] c.i.n.HelloWorldServer - connected [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641]</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 1B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61                                              |a               |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 62 62 62                                        |bbb             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 3B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 63 63 63                                        |ccc             |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 64 64                                           |dd              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 10B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 65 65 65 65 65 65 65 65 65 65                   |eeeeeeeeee      |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 66 66                                           |ff              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 67 67 67 67 67 67 67                            |ggggggg         |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 4B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 68 68 68                                     |hhhh            |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 7B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 69 69 69 69 69 69 69                            |iiiiiii         |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ: 11B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a 6a                |jjjjjjjjjjj     |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:08:18 [DEBUG] [nioEventLoopGroup-3-5] i.n.h.l.LoggingHandler - [id: 0xa4b3be43, L:/192.168.0.103:9090 - R:/192.168.0.103:63641] READ COMPLETE</span><br></pre></td></tr></table></figure>
<p>缺点，处理字符数据比较合适，但如果内容本身包含了分隔符（字节数据常常会有此情况），那么就会解析错误</p>
<h4 id="方法4，预设长度"><a href="#方法4，预设长度" class="headerlink" title="方法4，预设长度"></a>方法4，预设长度</h4><p>在发送消息前，先约定用定长字节表示接下来数据的长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 最大长度，长度偏移，长度占用字节，长度调整，剥离字节数</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(<span class="number">1024</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>客户端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorldClient</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Logger</span> <span class="variable">log</span> <span class="operator">=</span> LoggerFactory.getLogger(HelloWorldClient.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(worker);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;connetted...&quot;</span>);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;sending...&quot;</span>);</span><br><span class="line">                            <span class="type">Random</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">                            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                            <span class="type">ByteBuf</span> <span class="variable">buffer</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                                <span class="type">byte</span> <span class="variable">length</span> <span class="operator">=</span> (<span class="type">byte</span>) (r.nextInt(<span class="number">16</span>) + <span class="number">1</span>);</span><br><span class="line">                                <span class="comment">// 先写入长度</span></span><br><span class="line">                                buffer.writeByte(length);</span><br><span class="line">                                <span class="comment">// 再</span></span><br><span class="line">                                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= length; j++) &#123;</span><br><span class="line">                                    buffer.writeByte((<span class="type">byte</span>) c);</span><br><span class="line">                                &#125;</span><br><span class="line">                                c++;</span><br><span class="line">                            &#125;</span><br><span class="line">                            ctx.writeAndFlush(buffer);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;192.168.0.103&quot;</span>, <span class="number">9090</span>).sync();</span><br><span class="line">            channelFuture.channel().closeFuture().sync();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - connetted...</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] REGISTERED</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8] CONNECT: /192.168.0.103:9090</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] ACTIVE</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] c.i.n.HelloWorldClient - sending...</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] WRITE: 97B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 09 61 61 61 61 61 61 61 61 61 09 62 62 62 62 62 |.aaaaaaaaa.bbbbb|</span><br><span class="line">|00000010| 62 62 62 62 06 63 63 63 63 63 63 08 64 64 64 64 |bbbb.cccccc.dddd|</span><br><span class="line">|00000020| 64 64 64 64 0f 65 65 65 65 65 65 65 65 65 65 65 |dddd.eeeeeeeeeee|</span><br><span class="line">|00000030| 65 65 65 65 0d 66 66 66 66 66 66 66 66 66 66 66 |eeee.fffffffffff|</span><br><span class="line">|00000040| 66 66 02 67 67 02 68 68 0e 69 69 69 69 69 69 69 |ff.gg.hh.iiiiiii|</span><br><span class="line">|00000050| 69 69 69 69 69 69 69 09 6a 6a 6a 6a 6a 6a 6a 6a |iiiiiii.jjjjjjjj|</span><br><span class="line">|00000060| 6a                                              |j               |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-2-1] i.n.h.l.LoggingHandler - [id: 0xf0f347b8, L:/192.168.0.103:49979 - R:/192.168.0.103:9090] FLUSH</span><br></pre></td></tr></table></figure>
<p>服务端输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">14:36:50 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3] binding...</span><br><span class="line">14:36:51 [DEBUG] [main] c.i.n.HelloWorldServer - [id: 0xdff439d3, L:/192.168.0.103:9090] bound...</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] REGISTERED</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] ACTIVE</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] c.i.n.HelloWorldServer - connected [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979]</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 61 61 61 61 61 61 61 61 61                      |aaaaaaaaa       |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 62 62 62 62 62 62 62 62 62                      |bbbbbbbbb       |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 6B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 63 63 63 63 63 63                               |cccccc          |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 8B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 64 64 64 64 64 64 64 64                         |dddddddd        |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 15B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 65 65 65 65 65 65 65 65 65 65 65 65 65 65 65    |eeeeeeeeeeeeeee |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 13B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 66 66 66 66 66 66 66 66 66 66 66 66 66          |fffffffffffff   |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 67 67                                           |gg              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 2B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 68 68                                           |hh              |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 14B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 69 69 69 69 69 69 69 69 69 69 69 69 69 69       |iiiiiiiiiiiiii  |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ: 9B</span><br><span class="line">         +-------------------------------------------------+</span><br><span class="line">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">|00000000| 6a 6a 6a 6a 6a 6a 6a 6a 6a                      |jjjjjjjjj       |</span><br><span class="line">+--------+-------------------------------------------------+----------------+</span><br><span class="line">14:37:10 [DEBUG] [nioEventLoopGroup-3-1] i.n.h.l.LoggingHandler - [id: 0x744f2b47, L:/192.168.0.103:9090 - R:/192.168.0.103:49979] READ COMPLETE</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-协议设计与解析"><a href="#2-协议设计与解析" class="headerlink" title="2. 协议设计与解析"></a>2. 协议设计与解析</h2><h3 id="2-1-为什么需要协议？"><a href="#2-1-为什么需要协议？" class="headerlink" title="2.1 为什么需要协议？"></a>2.1 为什么需要协议？</h3><p>TCP/IP 中消息传输基于流的方式，没有边界。</p>
<p>协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则</p>
<p>例如：在网络上传输</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下雨天留客天留我不留</span><br></pre></td></tr></table></figure>
<p>是中文一句著名的无标点符号句子，在没有标点符号情况下，这句话有数种拆解方式，而意思却是完全不同，所以常被用作讲述标点符号的重要性</p>
<p>一种解读</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下雨天留客，天留，我不留</span><br></pre></td></tr></table></figure>
<p>另一种解读</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">下雨天，留客天，留我不？留</span><br></pre></td></tr></table></figure>
<p>如何设计协议呢？其实就是给网络传输的信息加上“标点符号”。但通过分隔符来断句不是很好，因为分隔符本身如果用于传输，那么必须加以区分。因此，下面一种协议较为常用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定长字节表示内容长度 + 实际内容</span><br></pre></td></tr></table></figure>
<p>例如，假设一个中文字符长度为 3，按照上述协议的规则，发送信息方式如下，就不会被接收方弄错意思了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0f下雨天留客06天留09我不留</span><br></pre></td></tr></table></figure>
<blockquote>
<p>小故事</p>
<p>很久很久以前，一位私塾先生到一家任教。双方签订了一纸协议：“无鸡鸭亦可无鱼肉亦可白菜豆腐不可少不得束修金”。此后，私塾先生虽然认真教课，但主人家则总是给私塾先生以白菜豆腐为菜，丝毫未见鸡鸭鱼肉的款待。私塾先生先是很不解，可是后来也就想通了：主人把鸡鸭鱼肉的钱都会换为束修金的，也罢。至此双方相安无事。</p>
<p>年关将至，一个学年段亦告结束。私塾先生临行时，也不见主人家为他交付束修金，遂与主家理论。然主家亦振振有词：“有协议为证——无鸡鸭亦可，无鱼肉亦可，白菜豆腐不可少，不得束修金。这白纸黑字明摆着的，你有什么要说的呢？”</p>
<p>私塾先生据理力争：“协议是这样的——无鸡，鸭亦可；无鱼，肉亦可；白菜豆腐不可，少不得束修金。”</p>
<p>双方唇枪舌战，你来我往，真个是不亦乐乎！</p>
<p>这里的束修金，也作“束脩”，应当是泛指教师应当得到的报酬</p>
</blockquote>
<h3 id="2-2-redis-协议举例"><a href="#2-2-redis-协议举例" class="headerlink" title="2.2 redis 协议举例"></a>2.2 redis 协议举例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="type">byte</span>[] LINE = &#123;<span class="number">13</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">    bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">    bootstrap.group(worker);</span><br><span class="line">    bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>());</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                <span class="comment">// 会在连接 channel 建立成功后，会触发 active 事件</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">                    set(ctx);</span><br><span class="line">                    get(ctx);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;*2&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;get&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;aaa&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    ctx.writeAndFlush(buf);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;*3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;set&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;aaa&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;$3&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    buf.writeBytes(<span class="string">&quot;bbb&quot;</span>.getBytes());</span><br><span class="line">                    buf.writeBytes(LINE);</span><br><span class="line">                    ctx.writeAndFlush(buf);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> (ByteBuf) msg;</span><br><span class="line">                    System.out.println(buf.toString(Charset.defaultCharset()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">6379</span>).sync();</span><br><span class="line">    channelFuture.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    worker.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-http-协议举例"><a href="#2-3-http-协议举例" class="headerlink" title="2.3 http 协议举例"></a>2.3 http 协议举例</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">NioEventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">    serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">    serverBootstrap.group(boss, worker);</span><br><span class="line">    serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG));</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">HttpServerCodec</span>());</span><br><span class="line">            ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;HttpRequest&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, HttpRequest msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    <span class="comment">// 获取请求</span></span><br><span class="line">                    log.debug(msg.uri());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 返回响应</span></span><br><span class="line">                    <span class="type">DefaultFullHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span></span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">DefaultFullHttpResponse</span>(msg.protocolVersion(), HttpResponseStatus.OK);</span><br><span class="line"></span><br><span class="line">                    <span class="type">byte</span>[] bytes = <span class="string">&quot;&lt;h1&gt;Hello, world!&lt;/h1&gt;&quot;</span>.getBytes();</span><br><span class="line"></span><br><span class="line">                    response.headers().setInt(CONTENT_LENGTH, bytes.length);</span><br><span class="line">                    response.content().writeBytes(bytes);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 写回响应</span></span><br><span class="line">                    ctx.writeAndFlush(response);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="comment">/*ch.pipeline().addLast(new ChannelInboundHandlerAdapter() &#123;</span></span><br><span class="line"><span class="comment">                @Override</span></span><br><span class="line"><span class="comment">                public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception &#123;</span></span><br><span class="line"><span class="comment">                    log.debug(&quot;&#123;&#125;&quot;, msg.getClass());</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    if (msg instanceof HttpRequest) &#123; // 请求行，请求头</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    &#125; else if (msg instanceof HttpContent) &#123; //请求体</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;</span></span><br><span class="line"><span class="comment">            &#125;);*/</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">channelFuture</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">8080</span>).sync();</span><br><span class="line">    channelFuture.channel().closeFuture().sync();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;server error&quot;</span>, e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    boss.shutdownGracefully();</span><br><span class="line">    worker.shutdownGracefully();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-自定义协议要素"><a href="#2-4-自定义协议要素" class="headerlink" title="2.4 自定义协议要素"></a>2.4 自定义协议要素</h3><ul>
<li>魔数，用来在第一时间判定是否是无效数据包</li>
<li>版本号，可以支持协议的升级</li>
<li>序列化算法，消息正文到底采用哪种序列化反序列化方式，可以由此扩展，例如：json、protobuf、hessian、jdk</li>
<li>指令类型，是登录、注册、单聊、群聊… 跟业务相关</li>
<li>请求序号，为了双工通信，提供异步能力</li>
<li>正文长度</li>
<li>消息正文</li>
</ul>
<h4 id="编解码器"><a href="#编解码器" class="headerlink" title="编解码器"></a>编解码器</h4><p>根据上面的要素，设计一个登录请求消息和登录响应消息，并使用 Netty 完成收发</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageCodec</span> <span class="keyword">extends</span> <span class="title class_">ByteToMessageCodec</span>&lt;Message&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, ByteBuf out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1. 4 字节的魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">// 2. 1 字节的版本,</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class="line">        out.writeByte(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 4. 1 字节的指令类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 5. 4 个字节</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 无意义，对齐填充</span></span><br><span class="line">        out.writeByte(<span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">// 6. 获取内容的字节数组</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(msg);</span><br><span class="line">        <span class="type">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">        <span class="comment">// 7. 长度</span></span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">// 8. 写入内容</span></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">magicNum</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">version</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">serializerType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) ois.readObject();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, magicNum, version, serializerType, messageType, sequenceId, length);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, message);</span><br><span class="line">        out.add(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">EmbeddedChannel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EmbeddedChannel</span>(</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">LengthFieldBasedFrameDecoder</span>(</span><br><span class="line">        <span class="number">1024</span>, <span class="number">12</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">MessageCodec</span>()</span><br><span class="line">);</span><br><span class="line"><span class="comment">// encode</span></span><br><span class="line"><span class="type">LoginRequestMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginRequestMessage</span>(<span class="string">&quot;zhangsan&quot;</span>, <span class="string">&quot;123&quot;</span>, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line"><span class="comment">//        channel.writeOutbound(message);</span></span><br><span class="line"><span class="comment">// decode</span></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">buf</span> <span class="operator">=</span> ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">MessageCodec</span>().encode(<span class="literal">null</span>, message, buf);</span><br><span class="line"></span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">s1</span> <span class="operator">=</span> buf.slice(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line"><span class="type">ByteBuf</span> <span class="variable">s2</span> <span class="operator">=</span> buf.slice(<span class="number">100</span>, buf.readableBytes() - <span class="number">100</span>);</span><br><span class="line">s1.retain(); <span class="comment">// 引用计数 2</span></span><br><span class="line">channel.writeInbound(s1); <span class="comment">// release 1</span></span><br><span class="line">channel.writeInbound(s2);</span><br></pre></td></tr></table></figure>
<p>解读</p>
<p><img src="../../../images/0013.png" alt=""></p>
<h4 id="💡-什么时候可以加-Sharable"><a href="#💡-什么时候可以加-Sharable" class="headerlink" title="💡 什么时候可以加 @Sharable"></a>💡 什么时候可以加 @Sharable</h4><ul>
<li>当 handler 不保存状态时，就可以安全地在多线程下被共享</li>
<li>但要注意对于编解码器类，不能继承 ByteToMessageCodec 或 CombinedChannelDuplexHandler 父类，他们的构造方法对 @Sharable 有限制</li>
<li>如果能确保编解码器不会保存状态，可以继承 MessageToMessageCodec 父类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageCodecSharable</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageCodec</span>&lt;ByteBuf, Message&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">out</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">        <span class="comment">// 1. 4 字节的魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">// 2. 1 字节的版本,</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class="line">        out.writeByte(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 4. 1 字节的指令类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 5. 4 个字节</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 无意义，对齐填充</span></span><br><span class="line">        out.writeByte(<span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">// 6. 获取内容的字节数组</span></span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(bos);</span><br><span class="line">        oos.writeObject(msg);</span><br><span class="line">        <span class="type">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">        <span class="comment">// 7. 长度</span></span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">// 8. 写入内容</span></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">        outList.add(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">magicNum</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">version</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">serializerType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line">        <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) ois.readObject();</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, magicNum, version, serializerType, messageType, sequenceId, length);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, message);</span><br><span class="line">        out.add(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-聊天室案例"><a href="#3-聊天室案例" class="headerlink" title="3. 聊天室案例"></a>3. 聊天室案例</h2><h3 id="3-1-聊天室业务介绍"><a href="#3-1-聊天室业务介绍" class="headerlink" title="3.1 聊天室业务介绍"></a>3.1 聊天室业务介绍</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户管理接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登录</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password 密码</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 登录成功返回 true, 否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">login</span><span class="params">(String username, String password)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 会话管理接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Session</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 哪个 channel 要绑定会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 会话绑定用户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Channel channel, String username)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解绑会话</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 哪个 channel 要解绑会话</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unbind</span><span class="params">(Channel channel)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 哪个 channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 属性名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 属性值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Object <span class="title function_">getAttribute</span><span class="params">(Channel channel, String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置属性</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> channel 哪个 channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 属性名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 属性值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setAttribute</span><span class="params">(Channel channel, String name, Object value)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据用户名获取 channel</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> channel</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Channel <span class="title function_">getChannel</span><span class="params">(String username)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 聊天组会话管理接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GroupSession</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> members 成员</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成功时返回组对象, 失败返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Group <span class="title function_">createGroup</span><span class="params">(String name, Set&lt;String&gt; members)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加入聊天组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> member 成员名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Group <span class="title function_">joinMember</span><span class="params">(String name, String member)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除组成员</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> member 成员名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Group <span class="title function_">removeMember</span><span class="params">(String name, String member)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 移除聊天组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Group <span class="title function_">removeGroup</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取组成员</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成员集合, 没有成员会返回 empty set</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Set&lt;String&gt; <span class="title function_">getMembers</span><span class="params">(String name)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取组成员的 channel 集合, 只有在线的 channel 才会返回</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name 组名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 成员 channel 集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    List&lt;Channel&gt; <span class="title function_">getMembersChannel</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-聊天室业务-登录"><a href="#3-2-聊天室业务-登录" class="headerlink" title="3.2 聊天室业务-登录"></a>3.2 聊天室业务-登录</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">LoggingHandler</span> <span class="variable">LOGGING_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class="line">        <span class="type">MessageCodecSharable</span> <span class="variable">MESSAGE_CODEC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageCodecSharable</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ProcotolFrameDecoder</span>());</span><br><span class="line">                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class="line">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;LoginRequestMessage&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, LoginRequestMessage msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> msg.getUsername();</span><br><span class="line">                            <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> msg.getPassword();</span><br><span class="line">                            <span class="type">boolean</span> <span class="variable">login</span> <span class="operator">=</span> UserServiceFactory.getUserService().login(username, password);</span><br><span class="line">                            LoginResponseMessage message;</span><br><span class="line">                            <span class="keyword">if</span>(login) &#123;</span><br><span class="line">                                message = <span class="keyword">new</span> <span class="title class_">LoginResponseMessage</span>(<span class="literal">true</span>, <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                message = <span class="keyword">new</span> <span class="title class_">LoginResponseMessage</span>(<span class="literal">false</span>, <span class="string">&quot;用户名或密码不正确&quot;</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            ctx.writeAndFlush(message);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">8080</span>).sync().channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;server error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">LoggingHandler</span> <span class="variable">LOGGING_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class="line">        <span class="type">MessageCodecSharable</span> <span class="variable">MESSAGE_CODEC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageCodecSharable</span>();</span><br><span class="line">        <span class="type">CountDownLatch</span> <span class="variable">WAIT_FOR_LOGIN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">AtomicBoolean</span> <span class="variable">LOGIN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicBoolean</span>(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(group);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ProcotolFrameDecoder</span>());</span><br><span class="line"><span class="comment">//                    ch.pipeline().addLast(LOGGING_HANDLER);</span></span><br><span class="line">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    ch.pipeline().addLast(<span class="string">&quot;client handler&quot;</span>, <span class="keyword">new</span> <span class="title class_">ChannelInboundHandlerAdapter</span>() &#123;</span><br><span class="line">                        <span class="comment">// 接收响应消息</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            log.debug(<span class="string">&quot;msg: &#123;&#125;&quot;</span>, msg);</span><br><span class="line">                            <span class="keyword">if</span> ((msg <span class="keyword">instanceof</span> LoginResponseMessage)) &#123;</span><br><span class="line">                                <span class="type">LoginResponseMessage</span> <span class="variable">response</span> <span class="operator">=</span> (LoginResponseMessage) msg;</span><br><span class="line">                                <span class="keyword">if</span> (response.isSuccess()) &#123;</span><br><span class="line">                                    <span class="comment">// 如果登录成功</span></span><br><span class="line">                                    LOGIN.set(<span class="literal">true</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 唤醒 system in 线程</span></span><br><span class="line">                                WAIT_FOR_LOGIN.countDown();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 在连接建立后触发 active 事件</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                            <span class="comment">// 负责接收用户在控制台的输入，负责向服务器发送各种消息</span></span><br><span class="line">                            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                                <span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">                                System.out.println(<span class="string">&quot;请输入用户名:&quot;</span>);</span><br><span class="line">                                <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                                System.out.println(<span class="string">&quot;请输入密码:&quot;</span>);</span><br><span class="line">                                <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                                <span class="comment">// 构造消息对象</span></span><br><span class="line">                                <span class="type">LoginRequestMessage</span> <span class="variable">message</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoginRequestMessage</span>(username, password);</span><br><span class="line">                                <span class="comment">// 发送消息</span></span><br><span class="line">                                ctx.writeAndFlush(message);</span><br><span class="line">                                System.out.println(<span class="string">&quot;等待后续操作...&quot;</span>);</span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    WAIT_FOR_LOGIN.await();</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                    e.printStackTrace();</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="comment">// 如果登录失败</span></span><br><span class="line">                                <span class="keyword">if</span> (!LOGIN.get()) &#123;</span><br><span class="line">                                    ctx.channel().close();</span><br><span class="line">                                    <span class="keyword">return</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                                    System.out.println(<span class="string">&quot;==================================&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;send [username] [content]&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;gsend [group name] [content]&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;gcreate [group name] [m1,m2,m3...]&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;gmembers [group name]&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;gjoin [group name]&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;gquit [group name]&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;quit&quot;</span>);</span><br><span class="line">                                    System.out.println(<span class="string">&quot;==================================&quot;</span>);</span><br><span class="line">                                    <span class="type">String</span> <span class="variable">command</span> <span class="operator">=</span> scanner.nextLine();</span><br><span class="line">                                    String[] s = command.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                                    <span class="keyword">switch</span> (s[<span class="number">0</span>])&#123;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;send&quot;</span>:</span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">ChatRequestMessage</span>(username, s[<span class="number">1</span>], s[<span class="number">2</span>]));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;gsend&quot;</span>:</span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupChatRequestMessage</span>(username, s[<span class="number">1</span>], s[<span class="number">2</span>]));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;gcreate&quot;</span>:</span><br><span class="line">                                            Set&lt;String&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(Arrays.asList(s[<span class="number">2</span>].split(<span class="string">&quot;,&quot;</span>)));</span><br><span class="line">                                            set.add(username); <span class="comment">// 加入自己</span></span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupCreateRequestMessage</span>(s[<span class="number">1</span>], set));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;gmembers&quot;</span>:</span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupMembersRequestMessage</span>(s[<span class="number">1</span>]));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;gjoin&quot;</span>:</span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupJoinRequestMessage</span>(username, s[<span class="number">1</span>]));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;gquit&quot;</span>:</span><br><span class="line">                                            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupQuitRequestMessage</span>(username, s[<span class="number">1</span>]));</span><br><span class="line">                                            <span class="keyword">break</span>;</span><br><span class="line">                                        <span class="keyword">case</span> <span class="string">&quot;quit&quot;</span>:</span><br><span class="line">                                            ctx.channel().close();</span><br><span class="line">                                            <span class="keyword">return</span>;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;, <span class="string">&quot;system in&quot;</span>).start();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).sync().channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-聊天室业务-单聊"><a href="#3-3-聊天室业务-单聊" class="headerlink" title="3.3 聊天室业务-单聊"></a>3.3 聊天室业务-单聊</h3><p>服务器端将 handler 独立出来</p>
<p>登录 handler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoginRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;LoginRequestMessage&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, LoginRequestMessage msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> msg.getUsername();</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> msg.getPassword();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">login</span> <span class="operator">=</span> UserServiceFactory.getUserService().login(username, password);</span><br><span class="line">        LoginResponseMessage message;</span><br><span class="line">        <span class="keyword">if</span>(login) &#123;</span><br><span class="line">            SessionFactory.getSession().bind(ctx.channel(), username);</span><br><span class="line">            message = <span class="keyword">new</span> <span class="title class_">LoginResponseMessage</span>(<span class="literal">true</span>, <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            message = <span class="keyword">new</span> <span class="title class_">LoginResponseMessage</span>(<span class="literal">false</span>, <span class="string">&quot;用户名或密码不正确&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.writeAndFlush(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>单聊 handler</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ChatRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;ChatRequestMessage&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, ChatRequestMessage msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">to</span> <span class="operator">=</span> msg.getTo();</span><br><span class="line">        <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> SessionFactory.getSession().getChannel(to);</span><br><span class="line">        <span class="comment">// 在线</span></span><br><span class="line">        <span class="keyword">if</span>(channel != <span class="literal">null</span>) &#123;</span><br><span class="line">            channel.writeAndFlush(<span class="keyword">new</span> <span class="title class_">ChatResponseMessage</span>(msg.getFrom(), msg.getContent()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 不在线</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">ChatResponseMessage</span>(<span class="literal">false</span>, <span class="string">&quot;对方用户不存在或者不在线&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-4-聊天室业务-群聊"><a href="#3-4-聊天室业务-群聊" class="headerlink" title="3.4 聊天室业务-群聊"></a>3.4 聊天室业务-群聊</h3><p>创建群聊</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupCreateRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;GroupCreateRequestMessage&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupCreateRequestMessage msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">groupName</span> <span class="operator">=</span> msg.getGroupName();</span><br><span class="line">        Set&lt;String&gt; members = msg.getMembers();</span><br><span class="line">        <span class="comment">// 群管理器</span></span><br><span class="line">        <span class="type">GroupSession</span> <span class="variable">groupSession</span> <span class="operator">=</span> GroupSessionFactory.getGroupSession();</span><br><span class="line">        <span class="type">Group</span> <span class="variable">group</span> <span class="operator">=</span> groupSession.createGroup(groupName, members);</span><br><span class="line">        <span class="keyword">if</span> (group == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 发生成功消息</span></span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupCreateResponseMessage</span>(<span class="literal">true</span>, groupName + <span class="string">&quot;创建成功&quot;</span>));</span><br><span class="line">            <span class="comment">// 发送拉群消息</span></span><br><span class="line">            List&lt;Channel&gt; channels = groupSession.getMembersChannel(groupName);</span><br><span class="line">            <span class="keyword">for</span> (Channel channel : channels) &#123;</span><br><span class="line">                channel.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupCreateResponseMessage</span>(<span class="literal">true</span>, <span class="string">&quot;您已被拉入&quot;</span> + groupName));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupCreateResponseMessage</span>(<span class="literal">false</span>, groupName + <span class="string">&quot;已经存在&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>群聊</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupChatRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;GroupChatRequestMessage&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupChatRequestMessage msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        List&lt;Channel&gt; channels = GroupSessionFactory.getGroupSession()</span><br><span class="line">                .getMembersChannel(msg.getGroupName());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Channel channel : channels) &#123;</span><br><span class="line">            channel.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupChatResponseMessage</span>(msg.getFrom(), msg.getContent()));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加入群聊</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupJoinRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;GroupJoinRequestMessage&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupJoinRequestMessage msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Group</span> <span class="variable">group</span> <span class="operator">=</span> GroupSessionFactory.getGroupSession().joinMember(msg.getGroupName(), msg.getUsername());</span><br><span class="line">        <span class="keyword">if</span> (group != <span class="literal">null</span>) &#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupJoinResponseMessage</span>(<span class="literal">true</span>, msg.getGroupName() + <span class="string">&quot;群加入成功&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupJoinResponseMessage</span>(<span class="literal">true</span>, msg.getGroupName() + <span class="string">&quot;群不存在&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>退出群聊</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupQuitRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;GroupQuitRequestMessage&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupQuitRequestMessage msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Group</span> <span class="variable">group</span> <span class="operator">=</span> GroupSessionFactory.getGroupSession().removeMember(msg.getGroupName(), msg.getUsername());</span><br><span class="line">        <span class="keyword">if</span> (group != <span class="literal">null</span>) &#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupJoinResponseMessage</span>(<span class="literal">true</span>, <span class="string">&quot;已退出群&quot;</span> + msg.getGroupName()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupJoinResponseMessage</span>(<span class="literal">true</span>, msg.getGroupName() + <span class="string">&quot;群不存在&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看成员</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GroupMembersRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;GroupMembersRequestMessage&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, GroupMembersRequestMessage msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Set&lt;String&gt; members = GroupSessionFactory.getGroupSession()</span><br><span class="line">                .getMembers(msg.getGroupName());</span><br><span class="line">        ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">GroupMembersResponseMessage</span>(members));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-5-聊天室业务-退出"><a href="#3-5-聊天室业务-退出" class="headerlink" title="3.5 聊天室业务-退出"></a>3.5 聊天室业务-退出</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@ChannelHandler.Sharable</span><br><span class="line">public class QuitHandler extends ChannelInboundHandlerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    // 当连接断开时触发 inactive 事件</span><br><span class="line">    @Override</span><br><span class="line">    public void channelInactive(ChannelHandlerContext ctx) throws Exception &#123;</span><br><span class="line">        SessionFactory.getSession().unbind(ctx.channel());</span><br><span class="line">        log.debug(&quot;&#123;&#125; 已经断开&quot;, ctx.channel());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	// 当出现异常时触发</span><br><span class="line">    @Override</span><br><span class="line">    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception &#123;</span><br><span class="line">        SessionFactory.getSession().unbind(ctx.channel());</span><br><span class="line">        log.debug(&quot;&#123;&#125; 已经异常断开 异常是&#123;&#125;&quot;, ctx.channel(), cause.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-6-聊天室业务-空闲检测"><a href="#3-6-聊天室业务-空闲检测" class="headerlink" title="3.6 聊天室业务-空闲检测"></a>3.6 聊天室业务-空闲检测</h3><h4 id="连接假死"><a href="#连接假死" class="headerlink" title="连接假死"></a>连接假死</h4><p>原因</p>
<ul>
<li>网络设备出现故障，例如网卡，机房等，底层的 TCP 连接已经断开了，但应用程序没有感知到，仍然占用着资源。</li>
<li>公网网络不稳定，出现丢包。如果连续出现丢包，这时现象就是客户端数据发不出去，服务端也一直收不到数据，就这么一直耗着</li>
<li>应用程序线程阻塞，无法进行数据读写</li>
</ul>
<p>问题</p>
<ul>
<li>假死的连接占用的资源不能自动释放</li>
<li>向假死的连接发送数据，得到的反馈是发送超时</li>
</ul>
<p>服务器端解决</p>
<ul>
<li>怎么判断客户端连接是否假死呢？如果能收到客户端数据，说明没有假死。因此策略就可以定为，每隔一段时间就检查这段时间内是否接收到客户端数据，没有就可以判定为连接假死</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用来判断是不是 读空闲时间过长，或 写空闲时间过长</span></span><br><span class="line"><span class="comment">// 5s 内如果没有收到 channel 的数据，会触发一个 IdleState#READER_IDLE 事件</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">5</span>, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// ChannelDuplexHandler 可以同时作为入站和出站处理器</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelDuplexHandler</span>() &#123;</span><br><span class="line">    <span class="comment">// 用来触发特殊事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">IdleStateEvent</span> <span class="variable">event</span> <span class="operator">=</span> (IdleStateEvent) evt;</span><br><span class="line">        <span class="comment">// 触发了读空闲事件</span></span><br><span class="line">        <span class="keyword">if</span> (event.state() == IdleState.READER_IDLE) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;已经 5s 没有读到数据了&quot;</span>);</span><br><span class="line">            ctx.channel().close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>客户端定时心跳</p>
<ul>
<li>客户端可以定时向服务器端发送数据，只要这个时间间隔小于服务器定义的空闲检测的时间间隔，那么就能防止前面提到的误判，客户端可以定义如下心跳处理器</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用来判断是不是 读空闲时间过长，或 写空闲时间过长</span></span><br><span class="line"><span class="comment">// 3s 内如果没有向服务器写数据，会触发一个 IdleState#WRITER_IDLE 事件</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">IdleStateHandler</span>(<span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>));</span><br><span class="line"><span class="comment">// ChannelDuplexHandler 可以同时作为入站和出站处理器</span></span><br><span class="line">ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ChannelDuplexHandler</span>() &#123;</span><br><span class="line">    <span class="comment">// 用来触发特殊事件</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">        <span class="type">IdleStateEvent</span> <span class="variable">event</span> <span class="operator">=</span> (IdleStateEvent) evt;</span><br><span class="line">        <span class="comment">// 触发了写空闲事件</span></span><br><span class="line">        <span class="keyword">if</span> (event.state() == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">            <span class="comment">//                                log.debug(&quot;3s 没有写数据了，发送一个心跳包&quot;);</span></span><br><span class="line">            ctx.writeAndFlush(<span class="keyword">new</span> <span class="title class_">PingMessage</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>Netty(四) 进阶，优化与源码</title>
    <url>/posts/45606.html</url>
    <content><![CDATA[<h1 id="四-优化与源码"><a href="#四-优化与源码" class="headerlink" title="四. 优化与源码"></a>四. 优化与源码</h1><h2 id="1-优化"><a href="#1-优化" class="headerlink" title="1. 优化"></a>1. 优化</h2><h3 id="1-1-扩展序列化算法"><a href="#1-1-扩展序列化算法" class="headerlink" title="1.1 扩展序列化算法"></a>1.1 扩展序列化算法</h3><p>序列化，反序列化主要用在消息正文的转换上</p>
<ul>
<li>序列化时，需要将 Java 对象变为要传输的数据（可以是 byte[]，或 json 等，最终都需要变成 byte[]）</li>
<li>反序列化时，需要将传入的正文数据还原成 Java 对象，便于处理</li>
</ul>
<p>目前的代码仅支持 Java 自带的序列化，反序列化机制，核心代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line"><span class="type">byte</span>[] body = <span class="keyword">new</span> <span class="title class_">byte</span>[bodyLength];</span><br><span class="line">byteByf.readBytes(body);</span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(body));</span><br><span class="line"><span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> (Message) in.readObject();</span><br><span class="line">message.setSequenceId(sequenceId);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(out).writeObject(message);</span><br><span class="line"><span class="type">byte</span>[] bytes = out.toByteArray();</span><br></pre></td></tr></table></figure>
<p>为了支持更多序列化算法，抽象一个 Serializer 接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 反序列化方法</span></span><br><span class="line">    &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 序列化方法</span></span><br><span class="line">    &lt;T&gt; <span class="type">byte</span>[] serialize(T object);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>提供两个实现，我这里直接将实现加入了枚举类 Serializer.Algorithm 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">SerializerAlgorithm</span> <span class="keyword">implements</span> <span class="title class_">Serializer</span> &#123;</span><br><span class="line">	<span class="comment">// Java 实现</span></span><br><span class="line">    Java &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> </span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes));</span><br><span class="line">                <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> in.readObject();</span><br><span class="line">                <span class="keyword">return</span> (T) object;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;SerializerAlgorithm.Java 反序列化错误&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(out).writeObject(object);</span><br><span class="line">                <span class="keyword">return</span> out.toByteArray();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;SerializerAlgorithm.Java 序列化错误&quot;</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, </span><br><span class="line">    <span class="comment">// Json 实现(引入了 Gson 依赖)</span></span><br><span class="line">    Json &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; T <span class="title function_">deserialize</span><span class="params">(Class&lt;T&gt; clazz, <span class="type">byte</span>[] bytes)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().fromJson(<span class="keyword">new</span> <span class="title class_">String</span>(bytes, StandardCharsets.UTF_8), clazz);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="type">byte</span>[] serialize(T object) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Gson</span>().toJson(object).getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要从协议的字节中得到是哪种序列化算法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> SerializerAlgorithm <span class="title function_">getByInt</span><span class="params">(<span class="type">int</span> type)</span> &#123;</span><br><span class="line">        SerializerAlgorithm[] array = SerializerAlgorithm.values();</span><br><span class="line">        <span class="keyword">if</span> (type &lt; <span class="number">0</span> || type &gt; array.length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;超过 SerializerAlgorithm 范围&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array[type];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>增加配置类和配置文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Config</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Properties properties;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Config.class.getResourceAsStream(<span class="string">&quot;/application.properties&quot;</span>)) &#123;</span><br><span class="line">            properties = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            properties.load(in);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExceptionInInitializerError</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getServerPort</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;server.port&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">8080</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.parseInt(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Serializer.Algorithm <span class="title function_">getSerializerAlgorithm</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> properties.getProperty(<span class="string">&quot;serializer.algorithm&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span>(value == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Serializer.Algorithm.Java;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Serializer.Algorithm.valueOf(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">serializer.algorithm</span>=<span class="string">Json</span></span><br></pre></td></tr></table></figure>
<p>修改编解码器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 必须和 LengthFieldBasedFrameDecoder 一起使用，确保接到的 ByteBuf 消息是完整的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageCodecSharable</span> <span class="keyword">extends</span> <span class="title class_">MessageToMessageCodec</span>&lt;ByteBuf, Message&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">encode</span><span class="params">(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; outList)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">ByteBuf</span> <span class="variable">out</span> <span class="operator">=</span> ctx.alloc().buffer();</span><br><span class="line">        <span class="comment">// 1. 4 字节的魔数</span></span><br><span class="line">        out.writeBytes(<span class="keyword">new</span> <span class="title class_">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">        <span class="comment">// 2. 1 字节的版本,</span></span><br><span class="line">        out.writeByte(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 3. 1 字节的序列化方式 jdk 0 , json 1</span></span><br><span class="line">        out.writeByte(Config.getSerializerAlgorithm().ordinal());</span><br><span class="line">        <span class="comment">// 4. 1 字节的指令类型</span></span><br><span class="line">        out.writeByte(msg.getMessageType());</span><br><span class="line">        <span class="comment">// 5. 4 个字节</span></span><br><span class="line">        out.writeInt(msg.getSequenceId());</span><br><span class="line">        <span class="comment">// 无意义，对齐填充</span></span><br><span class="line">        out.writeByte(<span class="number">0xff</span>);</span><br><span class="line">        <span class="comment">// 6. 获取内容的字节数组</span></span><br><span class="line">        <span class="type">byte</span>[] bytes = Config.getSerializerAlgorithm().serialize(msg);</span><br><span class="line">        <span class="comment">// 7. 长度</span></span><br><span class="line">        out.writeInt(bytes.length);</span><br><span class="line">        <span class="comment">// 8. 写入内容</span></span><br><span class="line">        out.writeBytes(bytes);</span><br><span class="line">        outList.add(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">decode</span><span class="params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">magicNum</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">version</span> <span class="operator">=</span> in.readByte();</span><br><span class="line">        <span class="type">byte</span> <span class="variable">serializerAlgorithm</span> <span class="operator">=</span> in.readByte(); <span class="comment">// 0 或 1</span></span><br><span class="line">        <span class="type">byte</span> <span class="variable">messageType</span> <span class="operator">=</span> in.readByte(); <span class="comment">// 0,1,2...</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        in.readByte();</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> in.readInt();</span><br><span class="line">        <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[length];</span><br><span class="line">        in.readBytes(bytes, <span class="number">0</span>, length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到反序列化算法</span></span><br><span class="line">        Serializer.<span class="type">Algorithm</span> <span class="variable">algorithm</span> <span class="operator">=</span> Serializer.Algorithm.values()[serializerAlgorithm];</span><br><span class="line">        <span class="comment">// 确定具体消息类型</span></span><br><span class="line">        Class&lt;? <span class="keyword">extends</span> <span class="title class_">Message</span>&gt; messageClass = Message.getMessageClass(messageType);</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> algorithm.deserialize(messageClass, bytes);</span><br><span class="line"><span class="comment">//        log.debug(&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;, magicNum, version, serializerType, messageType, sequenceId, length);</span></span><br><span class="line"><span class="comment">//        log.debug(&quot;&#123;&#125;&quot;, message);</span></span><br><span class="line">        out.add(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中确定具体消息类型，可以根据 <code>消息类型字节</code> 获取到对应的 <code>消息 class</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Message</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据消息类型字节，获得对应的消息 class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> messageType 消息类型字节</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 消息 class</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Class&lt;? <span class="keyword">extends</span> <span class="title class_">Message</span>&gt; getMessageClass(<span class="type">int</span> messageType) &#123;</span><br><span class="line">        <span class="keyword">return</span> messageClasses.get(messageType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> sequenceId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> messageType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="type">int</span> <span class="title function_">getMessageType</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LoginRequestMessage</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">LoginResponseMessage</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ChatRequestMessage</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ChatResponseMessage</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">GroupCreateRequestMessage</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">GroupCreateResponseMessage</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">GroupJoinRequestMessage</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">GroupJoinResponseMessage</span> <span class="operator">=</span> <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">GroupQuitRequestMessage</span> <span class="operator">=</span> <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">GroupQuitResponseMessage</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">GroupChatRequestMessage</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">GroupChatResponseMessage</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">GroupMembersRequestMessage</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">GroupMembersResponseMessage</span> <span class="operator">=</span> <span class="number">13</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PingMessage</span> <span class="operator">=</span> <span class="number">14</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">PongMessage</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, Class&lt;? <span class="keyword">extends</span> <span class="title class_">Message</span>&gt;&gt; messageClasses = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        messageClasses.put(LoginRequestMessage, LoginRequestMessage.class);</span><br><span class="line">        messageClasses.put(LoginResponseMessage, LoginResponseMessage.class);</span><br><span class="line">        messageClasses.put(ChatRequestMessage, ChatRequestMessage.class);</span><br><span class="line">        messageClasses.put(ChatResponseMessage, ChatResponseMessage.class);</span><br><span class="line">        messageClasses.put(GroupCreateRequestMessage, GroupCreateRequestMessage.class);</span><br><span class="line">        messageClasses.put(GroupCreateResponseMessage, GroupCreateResponseMessage.class);</span><br><span class="line">        messageClasses.put(GroupJoinRequestMessage, GroupJoinRequestMessage.class);</span><br><span class="line">        messageClasses.put(GroupJoinResponseMessage, GroupJoinResponseMessage.class);</span><br><span class="line">        messageClasses.put(GroupQuitRequestMessage, GroupQuitRequestMessage.class);</span><br><span class="line">        messageClasses.put(GroupQuitResponseMessage, GroupQuitResponseMessage.class);</span><br><span class="line">        messageClasses.put(GroupChatRequestMessage, GroupChatRequestMessage.class);</span><br><span class="line">        messageClasses.put(GroupChatResponseMessage, GroupChatResponseMessage.class);</span><br><span class="line">        messageClasses.put(GroupMembersRequestMessage, GroupMembersRequestMessage.class);</span><br><span class="line">        messageClasses.put(GroupMembersResponseMessage, GroupMembersResponseMessage.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1-2-参数调优"><a href="#1-2-参数调优" class="headerlink" title="1.2 参数调优"></a>1.2 参数调优</h3><h4 id="1）CONNECT-TIMEOUT-MILLIS"><a href="#1）CONNECT-TIMEOUT-MILLIS" class="headerlink" title="1）CONNECT_TIMEOUT_MILLIS"></a>1）CONNECT_TIMEOUT_MILLIS</h4><ul>
<li><p>属于 SocketChannal 参数</p>
</li>
<li><p>用在客户端建立连接时，如果在指定毫秒内无法连接，会抛出 timeout 异常</p>
</li>
<li><p>SO_TIMEOUT 主要用在阻塞 IO，阻塞 IO 中 accept，read 等都是无限等待的，如果不希望永远阻塞，使用它调整超时时间</p>
</li>
<li><p>客户端只有option方法，配置SocketChannel 参数</p>
</li>
<li><p>服务端区别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>().option() <span class="comment">// 给ServerSocketChannel 配置参数</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>().childOption() <span class="comment">// 给SocketChannel 配置参数</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestConnectionTimeout</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>()</span><br><span class="line">                    .group(group)</span><br><span class="line">                    .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">300</span>)</span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> <span class="title class_">LoggingHandler</span>());</span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>);</span><br><span class="line">            future.sync().channel().closeFuture().sync(); <span class="comment">// 断点1</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            log.debug(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外源码部分 <code>io.netty.channel.nio.AbstractNioChannel.AbstractNioUnsafe#connect</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">connect</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> SocketAddress remoteAddress, <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Schedule connect timeout.</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">connectTimeoutMillis</span> <span class="operator">=</span> config().getConnectTimeoutMillis();</span><br><span class="line">    <span class="keyword">if</span> (connectTimeoutMillis &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        connectTimeoutFuture = eventLoop().schedule(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;                </span><br><span class="line">                <span class="type">ChannelPromise</span> <span class="variable">connectPromise</span> <span class="operator">=</span> AbstractNioChannel.<span class="built_in">this</span>.connectPromise;</span><br><span class="line">                <span class="type">ConnectTimeoutException</span> <span class="variable">cause</span> <span class="operator">=</span></span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">ConnectTimeoutException</span>(<span class="string">&quot;connection timed out: &quot;</span> + remoteAddress); <span class="comment">// 断点2</span></span><br><span class="line">                <span class="keyword">if</span> (connectPromise != <span class="literal">null</span> &amp;&amp; connectPromise.tryFailure(cause)) &#123;</span><br><span class="line">                    close(voidPromise());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2）SO-BACKLOG"><a href="#2）SO-BACKLOG" class="headerlink" title="2）SO_BACKLOG"></a>2）SO_BACKLOG</h4><ul>
<li>属于 ServerSocketChannal 参数</li>
</ul>
<pre class="mermaid">sequenceDiagram

participant c as client
participant s as server
participant sq as syns queue
participant aq as accept queue

s ->> s : bind()
s ->> s : listen()
c ->> c : connect()
c ->> s : 1. SYN
Note left of c : SYN_SEND
s ->> sq : put
Note right of s : SYN_RCVD
s ->> c : 2. SYN + ACK
Note left of c : ESTABLISHED
c ->> s : 3. ACK
sq ->> aq : put
Note right of s : ESTABLISHED
aq -->> s : 
s ->> s : accept()</pre>

<ol>
<li>第一次握手，client 发送 SYN 到 server，状态修改为 SYN_SEND，server 收到，状态改变为 SYN_REVD，并将该请求放入 sync queue 队列</li>
<li>第二次握手，server 回复 SYN + ACK 给 client，client 收到，状态改变为 ESTABLISHED，并发送 ACK 给 server</li>
<li>第三次握手，server 收到 ACK，状态改变为 ESTABLISHED，将该请求从 sync queue 放入 accept queue</li>
</ol>
<p>其中</p>
<ul>
<li><p>在 linux 2.2 之前，backlog 大小包括了两个队列的大小，在 2.2 之后，分别用下面两个参数来控制</p>
</li>
<li><p>sync queue - 半连接队列</p>
<ul>
<li>大小通过 /proc/sys/net/ipv4/tcp_max_syn_backlog 指定，在 <code>syncookies</code> 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略</li>
</ul>
</li>
<li>accept queue - 全连接队列<ul>
<li>其大小通过 /proc/sys/net/core/somaxconn 指定，在使用 listen 函数时，内核会根据传入的 backlog 参数与系统参数，取二者的较小值</li>
<li>如果 accpet queue 队列满了，server 将发送一个拒绝连接的错误信息到 client</li>
</ul>
</li>
</ul>
<p>netty 中</p>
<p>可以通过  option(ChannelOption.SO_BACKLOG, 值) 来设置大小</p>
<p>可以通过下面源码查看默认大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultServerSocketChannelConfig</span> <span class="keyword">extends</span> <span class="title class_">DefaultChannelConfig</span></span><br><span class="line">                                              <span class="keyword">implements</span> <span class="title class_">ServerSocketChannelConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">backlog</span> <span class="operator">=</span> NetUtil.SOMAXCONN;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>课堂调试关键断点为：<code>io.netty.channel.nio.NioEventLoop#processSelectedKey</code></p>
<p>oio 中更容易说明，不用 debug 模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Server</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8888</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="type">Socket</span> <span class="variable">accept</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">        System.out.println(accept);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端启动 4 个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Socket</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>();</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>()+<span class="string">&quot; connecting...&quot;</span>);</span><br><span class="line">            s.connect(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="string">&quot;localhost&quot;</span>, <span class="number">8888</span>),<span class="number">1000</span>);</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>()+<span class="string">&quot; connected...&quot;</span>);</span><br><span class="line">            s.getOutputStream().write(<span class="number">1</span>);</span><br><span class="line">            System.in.read();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> <span class="title class_">Date</span>()+<span class="string">&quot; connecting timeout...&quot;</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第 1，2，3 个客户端都打印，但除了第一个处于 accpet 外，其它两个都处于 accept queue 中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Tue Apr <span class="number">21</span> <span class="number">20</span>:<span class="number">30</span>:<span class="number">28</span> CST <span class="number">2020</span> connecting...</span><br><span class="line">Tue Apr <span class="number">21</span> <span class="number">20</span>:<span class="number">30</span>:<span class="number">28</span> CST <span class="number">2020</span> connected...</span><br></pre></td></tr></table></figure>
<p>第 4 个客户端连接时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tue Apr 21 20:53:58 CST 2020 connecting...</span><br><span class="line">Tue Apr 21 20:53:59 CST 2020 connecting timeout...</span><br><span class="line">java.net.SocketTimeoutException: connect timed out</span><br></pre></td></tr></table></figure>
<h4 id="3）ulimit-n"><a href="#3）ulimit-n" class="headerlink" title="3）ulimit -n"></a>3）ulimit -n</h4><ul>
<li>属于操作系统参数</li>
</ul>
<h4 id="4）TCP-NODELAY"><a href="#4）TCP-NODELAY" class="headerlink" title="4）TCP_NODELAY"></a>4）TCP_NODELAY</h4><ul>
<li>属于 SocketChannal 参数</li>
</ul>
<h4 id="5）SO-SNDBUF-amp-SO-RCVBUF"><a href="#5）SO-SNDBUF-amp-SO-RCVBUF" class="headerlink" title="5）SO_SNDBUF &amp; SO_RCVBUF"></a>5）SO_SNDBUF &amp; SO_RCVBUF</h4><ul>
<li>SO_SNDBUF 属于 SocketChannal 参数</li>
<li>SO_RCVBUF 既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数（建议设置到 ServerSocketChannal 上）</li>
</ul>
<h4 id="6）ALLOCATOR"><a href="#6）ALLOCATOR" class="headerlink" title="6）ALLOCATOR"></a>6）ALLOCATOR</h4><ul>
<li>属于 SocketChannal 参数</li>
<li>用来分配 ByteBuf， ctx.alloc()</li>
</ul>
<h4 id="7）RCVBUF-ALLOCATOR"><a href="#7）RCVBUF-ALLOCATOR" class="headerlink" title="7）RCVBUF_ALLOCATOR"></a>7）RCVBUF_ALLOCATOR</h4><ul>
<li>属于 SocketChannal 参数</li>
<li>控制 netty 接收缓冲区大小</li>
<li>负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），统一采用 direct 直接内存，具体池化还是非池化由 allocator 决定</li>
</ul>
<h3 id="1-3-RPC-框架"><a href="#1-3-RPC-框架" class="headerlink" title="1.3 RPC 框架"></a>1.3 RPC 框架</h3><h4 id="1）准备工作"><a href="#1）准备工作" class="headerlink" title="1）准备工作"></a>1）准备工作</h4><p>这些代码可以认为是现成的，无需从头编写练习</p>
<p>为了简化起见，在原来聊天项目的基础上新增 Rpc 请求和响应消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Message</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略旧的代码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">RPC_MESSAGE_TYPE_REQUEST</span> <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>  <span class="variable">RPC_MESSAGE_TYPE_RESPONSE</span> <span class="operator">=</span> <span class="number">102</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        messageClasses.put(RPC_MESSAGE_TYPE_REQUEST, RpcRequestMessage.class);</span><br><span class="line">        messageClasses.put(RPC_MESSAGE_TYPE_RESPONSE, RpcResponseMessage.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请求消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@ToString(callSuper = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcRequestMessage</span> <span class="keyword">extends</span> <span class="title class_">Message</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用的接口全限定名，服务端根据它找到实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String interfaceName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用接口中的方法名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String methodName;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法返回类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; returnType;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法参数类型数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Class[] parameterTypes;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 方法参数值数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object[] parameterValue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RpcRequestMessage</span><span class="params">(<span class="type">int</span> sequenceId, String interfaceName, String methodName, Class&lt;?&gt; returnType, Class[] parameterTypes, Object[] parameterValue)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setSequenceId(sequenceId);</span><br><span class="line">        <span class="built_in">this</span>.interfaceName = interfaceName;</span><br><span class="line">        <span class="built_in">this</span>.methodName = methodName;</span><br><span class="line">        <span class="built_in">this</span>.returnType = returnType;</span><br><span class="line">        <span class="built_in">this</span>.parameterTypes = parameterTypes;</span><br><span class="line">        <span class="built_in">this</span>.parameterValue = parameterValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMessageType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RPC_MESSAGE_TYPE_REQUEST;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>响应消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@ToString(callSuper = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcResponseMessage</span> <span class="keyword">extends</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object returnValue;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 异常值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Exception exceptionValue;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMessageType</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> RPC_MESSAGE_TYPE_RESPONSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器架子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcServer</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">boss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">LoggingHandler</span> <span class="variable">LOGGING_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class="line">        <span class="type">MessageCodecSharable</span> <span class="variable">MESSAGE_CODEC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageCodecSharable</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// rpc 请求消息处理器，待实现</span></span><br><span class="line">        <span class="type">RpcRequestMessageHandler</span> <span class="variable">RPC_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcRequestMessageHandler</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">ServerBootstrap</span> <span class="variable">serverBootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerBootstrap</span>();</span><br><span class="line">            serverBootstrap.channel(NioServerSocketChannel.class);</span><br><span class="line">            serverBootstrap.group(boss, worker);</span><br><span class="line">            serverBootstrap.childHandler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ProcotolFrameDecoder</span>());</span><br><span class="line">                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class="line">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    ch.pipeline().addLast(RPC_HANDLER);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> serverBootstrap.bind(<span class="number">8080</span>).sync().channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;server error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            boss.shutdownGracefully();</span><br><span class="line">            worker.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端架子</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">LoggingHandler</span> <span class="variable">LOGGING_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class="line">        <span class="type">MessageCodecSharable</span> <span class="variable">MESSAGE_CODEC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageCodecSharable</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// rpc 响应消息处理器，待实现</span></span><br><span class="line">        <span class="type">RpcResponseMessageHandler</span> <span class="variable">RPC_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcResponseMessageHandler</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(group);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ProcotolFrameDecoder</span>());</span><br><span class="line">                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class="line">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    ch.pipeline().addLast(RPC_HANDLER);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).sync().channel();</span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>服务器端的 service 获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServicesFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Properties properties;</span><br><span class="line">    <span class="keyword">static</span> Map&lt;Class&lt;?&gt;, Object&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">in</span> <span class="operator">=</span> Config.class.getResourceAsStream(<span class="string">&quot;/application.properties&quot;</span>)) &#123;</span><br><span class="line">            properties = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            properties.load(in);</span><br><span class="line">            Set&lt;String&gt; names = properties.stringPropertyNames();</span><br><span class="line">            <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">                <span class="keyword">if</span> (name.endsWith(<span class="string">&quot;Service&quot;</span>)) &#123;</span><br><span class="line">                    Class&lt;?&gt; interfaceClass = Class.forName(name);</span><br><span class="line">                    Class&lt;?&gt; instanceClass = Class.forName(properties.getProperty(name));</span><br><span class="line">                    map.put(interfaceClass, instanceClass.newInstance());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException | InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ExceptionInInitializerError</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getService</span><span class="params">(Class&lt;T&gt; interfaceClass)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (T) map.get(interfaceClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关配置 application.properties</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">serializer.algorithm=Json</span><br><span class="line">cn.itcast.server.service.HelloService=cn.itcast.server.service.HelloServiceImpl</span><br></pre></td></tr></table></figure>
<h4 id="2）服务器-handler"><a href="#2）服务器-handler" class="headerlink" title="2）服务器 handler"></a>2）服务器 handler</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcRequestMessageHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;RpcRequestMessage&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcRequestMessage message)</span> &#123;</span><br><span class="line">        <span class="type">RpcResponseMessage</span> <span class="variable">response</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcResponseMessage</span>();</span><br><span class="line">        response.setSequenceId(message.getSequenceId());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 获取真正的实现对象</span></span><br><span class="line">            <span class="type">HelloService</span> <span class="variable">service</span> <span class="operator">=</span> (HelloService)</span><br><span class="line">                    ServicesFactory.getService(Class.forName(message.getInterfaceName()));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 获取要调用的方法</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> service.getClass().getMethod(message.getMethodName(), message.getParameterTypes());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 调用方法</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> method.invoke(service, message.getParameterValue());</span><br><span class="line">            <span class="comment">// 调用成功</span></span><br><span class="line">            response.setReturnValue(invoke);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="comment">// 调用异常</span></span><br><span class="line">            response.setExceptionValue(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回结果</span></span><br><span class="line">        ctx.writeAndFlush(response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3）客户端代码第一版"><a href="#3）客户端代码第一版" class="headerlink" title="3）客户端代码第一版"></a>3）客户端代码第一版</h4><p>只发消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcClient</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">LoggingHandler</span> <span class="variable">LOGGING_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class="line">        <span class="type">MessageCodecSharable</span> <span class="variable">MESSAGE_CODEC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageCodecSharable</span>();</span><br><span class="line">        <span class="type">RpcResponseMessageHandler</span> <span class="variable">RPC_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcResponseMessageHandler</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">            bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">            bootstrap.group(group);</span><br><span class="line">            bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ProcotolFrameDecoder</span>());</span><br><span class="line">                    ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class="line">                    ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                    ch.pipeline().addLast(RPC_HANDLER);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).sync().channel();</span><br><span class="line"></span><br><span class="line">            <span class="type">ChannelFuture</span> <span class="variable">future</span> <span class="operator">=</span> channel.writeAndFlush(<span class="keyword">new</span> <span class="title class_">RpcRequestMessage</span>(</span><br><span class="line">                    <span class="number">1</span>,</span><br><span class="line">                    <span class="string">&quot;cn.itcast.server.service.HelloService&quot;</span>,</span><br><span class="line">                    <span class="string">&quot;sayHello&quot;</span>,</span><br><span class="line">                    String.class,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;张三&quot;</span>&#125;</span><br><span class="line">            )).addListener(promise -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (!promise.isSuccess()) &#123;</span><br><span class="line">                    <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> promise.cause();</span><br><span class="line">                    log.error(<span class="string">&quot;error&quot;</span>, cause);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            channel.closeFuture().sync();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4）客户端-handler-第一版"><a href="#4）客户端-handler-第一版" class="headerlink" title="4）客户端 handler 第一版"></a>4）客户端 handler 第一版</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcResponseMessageHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;RpcResponseMessage&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcResponseMessage msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5）客户端代码-第二版"><a href="#5）客户端代码-第二版" class="headerlink" title="5）客户端代码 第二版"></a>5）客户端代码 第二版</h4><p>包括 channel 管理，代理，接收结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcClientManager</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">HelloService</span> <span class="variable">service</span> <span class="operator">=</span> getProxyService(HelloService.class);</span><br><span class="line">        System.out.println(service.sayHello(<span class="string">&quot;zhangsan&quot;</span>));</span><br><span class="line"><span class="comment">//        System.out.println(service.sayHello(&quot;lisi&quot;));</span></span><br><span class="line"><span class="comment">//        System.out.println(service.sayHello(&quot;wangwu&quot;));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建代理类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">getProxyService</span><span class="params">(Class&lt;T&gt; serviceClass)</span> &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">loader</span> <span class="operator">=</span> serviceClass.getClassLoader();</span><br><span class="line">        Class&lt;?&gt;[] interfaces = <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;serviceClass&#125;;</span><br><span class="line">        <span class="comment">//                                                            sayHello  &quot;张三&quot;</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> Proxy.newProxyInstance(loader, interfaces, (proxy, method, args) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 1. 将方法调用转换为 消息对象</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">sequenceId</span> <span class="operator">=</span> SequenceIdGenerator.nextId();</span><br><span class="line">            <span class="type">RpcRequestMessage</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcRequestMessage</span>(</span><br><span class="line">                    sequenceId,</span><br><span class="line">                    serviceClass.getName(),</span><br><span class="line">                    method.getName(),</span><br><span class="line">                    method.getReturnType(),</span><br><span class="line">                    method.getParameterTypes(),</span><br><span class="line">                    args</span><br><span class="line">            );</span><br><span class="line">            <span class="comment">// 2. 将消息对象发送出去</span></span><br><span class="line">            getChannel().writeAndFlush(msg);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. 准备一个空 Promise 对象，来接收结果             指定 promise 对象异步接收结果线程</span></span><br><span class="line">            DefaultPromise&lt;Object&gt; promise = <span class="keyword">new</span> <span class="title class_">DefaultPromise</span>&lt;&gt;(getChannel().eventLoop());</span><br><span class="line">            RpcResponseMessageHandler.PROMISES.put(sequenceId, promise);</span><br><span class="line"></span><br><span class="line"><span class="comment">//            promise.addListener(future -&gt; &#123;</span></span><br><span class="line"><span class="comment">//                // 线程</span></span><br><span class="line"><span class="comment">//            &#125;);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4. 等待 promise 结果</span></span><br><span class="line">            promise.await();</span><br><span class="line">            <span class="keyword">if</span>(promise.isSuccess()) &#123;</span><br><span class="line">                <span class="comment">// 调用正常</span></span><br><span class="line">                <span class="keyword">return</span> promise.getNow();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 调用失败</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(promise.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> (T) o;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取唯一的 channel 对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Channel <span class="title function_">getChannel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (channel != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> channel;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123; <span class="comment">//  t2</span></span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="literal">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">                <span class="keyword">return</span> channel;</span><br><span class="line">            &#125;</span><br><span class="line">            initChannel();</span><br><span class="line">            <span class="keyword">return</span> channel;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化 channel 方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">NioEventLoopGroup</span> <span class="variable">group</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioEventLoopGroup</span>();</span><br><span class="line">        <span class="type">LoggingHandler</span> <span class="variable">LOGGING_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoggingHandler</span>(LogLevel.DEBUG);</span><br><span class="line">        <span class="type">MessageCodecSharable</span> <span class="variable">MESSAGE_CODEC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageCodecSharable</span>();</span><br><span class="line">        <span class="type">RpcResponseMessageHandler</span> <span class="variable">RPC_HANDLER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RpcResponseMessageHandler</span>();</span><br><span class="line">        <span class="type">Bootstrap</span> <span class="variable">bootstrap</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bootstrap</span>();</span><br><span class="line">        bootstrap.channel(NioSocketChannel.class);</span><br><span class="line">        bootstrap.group(group);</span><br><span class="line">        bootstrap.handler(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                ch.pipeline().addLast(<span class="keyword">new</span> <span class="title class_">ProcotolFrameDecoder</span>());</span><br><span class="line">                ch.pipeline().addLast(LOGGING_HANDLER);</span><br><span class="line">                ch.pipeline().addLast(MESSAGE_CODEC);</span><br><span class="line">                ch.pipeline().addLast(RPC_HANDLER);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel = bootstrap.connect(<span class="string">&quot;localhost&quot;</span>, <span class="number">8080</span>).sync().channel();</span><br><span class="line">            channel.closeFuture().addListener(future -&gt; &#123;</span><br><span class="line">                group.shutdownGracefully();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;client error&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6）客户端-handler-第二版"><a href="#6）客户端-handler-第二版" class="headerlink" title="6）客户端 handler 第二版"></a>6）客户端 handler 第二版</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="meta">@ChannelHandler</span>.Sharable</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RpcResponseMessageHandler</span> <span class="keyword">extends</span> <span class="title class_">SimpleChannelInboundHandler</span>&lt;RpcResponseMessage&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//                       序号      用来接收结果的 promise 对象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, Promise&lt;Object&gt;&gt; PROMISES = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">channelRead0</span><span class="params">(ChannelHandlerContext ctx, RpcResponseMessage msg)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, msg);</span><br><span class="line">        <span class="comment">// 拿到空的 promise</span></span><br><span class="line">        Promise&lt;Object&gt; promise = PROMISES.remove(msg.getSequenceId());</span><br><span class="line">        <span class="keyword">if</span> (promise != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> msg.getReturnValue();</span><br><span class="line">            <span class="type">Exception</span> <span class="variable">exceptionValue</span> <span class="operator">=</span> msg.getExceptionValue();</span><br><span class="line">            <span class="keyword">if</span>(exceptionValue != <span class="literal">null</span>) &#123;</span><br><span class="line">                promise.setFailure(exceptionValue);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                promise.setSuccess(returnValue);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2. 源码分析"></a>2. 源码分析</h2><h3 id="2-1-启动剖析"><a href="#2-1-启动剖析" class="headerlink" title="2.1 启动剖析"></a>2.1 启动剖析</h3><p>我们就来看看 netty 中对下面的代码是怎样进行处理的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1 netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装线程和 selector</span></span><br><span class="line"><span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> Selector.open(); </span><br><span class="line"></span><br><span class="line"><span class="comment">//2 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 config</span></span><br><span class="line"><span class="type">NioServerSocketChannel</span> <span class="variable">attachment</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NioServerSocketChannel</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannel</span></span><br><span class="line"><span class="type">ServerSocketChannel</span> <span class="variable">serverSocketChannel</span> <span class="operator">=</span> ServerSocketChannel.open(); </span><br><span class="line">serverSocketChannel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4 启动 nio boss 线程执行接下来的操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//5 注册（仅关联 selector 和 NioServerSocketChannel），未关注事件</span></span><br><span class="line"><span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> serverSocketChannel.register(selector, <span class="number">0</span>, attachment);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6 head -&gt; 初始化器 -&gt; ServerBootstrapAcceptor -&gt; tail，初始化器是一次性的，只为添加 acceptor</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//7 绑定端口</span></span><br><span class="line">serverSocketChannel.bind(<span class="keyword">new</span> <span class="title class_">InetSocketAddress</span>(<span class="number">8080</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//8 触发 channel active 事件，在 head 中关注 op_accept 事件</span></span><br><span class="line">selectionKey.interestOps(SelectionKey.OP_ACCEPT);</span><br></pre></td></tr></table></figure>
<p>入口 <code>io.netty.bootstrap.ServerBootstrap#bind</code></p>
<p>关键代码 <code>io.netty.bootstrap.AbstractBootstrap#doBind</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ChannelFuture <span class="title function_">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> &#123;</span><br><span class="line">	<span class="comment">// 1. 执行初始化和注册 regFuture 会由 initAndRegister 设置其是否完成，从而回调 3.2 处代码</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> initAndRegister();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> regFuture.channel();</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 因为是 initAndRegister 异步执行，需要分两种情况来看，调试时也需要通过 suspend 断点类型加以区分</span></span><br><span class="line">    <span class="comment">// 2.1 如果已经完成</span></span><br><span class="line">    <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">        <span class="type">ChannelPromise</span> <span class="variable">promise</span> <span class="operator">=</span> channel.newPromise();</span><br><span class="line">        <span class="comment">// 3.1 立刻调用 doBind0</span></span><br><span class="line">        doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 2.2 还没有完成</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">PendingRegistrationPromise</span> <span class="variable">promise</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PendingRegistrationPromise</span>(channel);</span><br><span class="line">        <span class="comment">// 3.2 回调 doBind0</span></span><br><span class="line">        regFuture.addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="type">Throwable</span> <span class="variable">cause</span> <span class="operator">=</span> future.cause();</span><br><span class="line">                <span class="keyword">if</span> (cause != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 处理异常...</span></span><br><span class="line">                    promise.setFailure(cause);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    promise.registered();</span><br><span class="line">					<span class="comment">// 3. 由注册线程去执行 doBind0</span></span><br><span class="line">                    doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键代码 <code>io.netty.bootstrap.AbstractBootstrap#initAndRegister</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> ChannelFuture <span class="title function_">initAndRegister</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">Channel</span> <span class="variable">channel</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        channel = channelFactory.newChannel();</span><br><span class="line">        <span class="comment">// 1.1 初始化 - 做的事就是添加一个初始化器 ChannelInitializer</span></span><br><span class="line">        init(channel);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// 处理异常...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultChannelPromise</span>(<span class="keyword">new</span> <span class="title class_">FailedChannel</span>(), GlobalEventExecutor.INSTANCE).setFailure(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1.2 注册 - 做的事就是将原生 channel 注册到 selector 上</span></span><br><span class="line">    <span class="type">ChannelFuture</span> <span class="variable">regFuture</span> <span class="operator">=</span> config().group().register(channel);</span><br><span class="line">    <span class="keyword">if</span> (regFuture.cause() != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 处理异常...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> regFuture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键代码 <code>io.netty.bootstrap.ServerBootstrap#init</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这里 channel 实际上是 NioServerSocketChannel</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">final</span> Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = options0();</span><br><span class="line">    <span class="keyword">synchronized</span> (options) &#123;</span><br><span class="line">        setChannelOptions(channel, options, logger);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = attrs0();</span><br><span class="line">    <span class="keyword">synchronized</span> (attrs) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: attrs.entrySet()) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">            AttributeKey&lt;Object&gt; key = (AttributeKey&lt;Object&gt;) e.getKey();</span><br><span class="line">            channel.attr(key).set(e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">ChannelPipeline</span> <span class="variable">p</span> <span class="operator">=</span> channel.pipeline();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">EventLoopGroup</span> <span class="variable">currentChildGroup</span> <span class="operator">=</span> childGroup;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelHandler</span> <span class="variable">currentChildHandler</span> <span class="operator">=</span> childHandler;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;</span><br><span class="line">    <span class="keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs;</span><br><span class="line">    <span class="keyword">synchronized</span> (childOptions) &#123;</span><br><span class="line">        currentChildOptions = childOptions.entrySet().toArray(newOptionArray(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (childAttrs) &#123;</span><br><span class="line">        currentChildAttrs = childAttrs.entrySet().toArray(newAttrArray(<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">// 为 NioServerSocketChannel 添加初始化器</span></span><br><span class="line">    p.addLast(<span class="keyword">new</span> <span class="title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">initChannel</span><span class="params">(<span class="keyword">final</span> Channel ch)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ch.pipeline();</span><br><span class="line">            <span class="type">ChannelHandler</span> <span class="variable">handler</span> <span class="operator">=</span> config.handler();</span><br><span class="line">            <span class="keyword">if</span> (handler != <span class="literal">null</span>) &#123;</span><br><span class="line">                pipeline.addLast(handler);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 初始化器的职责是将 ServerBootstrapAcceptor 加入至 NioServerSocketChannel</span></span><br><span class="line">            ch.eventLoop().execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> <span class="title class_">ServerBootstrapAcceptor</span>(</span><br><span class="line">                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键代码 <code>io.netty.channel.AbstractChannel.AbstractUnsafe#register</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="comment">// 一些检查，略...</span></span><br><span class="line"></span><br><span class="line">    AbstractChannel.<span class="built_in">this</span>.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 首次执行 execute 方法时，会启动 nio 线程，之后注册等操作在 nio 线程上执行</span></span><br><span class="line">            <span class="comment">// 因为只有一个 NioServerSocketChannel 因此，也只会有一个 boss nio 线程</span></span><br><span class="line">            <span class="comment">// 这行代码完成的事实是 main -&gt; nio boss 线程的切换</span></span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// 日志记录...</span></span><br><span class="line">            closeForcibly();</span><br><span class="line">            closeFuture.setClosed();</span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>io.netty.channel.AbstractChannel.AbstractUnsafe#register0</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">register0</span><span class="params">(ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">firstRegistration</span> <span class="operator">=</span> neverRegistered;</span><br><span class="line">        <span class="comment">// 1.2.1 原生的 nio channel 绑定到 selector 上，注意此时没有注册 selector 关注事件，附件为 NioServerSocketChannel</span></span><br><span class="line">        doRegister();</span><br><span class="line">        neverRegistered = <span class="literal">false</span>;</span><br><span class="line">        registered = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.2.2 执行 NioServerSocketChannel 初始化器的 initChannel</span></span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回调 3.2 io.netty.bootstrap.AbstractBootstrap#doBind0</span></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 对应 server socket channel 还未绑定，isActive 为 false</span></span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// Close the channel directly to avoid FD leak.</span></span><br><span class="line">        closeForcibly();</span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键代码 <code>io.netty.channel.ChannelInitializer#initChannel</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">initChannel</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (initMap.add(ctx)) &#123; <span class="comment">// Guard against re-entrance.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 1.2.2.1 执行初始化</span></span><br><span class="line">            initChannel((C) ctx.channel());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable cause) &#123;</span><br><span class="line">            exceptionCaught(ctx, cause);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 1.2.2.2 移除初始化器</span></span><br><span class="line">            <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> ctx.pipeline();</span><br><span class="line">            <span class="keyword">if</span> (pipeline.context(<span class="built_in">this</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">                pipeline.remove(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键代码 <code>io.netty.bootstrap.AbstractBootstrap#doBind0</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.1 或 3.2 执行 doBind0</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doBind0</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> ChannelFuture regFuture, <span class="keyword">final</span> Channel channel,</span></span><br><span class="line"><span class="params">        <span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line"></span><br><span class="line">    channel.eventLoop().execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (regFuture.isSuccess()) &#123;</span><br><span class="line">                channel.bind(localAddress, promise).addListener(ChannelFutureListener.CLOSE_ON_FAILURE);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                promise.setFailure(regFuture.cause());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键代码 <code>io.netty.channel.AbstractChannel.AbstractUnsafe#bind</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress, <span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">    assertEventLoop();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Boolean.TRUE.equals(config().getOption(ChannelOption.SO_BROADCAST)) &amp;&amp;</span><br><span class="line">        localAddress <span class="keyword">instanceof</span> InetSocketAddress &amp;&amp;</span><br><span class="line">        !((InetSocketAddress) localAddress).getAddress().isAnyLocalAddress() &amp;&amp;</span><br><span class="line">        !PlatformDependent.isWindows() &amp;&amp; !PlatformDependent.maybeSuperUser()) &#123;</span><br><span class="line">        <span class="comment">// 记录日志...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">wasActive</span> <span class="operator">=</span> isActive();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 3.3 执行端口绑定</span></span><br><span class="line">        doBind(localAddress);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">        closeIfClosed();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;</span><br><span class="line">        invokeLater(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                <span class="comment">// 3.4 触发 active 事件</span></span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    safeSetSuccess(promise);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.3 关键代码 <code>io.netty.channel.socket.nio.NioServerSocketChannel#doBind</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doBind</span><span class="params">(SocketAddress localAddress)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="number">7</span>) &#123;</span><br><span class="line">        javaChannel().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        javaChannel().socket().bind(localAddress, config.getBacklog());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.4 关键代码 <code>io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">    ctx.fireChannelActive();</span><br><span class="line">	<span class="comment">// 触发 read (NioServerSocketChannel 上的 read 不是读取数据，只是为了触发 channel 的事件注册)</span></span><br><span class="line">    readIfIsAutoRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键代码 <code>io.netty.channel.nio.AbstractNioChannel#doBeginRead</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> <span class="built_in">this</span>.selectionKey;</span><br><span class="line">    <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readPending = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">interestOps</span> <span class="operator">=</span> selectionKey.interestOps();</span><br><span class="line">    <span class="comment">// readInterestOp 取值是 16，在 NioServerSocketChannel 创建时初始化好，代表关注 accept 事件</span></span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="../../../images/image-20211019195130076.png" alt="image-20211019195130076"></p>
<h3 id="2-2-NioEventLoop-剖析"><a href="#2-2-NioEventLoop-剖析" class="headerlink" title="2.2 NioEventLoop 剖析"></a>2.2 NioEventLoop 剖析</h3><p><img src="../../../images/image-20211101210536521.png" alt="image-20211101210536521"></p>
<p>NioEventLoop 线程不仅要处理 IO 事件，还要处理 Task（包括普通任务和定时任务），</p>
<p>提交任务代码 <code>io.netty.util.concurrent.SingleThreadEventExecutor#execute</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>(<span class="string">&quot;task&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">inEventLoop</span> <span class="operator">=</span> inEventLoop();</span><br><span class="line">    <span class="comment">// 添加任务，其中队列使用了 jctools 提供的 mpsc 无锁队列</span></span><br><span class="line">    addTask(task);</span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop) &#123;</span><br><span class="line">        <span class="comment">// inEventLoop 如果为 false 表示由其它线程来调用 execute，即首次调用，这时需要向 eventLoop 提交首个任务，启动死循环，会执行到下面的 doStartThread</span></span><br><span class="line">        startThread();</span><br><span class="line">        <span class="keyword">if</span> (isShutdown()) &#123;</span><br><span class="line">            <span class="comment">// 如果已经 shutdown，做拒绝逻辑，代码略...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class="line">        <span class="comment">// 如果线程由于 IO select 阻塞了，添加的任务的线程需要负责唤醒 NioEventLoop 线程</span></span><br><span class="line">        wakeup(inEventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>唤醒 select 阻塞线程<code>io.netty.channel.nio.NioEventLoop#wakeup</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">wakeup</span><span class="params">(<span class="type">boolean</span> inEventLoop)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!inEventLoop &amp;&amp; wakenUp.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">        selector.wakeup();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动 EventLoop 主循环 <code>io.netty.util.concurrent.SingleThreadEventExecutor#doStartThread</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doStartThread</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> thread == <span class="literal">null</span>;</span><br><span class="line">    executor.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 将线程池的当前线程保存在成员变量中，以便后续使用</span></span><br><span class="line">            thread = Thread.currentThread();</span><br><span class="line">            <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                thread.interrupt();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            updateLastExecutionTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 调用外部类 SingleThreadEventExecutor 的 run 方法，进入死循环，run 方法见下</span></span><br><span class="line">                SingleThreadEventExecutor.<span class="built_in">this</span>.run();</span><br><span class="line">                success = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                logger.warn(<span class="string">&quot;Unexpected exception from an event executor: &quot;</span>, t);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				<span class="comment">// 清理工作，代码略...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>io.netty.channel.nio.NioEventLoop#run</code> 主要任务是执行死循环，不断看有没有新任务，有没有 IO 事件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// calculateStrategy 的逻辑如下：</span></span><br><span class="line">                <span class="comment">// 有任务，会执行一次 selectNow，清除上一次的 wakeup 结果，无论有没有 IO 事件，都会跳过 switch</span></span><br><span class="line">                <span class="comment">// 没有任务，会匹配 SelectStrategy.SELECT，看是否应当阻塞</span></span><br><span class="line">                <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line">                    <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> SelectStrategy.BUSY_WAIT:</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">                        <span class="comment">// 因为 IO 线程和提交任务线程都有可能执行 wakeup，而 wakeup 属于比较昂贵的操作，因此使用了一个原子布尔对象 wakenUp，它取值为 true 时，表示该由当前线程唤醒</span></span><br><span class="line">                        <span class="comment">// 进行 select 阻塞，并设置唤醒状态为 false</span></span><br><span class="line">                        <span class="type">boolean</span> <span class="variable">oldWakenUp</span> <span class="operator">=</span> wakenUp.getAndSet(<span class="literal">false</span>);</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">// 如果在这个位置，非 EventLoop 线程抢先将 wakenUp 置为 true，并 wakeup</span></span><br><span class="line">                        <span class="comment">// 下面的 select 方法不会阻塞</span></span><br><span class="line">                        <span class="comment">// 等 runAllTasks 处理完成后，到再循环进来这个阶段新增的任务会不会及时执行呢?</span></span><br><span class="line">                        <span class="comment">// 因为 oldWakenUp 为 true，因此下面的 select 方法就会阻塞，直到超时</span></span><br><span class="line">                        <span class="comment">// 才能执行，让 select 方法无谓阻塞</span></span><br><span class="line">                        select(oldWakenUp);</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">                            selector.wakeup();</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                rebuildSelector0();</span><br><span class="line">                handleLoopException(e);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            cancelledKeys = <span class="number">0</span>;</span><br><span class="line">            needsToSelectAgain = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// ioRatio 默认是 50</span></span><br><span class="line">            <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ioRatio</span> <span class="operator">=</span> <span class="built_in">this</span>.ioRatio;</span><br><span class="line">            <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// ioRatio 为 100 时，总是运行完所有非 IO 任务</span></span><br><span class="line">                    runAllTasks();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;                </span><br><span class="line">                <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ioStartTime</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    processSelectedKeys();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 记录 io 事件处理耗时</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">ioTime</span> <span class="operator">=</span> System.nanoTime() - ioStartTime;</span><br><span class="line">                    <span class="comment">// 运行非 IO 任务，一旦超时会退出 runAllTasks</span></span><br><span class="line">                    runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (isShuttingDown()) &#123;</span><br><span class="line">                closeAll();</span><br><span class="line">                <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            handleLoopException(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="⚠️-注意"><a href="#⚠️-注意" class="headerlink" title="⚠️ 注意"></a>⚠️ 注意</h4><blockquote>
<p>这里有个费解的地方就是 wakeup，它既可以由提交任务的线程来调用（比较好理解），也可以由 EventLoop 线程来调用（比较费解），这里要知道 wakeup 方法的效果：</p>
<ul>
<li>由非 EventLoop 线程调用，会唤醒当前在执行 select 阻塞的 EventLoop 线程</li>
<li>由 EventLoop 自己调用，会本次的 wakeup 会取消下一次的 select 操作</li>
</ul>
</blockquote>
<p>参考下图</p>
<p><img src="../../../images/0032.png"  /></p>
<p><code>io.netty.channel.nio.NioEventLoop#select</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">select</span><span class="params">(<span class="type">boolean</span> oldWakenUp)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">Selector</span> <span class="variable">selector</span> <span class="operator">=</span> <span class="built_in">this</span>.selector;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">selectCnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">currentTimeNanos</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">        <span class="comment">// 计算等待时间</span></span><br><span class="line">        <span class="comment">// * 没有 scheduledTask，超时时间为 1s</span></span><br><span class="line">        <span class="comment">// * 有 scheduledTask，超时时间为 `下一个定时任务执行时间 - 当前时间`</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">selectDeadLineNanos</span> <span class="operator">=</span> currentTimeNanos + delayNanos(currentTimeNanos);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">timeoutMillis</span> <span class="operator">=</span> (selectDeadLineNanos - currentTimeNanos + <span class="number">500000L</span>) / <span class="number">1000000L</span>;</span><br><span class="line">            <span class="comment">// 如果超时，退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (timeoutMillis &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (selectCnt == <span class="number">0</span>) &#123;</span><br><span class="line">                    selector.selectNow();</span><br><span class="line">                    selectCnt = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果期间又有 task 退出循环，如果没这个判断，那么任务就会等到下次 select 超时时才能被执行</span></span><br><span class="line">            <span class="comment">// wakenUp.compareAndSet(false, true) 是让非 NioEventLoop 不必再执行 wakeup</span></span><br><span class="line">            <span class="keyword">if</span> (hasTasks() &amp;&amp; wakenUp.compareAndSet(<span class="literal">false</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">                selector.selectNow();</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// select 有限时阻塞</span></span><br><span class="line">            <span class="comment">// 注意 nio 有 bug，当 bug 出现时，select 方法即使没有时间发生，也不会阻塞住，导致不断空轮询，cpu 占用 100%</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">selectedKeys</span> <span class="operator">=</span> selector.select(timeoutMillis);</span><br><span class="line">            <span class="comment">// 计数加 1</span></span><br><span class="line">            selectCnt ++;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 醒来后，如果有 IO 事件、或是由非 EventLoop 线程唤醒，或者有任务，退出循环</span></span><br><span class="line">            <span class="keyword">if</span> (selectedKeys != <span class="number">0</span> || oldWakenUp || wakenUp.get() || hasTasks() || hasScheduledTasks()) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">               	<span class="comment">// 线程被打断，退出循环</span></span><br><span class="line">                <span class="comment">// 记录日志</span></span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">if</span> (time - TimeUnit.MILLISECONDS.toNanos(timeoutMillis) &gt;= currentTimeNanos) &#123;</span><br><span class="line">                <span class="comment">// 如果超时，计数重置为 1，下次循环就会 break</span></span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="comment">// 计数超过阈值，由 io.netty.selectorAutoRebuildThreshold 指定，默认 512</span></span><br><span class="line">            <span class="comment">// 这是为了解决 nio 空轮询 bug</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                    selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;</span><br><span class="line">                <span class="comment">// 重建 selector</span></span><br><span class="line">                selector = selectRebuildSelector(selectCnt);</span><br><span class="line">                selectCnt = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            currentTimeNanos = time;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS) &#123;</span><br><span class="line">            <span class="comment">// 记录日志</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException e) &#123;</span><br><span class="line">        <span class="comment">// 记录日志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>处理 keys <code>io.netty.channel.nio.NioEventLoop#processSelectedKeys</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processSelectedKeys</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (selectedKeys != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过反射将 Selector 实现类中的就绪事件集合替换为 SelectedSelectionKeySet </span></span><br><span class="line">        <span class="comment">// SelectedSelectionKeySet 底层为数组实现，可以提高遍历性能（原本为 HashSet）</span></span><br><span class="line">        processSelectedKeysOptimized();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        processSelectedKeysPlain(selector.selectedKeys());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>io.netty.channel.nio.NioEventLoop#processSelectedKey</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> AbstractNioChannel.<span class="type">NioUnsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> ch.unsafe();</span><br><span class="line">    <span class="comment">// 当 key 取消或关闭时会导致这个 key 无效</span></span><br><span class="line">    <span class="keyword">if</span> (!k.isValid()) &#123;</span><br><span class="line">        <span class="comment">// 无效时处理...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">readyOps</span> <span class="operator">=</span> k.readyOps();</span><br><span class="line">        <span class="comment">// 连接事件</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ops</span> <span class="operator">=</span> k.interestOps();</span><br><span class="line">            ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">            k.interestOps(ops);</span><br><span class="line"></span><br><span class="line">            unsafe.finishConnect();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可写事件</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">            ch.unsafe().forceFlush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可读或可接入事件</span></span><br><span class="line">        <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是可接入 io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read</span></span><br><span class="line">            <span class="comment">// 如果是可读 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read</span></span><br><span class="line">            unsafe.read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class="line">        unsafe.close(unsafe.voidPromise());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-accept-剖析"><a href="#2-3-accept-剖析" class="headerlink" title="2.3 accept 剖析"></a>2.3 accept 剖析</h3><p><img src="../../../images/image-20211102194135611.png" alt=""></p>
<p>nio 中如下代码，在 netty 中的流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1 阻塞直到事件发生</span></span><br><span class="line">selector.select();</span><br><span class="line"></span><br><span class="line">Iterator&lt;SelectionKey&gt; iter = selector.selectedKeys().iterator();</span><br><span class="line"><span class="keyword">while</span> (iter.hasNext()) &#123;    </span><br><span class="line">    <span class="comment">//2 拿到一个事件</span></span><br><span class="line">    <span class="type">SelectionKey</span> <span class="variable">key</span> <span class="operator">=</span> iter.next();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3 如果是 accept 事件</span></span><br><span class="line">    <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4 执行 accept</span></span><br><span class="line">        <span class="type">SocketChannel</span> <span class="variable">channel</span> <span class="operator">=</span> serverSocketChannel.accept();</span><br><span class="line">        channel.configureBlocking(<span class="literal">false</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5 关注 read 事件</span></span><br><span class="line">        channel.register(selector, SelectionKey.OP_READ);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先来看可接入事件处理（accept）</p>
<p><code>io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">assert</span> <span class="title function_">eventLoop</span><span class="params">()</span>.inEventLoop();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelConfig</span> <span class="variable">config</span> <span class="operator">=</span> config();</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> pipeline();    </span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.<span class="type">Handle</span> <span class="variable">allocHandle</span> <span class="operator">=</span> unsafe().recvBufAllocHandle();</span><br><span class="line">    allocHandle.reset(config);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">closed</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">Throwable</span> <span class="variable">exception</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">				<span class="comment">// doReadMessages 中执行了 accept 并创建 NioSocketChannel 作为消息放入 readBuf</span></span><br><span class="line">                <span class="comment">// readBuf 是一个 ArrayList 用来缓存消息</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">localRead</span> <span class="operator">=</span> doReadMessages(readBuf);</span><br><span class="line">                <span class="keyword">if</span> (localRead == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (localRead &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                    closed = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">				<span class="comment">// localRead 为 1，就一条消息，即接收一个客户端连接</span></span><br><span class="line">                allocHandle.incMessagesRead(localRead);</span><br><span class="line">            &#125; <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            exception = t;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> readBuf.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">            readPending = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理</span></span><br><span class="line">            <span class="comment">// io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead</span></span><br><span class="line">            pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">        readBuf.clear();</span><br><span class="line">        allocHandle.readComplete();</span><br><span class="line">        pipeline.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (exception != <span class="literal">null</span>) &#123;</span><br><span class="line">            closed = closeOnReadError(exception);</span><br><span class="line"></span><br><span class="line">            pipeline.fireExceptionCaught(exception);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">            inputShutdown = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (isOpen()) &#123;</span><br><span class="line">                close(voidPromise());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">            removeReadOp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键代码 <code>io.netty.bootstrap.ServerBootstrap.ServerBootstrapAcceptor#channelRead</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> &#123;</span><br><span class="line">    <span class="comment">// 这时的 msg 是 NioSocketChannel</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Channel</span> <span class="variable">child</span> <span class="operator">=</span> (Channel) msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NioSocketChannel 添加  childHandler 即初始化器</span></span><br><span class="line">    child.pipeline().addLast(childHandler);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置选项</span></span><br><span class="line">    setChannelOptions(child, childOptions, logger);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</span><br><span class="line">        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 注册 NioSocketChannel 到 nio worker 线程，接下来的处理也移交至 nio worker 线程</span></span><br><span class="line">        childGroup.register(child).addListener(<span class="keyword">new</span> <span class="title class_">ChannelFutureListener</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">                <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                    forceClose(child, future.cause());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        forceClose(child, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又回到了熟悉的 <code>io.netty.channel.AbstractChannel.AbstractUnsafe#register</code>  方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="comment">// 一些检查，略...</span></span><br><span class="line"></span><br><span class="line">    AbstractChannel.<span class="built_in">this</span>.eventLoop = eventLoop;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">        register0(promise);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这行代码完成的事实是 nio boss -&gt; nio worker 线程的切换</span></span><br><span class="line">            eventLoop.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    register0(promise);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            <span class="comment">// 日志记录...</span></span><br><span class="line">            closeForcibly();</span><br><span class="line">            closeFuture.setClosed();</span><br><span class="line">            safeSetFailure(promise, t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>io.netty.channel.AbstractChannel.AbstractUnsafe#register0</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">register0</span><span class="params">(ChannelPromise promise)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">firstRegistration</span> <span class="operator">=</span> neverRegistered;</span><br><span class="line">        doRegister();</span><br><span class="line">        neverRegistered = <span class="literal">false</span>;</span><br><span class="line">        registered = <span class="literal">true</span>;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">// 执行初始化器，执行前 pipeline 中只有 head -&gt; 初始化器 -&gt; tail</span></span><br><span class="line">        pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line">        <span class="comment">// 执行后就是 head -&gt; logging handler -&gt; my handler -&gt; tail</span></span><br><span class="line"></span><br><span class="line">        safeSetSuccess(promise);</span><br><span class="line">        pipeline.fireChannelRegistered();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                <span class="comment">// 触发 pipeline 上 active 事件</span></span><br><span class="line">                pipeline.fireChannelActive();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                beginRead();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        closeForcibly();</span><br><span class="line">        closeFuture.setClosed();</span><br><span class="line">        safeSetFailure(promise, t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回到了熟悉的代码 <code>io.netty.channel.DefaultChannelPipeline.HeadContext#channelActive</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> &#123;</span><br><span class="line">    ctx.fireChannelActive();</span><br><span class="line">	<span class="comment">// 触发 read (NioSocketChannel 这里 read，只是为了触发 channel 的事件注册，还未涉及数据读取)</span></span><br><span class="line">    readIfIsAutoRead();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>io.netty.channel.nio.AbstractNioChannel#doBeginRead</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">SelectionKey</span> <span class="variable">selectionKey</span> <span class="operator">=</span> <span class="built_in">this</span>.selectionKey;</span><br><span class="line">    <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    readPending = <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">// 这时候 interestOps 是 0</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">interestOps</span> <span class="operator">=</span> selectionKey.interestOps();</span><br><span class="line">    <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 关注 read 事件</span></span><br><span class="line">        selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-4-read-剖析"><a href="#2-4-read-剖析" class="headerlink" title="2.4 read 剖析"></a>2.4 read 剖析</h3><p>再来看可读事件 <code>io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read</code>，注意发送的数据未必能够一次读完，因此会触发多次 nio read 事件，一次事件内会触发多次 pipeline read，一次事件会触发一次 pipeline read complete</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelConfig</span> <span class="variable">config</span> <span class="operator">=</span> config();</span><br><span class="line">    <span class="keyword">if</span> (shouldBreakReadReady(config)) &#123;</span><br><span class="line">        clearReadPending();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ChannelPipeline</span> <span class="variable">pipeline</span> <span class="operator">=</span> pipeline();</span><br><span class="line">    <span class="comment">// io.netty.allocator.type 决定 allocator 的实现</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">ByteBufAllocator</span> <span class="variable">allocator</span> <span class="operator">=</span> config.getAllocator();</span><br><span class="line">    <span class="comment">// 用来分配 byteBuf，确定单次读取大小</span></span><br><span class="line">    <span class="keyword">final</span> RecvByteBufAllocator.<span class="type">Handle</span> <span class="variable">allocHandle</span> <span class="operator">=</span> recvBufAllocHandle();</span><br><span class="line">    allocHandle.reset(config);</span><br><span class="line"></span><br><span class="line">    <span class="type">ByteBuf</span> <span class="variable">byteBuf</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">close</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            byteBuf = allocHandle.allocate(allocator);</span><br><span class="line">            <span class="comment">// 读取</span></span><br><span class="line">            allocHandle.lastBytesRead(doReadBytes(byteBuf));</span><br><span class="line">            <span class="keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                byteBuf.release();</span><br><span class="line">                byteBuf = <span class="literal">null</span>;</span><br><span class="line">                close = allocHandle.lastBytesRead() &lt; <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (close) &#123;</span><br><span class="line">                    readPending = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            allocHandle.incMessagesRead(<span class="number">1</span>);</span><br><span class="line">            readPending = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// 触发 read 事件，让 pipeline 上的 handler 处理，这时是处理 NioSocketChannel 上的 handler</span></span><br><span class="line">            pipeline.fireChannelRead(byteBuf);</span><br><span class="line">            byteBuf = <span class="literal">null</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// 是否要继续循环</span></span><br><span class="line">        <span class="keyword">while</span> (allocHandle.continueReading());</span><br><span class="line"></span><br><span class="line">        allocHandle.readComplete();</span><br><span class="line">        <span class="comment">// 触发 read complete 事件</span></span><br><span class="line">        pipeline.fireChannelReadComplete();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (close) &#123;</span><br><span class="line">            closeOnRead(pipeline);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        handleReadException(pipeline, byteBuf, t, close, allocHandle);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">            removeReadOp();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>io.netty.channel.DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle#continueReading(io.netty.util.UncheckedBooleanSupplier)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">continueReading</span><span class="params">(UncheckedBooleanSupplier maybeMoreDataSupplier)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">           <span class="comment">// 一般为 true</span></span><br><span class="line">           config.isAutoRead() &amp;&amp;</span><br><span class="line">           <span class="comment">// respectMaybeMoreData 默认为 true</span></span><br><span class="line">           <span class="comment">// maybeMoreDataSupplier 的逻辑是如果预期读取字节与实际读取字节相等，返回 true</span></span><br><span class="line">           (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &amp;&amp;</span><br><span class="line">           <span class="comment">// 小于最大次数，maxMessagePerRead 默认 16</span></span><br><span class="line">           totalMessages &lt; maxMessagePerRead &amp;&amp;</span><br><span class="line">           <span class="comment">// 实际读到了数据</span></span><br><span class="line">           totalBytesRead &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>职场适应力</title>
    <url>/posts/19249.html</url>
    <content><![CDATA[<p>一、规划未来—职业生涯认知</p>
<p>二、拥抱环境—适应职场环境</p>
<p>三、步步为营—提升职业能力</p>
<h1 id="职业生涯三阶段"><a href="#职业生涯三阶段" class="headerlink" title="职业生涯三阶段"></a>职业生涯三阶段</h1><p> 生理需要—安全需求—社交需要—尊重需要—自我实现</p>
<p> 生存期              发展期              自我实现期</p>
<p> 三个阶段的关系</p>
<p><img src="../../../images/image-20221219180156673.png" alt=""></p>
<p><img src="../../../images/image-20221220110724901.png" alt=""></p>
<h1 id="新员工的自我定位"><a href="#新员工的自我定位" class="headerlink" title="新员工的自我定位"></a>新员工的自我定位</h1><p> 职业生涯较色：职业潜力的开拓者</p>
<p> 岗位角色：品牌价值的传递者</p>
<h2 id="理解层次图"><a href="#理解层次图" class="headerlink" title="理解层次图"></a>理解层次图</h2><p><img src="../../../images/image-20220124145315085.png" alt=""></p>
<h2 id="两种心智模式"><a href="#两种心智模式" class="headerlink" title="两种心智模式"></a>两种心智模式</h2><p><img src="../../../images/image-20221220111011079.png" alt=""></p>
<h2 id="绩效的四个不等式"><a href="#绩效的四个不等式" class="headerlink" title="绩效的四个不等式"></a>绩效的四个不等式</h2><p>任务不等于结果</p>
<p>态度不等于结果</p>
<p>职责不等于结果</p>
<p>理由不等于结果</p>
<h1 id="将自己融入团队"><a href="#将自己融入团队" class="headerlink" title="将自己融入团队"></a>将自己融入团队</h1><p> 1.文化认同：情感、制度、价值观</p>
<p> 2.服从</p>
<p> 3.妥协：大方向不妥协，小问题可以</p>
<p> 4.合作：一个伟大的目标需要一个伟大的团队来完成</p>
<h2 id="认识机会"><a href="#认识机会" class="headerlink" title="认识机会"></a>认识机会</h2><p> 机会：机——变化，会—看到—眼光</p>
<p> 先知先觉：撞到机会、把握机会—撞不到机会、找机会—找不到机会、造机会</p>
<p> 后知后觉：撞到机会、四处张望—小心跟随、抓住机会</p>
<p> 不知不觉：失去机会，荒废一生</p>
<h2 id="认识付出"><a href="#认识付出" class="headerlink" title="认识付出"></a>认识付出</h2><p> 收入与付出（能力）成正比</p>
<p> 付出要先于回报</p>
<p> 非凡的付出获得非凡的回报</p>
<h2 id="认识公平、公正"><a href="#认识公平、公正" class="headerlink" title="认识公平、公正"></a>认识公平、公正</h2><p>角度决定观点：</p>
<p>近视让你觉得不公平，长期看就公平了</p>
<h1 id="职场情绪管理"><a href="#职场情绪管理" class="headerlink" title="职场情绪管理"></a>职场情绪管理</h1><p> 从负面经验中升华出正面意义</p>
<p> 慎用简单线性思维，不搞绝对化，不做非黑即白判断</p>
<p> 避免灌装思维，不以偏概全</p>
<p> 不泛化到每一时，不拿负面情绪遮蔽整个天空</p>
<h1 id="能力三核—才干是可以迁移的"><a href="#能力三核—才干是可以迁移的" class="headerlink" title="能力三核—才干是可以迁移的"></a>能力三核—才干是可以迁移的</h1><p><img src="../../../images/image-20221220111511765.png" alt=""></p>
<h1 id="职场必备能力模型"><a href="#职场必备能力模型" class="headerlink" title="职场必备能力模型"></a>职场必备能力模型</h1><p>学习适应能力</p>
<p>人际沟通能力</p>
<p>资源利用能力</p>
<p>自我管理能力</p>
<h2 id="学习的两种模式—相对成长和绝对成长"><a href="#学习的两种模式—相对成长和绝对成长" class="headerlink" title="学习的两种模式—相对成长和绝对成长"></a>学习的两种模式—相对成长和绝对成长</h2><p>绝对成长：</p>
<p>在市场的市值的提高，才叫绝对成长，永远把基点落在内部</p>
<p>相对成长：</p>
<p>金钱，权利，地位</p>
<h2 id="整合式学习：优化知识结构"><a href="#整合式学习：优化知识结构" class="headerlink" title="整合式学习：优化知识结构"></a>整合式学习：优化知识结构</h2><p>混乱的知识 约等于 垃圾</p>
<p>偏见谬误 约等于 愚昧无知</p>
<h2 id="赶超式提升：轻取竞争优势"><a href="#赶超式提升：轻取竞争优势" class="headerlink" title="赶超式提升：轻取竞争优势"></a>赶超式提升：轻取竞争优势</h2><p>找：世上不缺榜样</p>
<p>抄：模仿改良到颠覆</p>
<p>超：只是远源杂交</p>
<h1 id="职场必备能力之人际沟通能力"><a href="#职场必备能力之人际沟通能力" class="headerlink" title="职场必备能力之人际沟通能力"></a>职场必备能力之人际沟通能力</h1><p>有效沟通的要素</p>
<p>语言 7%</p>
<p>听觉 38%</p>
<p>视觉 55%</p>
<h2 id="沟通基本步骤"><a href="#沟通基本步骤" class="headerlink" title="沟通基本步骤"></a>沟通基本步骤</h2><p> 1.建立安全氛围</p>
<p> 2.倾听</p>
<p> 3.同步（认同、复述）</p>
<p> 4.澄清</p>
<p> 5.求同存异</p>
<p> 6.找到支点</p>
<p> 7.拟定行动方案</p>
]]></content>
      <categories>
        <category>职场适应</category>
      </categories>
  </entry>
  <entry>
    <title>Mysql (二)</title>
    <url>/posts/55410.html</url>
    <content><![CDATA[<h1 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h1><p>MySQL存储函数（自定义函数），函数一般用于计算和返回一个值，可以将经常需要使用的计算或功能写成一个函数。</p>
<p>存储函数和存储过程一样，都是在数据库中定义一些 SQL 语句的集合。</p>
<p>存储函数与存储过程的区别</p>
<ul>
<li>存储函数有且只有一个返回值，而存储过程可以有多个返回值，也可以没有返回值</li>
<li>存储函数只能有输入参数，而且不能带in, 而存储过程可以有多个in,out,inout参数</li>
<li>存储过程中的语句功能更强大，存储过程可以实现很复杂的业务逻辑，而函数有很多限制，如不能在函数中使用insert,update,delete,create等语句</li>
<li>存储函数只完成查询的工作，可接受输入参数并返回一个结果，也就是函数实现的功能针对性比较强</li>
<li>存储过程可以调用存储函数。但函数不能调用存储过程</li>
<li>存储过程一般是作为一个独立的部分来执行(call调用)。而函数可以作为查询语句的一个部分来调用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create function func_name ([param_name type[,...]])</span><br><span class="line">returns type</span><br><span class="line">[characteristic ...] </span><br><span class="line">begin</span><br><span class="line">    routine_body</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">参数说明：</span><br><span class="line">（1）func_name ：存储函数的名称。</span><br><span class="line">（2）param_name type：可选项，指定存储函数的参数。type参数用于指定存储函数的参数类型，该类型可以是MySQL数据库中所有支持的类型。</span><br><span class="line">（3）RETURNS type：指定返回值的类型。</span><br><span class="line">（4）characteristic：可选项，指定存储函数的特性。</span><br><span class="line">（5）routine_body：SQL代码内容</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">create database mydb9_function;</span><br><span class="line">-- 导入测试数据</span><br><span class="line">use mydb9_function;</span><br><span class="line">set global log_bin_trust_function_creators=TRUE; -- 信任子程序的创建者</span><br><span class="line"> </span><br><span class="line">-- 创建存储函数-没有输输入参数</span><br><span class="line">drop function if exists myfunc1_emp;</span><br><span class="line"> </span><br><span class="line">delimiter $$</span><br><span class="line">create function myfunc1_emp() returns int</span><br><span class="line">begin</span><br><span class="line">  declare cnt int default 0;</span><br><span class="line">    select count(*) into  cnt from emp;</span><br><span class="line">  return cnt;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line">-- 调用存储函数</span><br><span class="line">select myfunc1_emp();</span><br><span class="line"></span><br><span class="line">-- 创建存储过程-有输入参数</span><br><span class="line"> </span><br><span class="line">drop function if exists myfunc2_emp;</span><br><span class="line">delimiter $$</span><br><span class="line">create function myfunc2_emp(in_empno int) returns varchar(50)</span><br><span class="line">begin</span><br><span class="line">    declare out_name varchar(50);</span><br><span class="line">    select ename into out_name from emp where  empno = in_empno;</span><br><span class="line">    return out_name;</span><br><span class="line">end $$</span><br><span class="line">delimiter ;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">select myfunc2_emp(1008);</span><br></pre></td></tr></table></figure>
<h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><p>触发器，就是一种特殊的存储过程。触发器和存储过程一样是一个能够完成特定功能、存储在数据库服务器上的SQL片段，但是触发器无需调用，当对数据库表中的数据执行DML操作时自动触发这个SQL片段的执行，无需手动条用</p>
<p>mysql中，只有执行insert,delete,update操作时才能触发触发器的执行</p>
<p>触发器的这种特性可以协助应用在数据库端确保数据的完整性 , 日志记录 , 数据校验等操作 。</p>
<p>使用别名 OLD 和 NEW 来引用触发器中发生变化的记录内容，这与其他的数据库是相似的。现在触发器还只支持行级触发，不支持语句级触发。</p>
<p><img src="../../../images/image-20230612164347819.png" alt="image-20230612164347819"></p>
<p>特性</p>
<ul>
<li>什么条件会触发：I、D、U</li>
<li>什么时候触发：在增删改前或者后</li>
<li>触发频率：针对每一行执行</li>
<li>触发器定义在表上，附着在表上</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建只有一个执行语句的触发器</span><br><span class="line">create trigger 触发器名 before|after 触发事件</span><br><span class="line">on 表名 for each row </span><br><span class="line">执行语句;</span><br><span class="line"></span><br><span class="line">-- 创建有多个执行语句的触发器</span><br><span class="line">create trigger 触发器名 before|after  触发事件 </span><br><span class="line">on 表名 for each row</span><br><span class="line">begin</span><br><span class="line">     执行语句列表</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">-- 数据准备</span><br><span class="line">create database if not exists mydb10_trigger;</span><br><span class="line">use mydb10_trigger;</span><br><span class="line"> </span><br><span class="line">-- 用户表</span><br><span class="line">create table user(</span><br><span class="line">    uid int primary key ,</span><br><span class="line">    username varchar(50) not null,</span><br><span class="line">    password varchar(50) not null</span><br><span class="line">);</span><br><span class="line">-- 用户信息操作日志表</span><br><span class="line">create table user_logs(</span><br><span class="line">    id int primary key auto_increment,</span><br><span class="line">    time timestamp,</span><br><span class="line">    log_text varchar(255)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 如果触发器存在，则先删除</span><br><span class="line">drop trigger if  exists trigger_test1;</span><br><span class="line"> </span><br><span class="line">-- 创建触发器trigger_test1</span><br><span class="line">create trigger trigger_test1</span><br><span class="line">after insert on user -- 触发时机：当添加user表数据时触发</span><br><span class="line">for each row</span><br><span class="line">insert into user_logs values(NULL,now(), &#x27;有新用户注册&#x27;);</span><br><span class="line"> </span><br><span class="line">-- 添加数据，触发器自动执行并添加日志代码</span><br><span class="line">insert into user values(1,&#x27;张三&#x27;,&#x27;123456&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 如果触发器trigger_test2存在，则先删除</span><br><span class="line">drop trigger if exists trigger_test2;</span><br><span class="line"></span><br><span class="line">-- 创建触发器trigger_test2</span><br><span class="line">delimiter $$</span><br><span class="line">create trigger trigger_test2</span><br><span class="line">after update on user  -- 触发时机：当修改user表数据时触发</span><br><span class="line">for each row -- 每一行</span><br><span class="line">begin</span><br><span class="line">insert into user_logs values(NULL,now(), &#x27;用户修改发生了修改&#x27;);</span><br><span class="line">end $$</span><br><span class="line"> </span><br><span class="line">delimiter ;</span><br><span class="line"> </span><br><span class="line">-- 添加数据，触发器自动执行并添加日志代码</span><br><span class="line">update user set password = &#x27;888888&#x27; where uid = 1;</span><br></pre></td></tr></table></figure>
<p>MySQL 中定义了 NEW 和 OLD，用来表示触发器的所在表中，触发了触发器的那一行数据，来引用触发器中发生变化的记录内容，具体地</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>触发器类型</strong></th>
<th><strong>触发器类型NEW  和 OLD的使用</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>INSERT  型触发器</td>
<td>NEW  表示将要或者已经新增的数据</td>
</tr>
<tr>
<td>UPDATE  型触发器</td>
<td>OLD  表示修改之前的数据  ,  NEW 表示将要或已经修改后的数据</td>
</tr>
<tr>
<td>DELETE  型触发器</td>
<td>OLD  表示将要或者已经删除的数据</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NEW.columnName （columnName为相应数据表某一列名）</span><br><span class="line"></span><br><span class="line">create trigger trigger_test3 after insert</span><br><span class="line">on user for each row</span><br><span class="line">insert into user_logs values(NULL,now(),concat(&#x27;有新用户添加，信息为:&#x27;,NEW.uid,NEW.username,NEW.password));</span><br><span class="line"> </span><br><span class="line">-- 测试</span><br><span class="line">insert into user values(4,&#x27;赵六&#x27;,&#x27;123456&#x27;);</span><br><span class="line">-- 查看触发器</span><br><span class="line">show triggers;</span><br><span class="line"></span><br><span class="line">-- 删除触发器</span><br><span class="line">-- drop trigger [if exists] trigger_name </span><br><span class="line">drop trigger if exists trigger_test1;</span><br></pre></td></tr></table></figure>
<p>注意事项</p>
<ul>
<li>MYSQL中触发器中不能对本表进行 insert ,update ,delete 操作，以免递归循环触发</li>
<li>尽量少使用触发器，假设触发器触发每次执行1s，insert table 500条数据，那么就需要触发500次触发器，光是触发器执行的时间就花费了500s，而insert 500条数据一共是1s，那么这个insert的效率就非常低了。</li>
<li>触发器是针对每一行的；对增删改非常频繁的表上切记不要使用触发器，因为它会非常消耗资源。 </li>
</ul>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><p>索引是通过某种算法，构建出一个数据模型，用于快速找出在某个列中有一特定值的行，不使用索引，MySQL必须从第一条记录开始读完整个表，直到找出相关的行，表越大，查询数据所花费的时间就越多，如果表中查询的列有一个索引，MySQL能够快速到达一个位置去搜索数据文件，而不必查看所有数据，那么将会节省很大一部分时间。</p>
<p>索引类似一本书的目录，比如要查找’student’这个单词，可以先找到s开头的页然后向后查找，这个就类似索引。</p>
<p>索引是存储引擎用来快速查找记录的一种数据结构，</p>
<p>按照实现的方式类分，主要有Hash索引和B+Tree索引</p>
<blockquote>
<p>Hash 索引</p>
</blockquote>
<p><strong>优点：</strong>通过字段的值计算的hash值，定位数据非常快。 <strong>缺点：</strong>不能进行范围查找，因为散列表中的值是无序的，无法进行大小的比较。</p>
<p><img src="../../../images/image-20230612174411032.png" alt="image-20230612174411032"></p>
<blockquote>
<p>B+Tree索引</p>
</blockquote>
<p>二叉树</p>
<p><strong>特性：</strong>分为左子树、右子树和根节点，左子树比根节点值要小，右子树比根节点值要大 <strong>缺点：</strong>有可能产生不平衡 类似于链表的结构 。</p>
<p><img src="../../../images/image-20230613093420433.png" alt="image-20230613093420433"></p>
<p>平衡二叉树</p>
<p><strong>特点：</strong></p>
<ul>
<li>它的左子树和右子树都是平衡二叉树</li>
<li>左子树比中间小，右子树比中间值大</li>
<li>左子树和右子树的深度之差的绝对值不超过1</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>插入操作需要旋转</li>
<li>支持范围查询，但回旋查询效率较低，比如要查找大于8的，会回旋到父节点7、10。</li>
<li>如果存放几百条数据的情况下，树高度越高，查询效率会越慢</li>
</ul>
<p>BTREE树</p>
<p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构，Btree结构可以有效的解决之前的相关算法遇到的问题。</p>
<p><img src="../../../images/image-20230613093556738.png" alt="image-20230613093556738"></p>
<p>B+ Trees</p>
<p><img src="../../../images/image-20230612174920720.png" alt=""></p>
<p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。</p>
<p><img src="../../../images/image-20230613093653894.png" alt="image-20230613093653894"></p>
<p>InnoDB的叶节点的data域存放的是数据，相比MyISAM效率要高一些，但是比较占硬盘内存大小。</p>
<p><img src="../../../images/image-20230613093723002.png" alt="image-20230613093723002"></p>
<p>按照功能划分，索引划为以下分类:</p>
<p><img src="../../../images/image-20230612174951919.png" alt="image-20230612174951919"></p>
<h2 id="单列索引"><a href="#单列索引" class="headerlink" title="单列索引"></a>单列索引</h2><p>一个索引只包含单个列，但一个表中可以有多个单列索引;</p>
<p>普通索引：MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database mydb5;</span><br><span class="line">use mydb5;</span><br><span class="line"></span><br><span class="line">-- 方式1-创建表的时候直接指定</span><br><span class="line">create  table student(</span><br><span class="line">    sid int primary key,</span><br><span class="line">    card_id varchar(20),</span><br><span class="line">    name varchar(20),</span><br><span class="line">    gender varchar(20),</span><br><span class="line">    age int,</span><br><span class="line">    birth date, </span><br><span class="line">    phone_num varchar(20),</span><br><span class="line">    score double,</span><br><span class="line">    index index_name(name) -- 给name列创建索引</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 方式2-直接创建</span><br><span class="line">-- create index indexname on tablename(columnname); </span><br><span class="line">create index index_gender on student(gender); </span><br><span class="line"></span><br><span class="line">-- 方式3-修改表结构(添加索引)</span><br><span class="line">-- alter table tablename add index indexname(columnname)</span><br><span class="line">alter table student add index index_age(age);</span><br><span class="line"></span><br><span class="line">-- 1、查看数据库所有索引 </span><br><span class="line">-- select * from mysql.`innodb_index_stats` a where a.`database_name` = &#x27;数据库名’; </span><br><span class="line">select * from mysql.`innodb_index_stats` a where a.`database_name` = &#x27;mydb5&#x27;;</span><br><span class="line"></span><br><span class="line">-- 2、查看表中所有索引 </span><br><span class="line">-- select * from mysql.`innodb_index_stats` a where a.`database_name` = &#x27;数据库名&#x27; and a.table_name like &#x27;%表名%’;</span><br><span class="line">select * from mysql.`innodb_index_stats` a where a.`database_name` = &#x27;mydb5&#x27; and a.table_name like &#x27;%student%&#x27;;</span><br><span class="line"></span><br><span class="line">-- 3、查看表中所有索引 </span><br><span class="line">-- show index from table_name; </span><br><span class="line">show index from student;</span><br><span class="line"></span><br><span class="line">-- 删除索引</span><br><span class="line">drop index 索引名 on 表名 </span><br><span class="line">-- 或 </span><br><span class="line">alter table 表名 drop index 索引名 </span><br><span class="line"></span><br><span class="line">drop index index_gender on student </span><br><span class="line">alter table student drop index index_name</span><br></pre></td></tr></table></figure>
<p>唯一索引</p>
<p>唯一索引与前面的普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 方式1-创建表的时候直接指定</span><br><span class="line">create  table student2(</span><br><span class="line">    sid int primary key,</span><br><span class="line">    card_id varchar(20),</span><br><span class="line">    name varchar(20),</span><br><span class="line">    gender varchar(20),</span><br><span class="line">    age int,</span><br><span class="line">    birth date, </span><br><span class="line">    phone_num varchar(20),</span><br><span class="line">    score double,</span><br><span class="line">    unique index_card_id(card_id) -- 给card_id列创建索引</span><br><span class="line">);</span><br><span class="line">-- 方式2-直接创建</span><br><span class="line">-- create unique index 索引名 on 表名(列名) </span><br><span class="line">create unique index index_card_id on student2(card_id);</span><br><span class="line"></span><br><span class="line">-- 方式3-修改表结构(添加索引)</span><br><span class="line">-- alter table 表名 add unique [索引名] (列名)</span><br><span class="line">alter table student2 add unique index_phone_num(phone_num)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>主键索引</p>
<p>每张表一般都会有自己的主键，当我们在创建表时，MySQL会自动在主键列上建立一个索引，这就是主键索引。主键是具有唯一性并且不允许为NULL，所以他是一种特殊的唯一索引</p>
<h2 id="组合索引"><a href="#组合索引" class="headerlink" title="组合索引"></a>组合索引</h2><p>组合索引也叫复合索引，指的是我们在建立索引的时候使用多个字段，例如同时使用身份证和手机号建立索引，同样的可以建立为普通索引或者是唯一索引。</p>
<p>复合索引的使用复合最左原则</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建索引的基本语法 </span><br><span class="line">create index indexname on table_name(column1(length),column2(length)); </span><br><span class="line"></span><br><span class="line">-- 组合索引</span><br><span class="line">use mydb5;</span><br><span class="line">-- 创建索引的基本语法-- 普通索引</span><br><span class="line">-- create index indexname on table_name(column1(length),column2(length)); </span><br><span class="line">create index index_phone_name on student(phone_num,name);</span><br><span class="line">-- 操作-删除索引</span><br><span class="line"> drop index index_phone_name on student; </span><br><span class="line">-- 创建索引的基本语法-- 唯一索引</span><br><span class="line">create  unique index index_phone_name on student(phone_num,name); </span><br><span class="line"></span><br><span class="line">select * from student where name = &#x27;张三&#x27;; </span><br><span class="line">select * from student where phone_num = &#x27;15100046637&#x27;; </span><br><span class="line">select * from student where phone_num = &#x27;15100046637&#x27; and name = &#x27;张三&#x27;; </span><br><span class="line">select * from student where name = &#x27;张三&#x27; and phone_num = &#x27;15100046637&#x27;; </span><br><span class="line">/* </span><br><span class="line">  三条sql只有 2 、 3、4能使用的到索引idx_phone_name,因为条件里面必须包含索引前面的字段  才能够进行匹配。</span><br><span class="line">  而3和4相比where条件的顺序不一样，为什么4可以用到索引呢？是因为mysql本身就有一层sql优化，他会根据sql来识别出来该用哪个索引，我们可以理解为3和4在mysql眼中是等价的。 </span><br><span class="line"></span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><p>全文索引的关键字是fulltext</p>
<p>全文索引主要用来查找文本中的关键字，而不是直接与索引中的值相比较，它更像是一个搜索引擎，基于相似度的查询，而不是简单的where语句的参数匹配。</p>
<p>用 like + % 就可以实现模糊匹配了，为什么还要全文索引？like + % 在文本比较少时是合适的，但是对于大量的文本数据检索，是不可想象的。全文索引在大量的数据面前，能比 like + % 快 N 倍，速度不是一个数量级，但是全文索引可能存在精度问题。</p>
<p>全文索引的版本、存储引擎、数据类型的支持情况：</p>
<ul>
<li>MySQL 5.6 以前的版本，只有 MyISAM 存储引擎支持全文索引；</li>
<li>MySQL 5.6 及以后的版本，MyISAM 和 InnoDB 存储引擎均支持全文索引;</li>
<li>只有字段的数据类型为 char、varchar、text 及其系列才可以建全文索引；</li>
<li>在数据量较大时候，现将数据放入一个没有全局索引的表中，然后再用create index创建fulltext索引，要比先为一张表建立fulltext然后再将数据写入的速度快很多；</li>
<li>测试或使用全文索引时，要先看一下自己的 MySQL 版本、存储引擎和数据类型是否支持全文索引。</li>
</ul>
<p>MySQL 中的全文索引，有两个变量，最小搜索长度和最大搜索长度，对于长度小于最小搜索长度和大于最大搜索长度的词语，都不会被索引。通俗点就是说，想对一个词语使用全文索引搜索，那么这个词语的长度必须在以上两个变量的区间内。这两个的默认值可以使用以下命令查看:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%ft%&#x27;;</span><br></pre></td></tr></table></figure>
<p>参数解释:</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>#</th>
<th>参数名称</th>
<th>默认值</th>
<th>最小值</th>
<th>最大值</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>ft_min_word_len</td>
<td>4</td>
<td>1</td>
<td>3600</td>
<td>MyISAM  引擎表全文索引包含的最小词长度</td>
</tr>
<tr>
<td>2</td>
<td>ft_query_expansion_limit</td>
<td>20</td>
<td>0</td>
<td>1000</td>
<td>MyISAM引擎表使用  with  query expansion 进行全文搜索的最大匹配数</td>
</tr>
<tr>
<td>3</td>
<td>innodb_ft_min_token_size</td>
<td>3</td>
<td>0</td>
<td>16</td>
<td>InnoDB  引擎表全文索引包含的最小词长度</td>
</tr>
<tr>
<td>4</td>
<td>innodb_ft_max_token_size</td>
<td>84</td>
<td>10</td>
<td>84</td>
<td>InnoDB  引擎表全文索引包含的最大词长度</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建表的时候添加全文索引</span><br><span class="line">create table t_article (</span><br><span class="line">     id int primary key auto_increment ,</span><br><span class="line">     title varchar(255) ,</span><br><span class="line">     content varchar(1000) ,</span><br><span class="line">     writing_date date -- , </span><br><span class="line">     -- fulltext (content) -- 创建全文检索</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">insert into t_article values(null,&quot;Yesterday Once More&quot;,&quot;When I was young I listen to the radio&quot;,&#x27;2021-10-01&#x27;);</span><br><span class="line">insert into t_article values(null,&quot;Right Here Waiting&quot;,&quot;Oceans apart, day after day,and I slowly go insane&quot;,&#x27;2021-10-02&#x27;); </span><br><span class="line">insert into t_article values(null,&quot;My Heart Will Go On&quot;,&quot;every night in my dreams,i see you, i feel you&quot;,&#x27;2021-10-03&#x27;);</span><br><span class="line">insert into t_article values(null,&quot;Everything I Do&quot;,&quot;eLook into my eyes,You will see what you mean to me&quot;,&#x27;2021-10-04&#x27;);</span><br><span class="line">insert into t_article values(null,&quot;Called To Say I Love You&quot;,&quot;say love you no new year&#x27;s day, to celebrate&quot;,&#x27;2021-10-05&#x27;);</span><br><span class="line">insert into t_article values(null,&quot;Nothing&#x27;s Gonna Change My Love For You&quot;,&quot;if i had to live my life without you near me&quot;,&#x27;2021-10-06&#x27;);</span><br><span class="line">insert into t_article values(null,&quot;Everybody&quot;,&quot;We&#x27;re gonna bring the flavor show U how.&quot;,&#x27;2021-10-07&#x27;);</span><br><span class="line"></span><br><span class="line">-- 修改表结构添加全文索引</span><br><span class="line">alter table t_article add fulltext index_content(content)</span><br><span class="line"> </span><br><span class="line">-- 直接添加全文索引</span><br><span class="line">create fulltext index index_content on t_article(content);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用全文索引</p>
<p>和常用的模糊匹配使用 like + % 不同，全文索引有自己的语法格式，使用 match 和 against 关键字，格式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">match (col1,col2,...)  against(expr [search_modifier])</span><br><span class="line"></span><br><span class="line">select * from t_article where match(content) against(&#x27;yo’); -- 没有结果 单词数需要大于等于3 </span><br><span class="line">select * from t_article where match(content) against(&#x27;you&#x27;); -- 有结果</span><br></pre></td></tr></table></figure>
<h2 id="空间索引"><a href="#空间索引" class="headerlink" title="空间索引"></a>空间索引</h2><p>MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型</p>
<p>空间索引是对空间数据类型的字段建立的索引，MYSQL中的空间数据类型有4种，分别是GEOMETRY、POINT、LINESTRING、POLYGON。</p>
<p>MYSQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类型的语法创建空间索引。</p>
<p>创建空间索引的列，必须将其声明为NOT NULL。</p>
<p>空间索引一般是用的比较少，了解即可。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>含义</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>Geometry</td>
<td>空间数据</td>
<td>任何一种空间类型</td>
</tr>
<tr>
<td>Point</td>
<td>点</td>
<td>坐标值</td>
</tr>
<tr>
<td>LineString</td>
<td>线</td>
<td>有一系列点连接而成</td>
</tr>
<tr>
<td>Polygon</td>
<td>多边形</td>
<td>由多条线组成</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table shop_info (</span><br><span class="line">  id  int  primary key auto_increment comment &#x27;id&#x27;,</span><br><span class="line">  shop_name varchar(64) not null comment &#x27;门店名称&#x27;,</span><br><span class="line">  geom_point geometry not null comment &#x27;经纬度&#x27;,</span><br><span class="line">  spatial key geom_index(geom_point)</span><br><span class="line">);</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">use itcast_shop;</span><br><span class="line"> </span><br><span class="line">-- 创建临时表</span><br><span class="line">create  temporary  table tmp_goods_cat</span><br><span class="line">as</span><br><span class="line">select t3.catid   as cat_id_l3,   -- 3级分类id</span><br><span class="line">       t3.catname as cat_name_l3, -- 3级分类名称</span><br><span class="line">       t2.catid   as cat_id_l2,   -- 2级分类id</span><br><span class="line">       t2.catname as cat_name_l2, -- 2级分类名称</span><br><span class="line">       t1.catid   as cat_id_l1,   -- 1级分类id</span><br><span class="line">       t1.catname as cat_name_l1  -- 1级分类名称</span><br><span class="line">from itcast_shop.itheima_goods_cats t3,</span><br><span class="line">     itcast_shop.itheima_goods_cats t2,</span><br><span class="line">     itcast_shop.itheima_goods_cats t1</span><br><span class="line">where t3.parentid = t2.catid</span><br><span class="line">  and t2.parentid = t1.catid</span><br><span class="line">  and t3.cat_level = 3;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- -- 统计分析不同一级商品分类对应的总金额、总笔数</span><br><span class="line">select</span><br><span class="line">  &#x27;2019-09-05&#x27;,</span><br><span class="line">  t1.cat_name_l1 as goods_cat_l1,</span><br><span class="line">  sum(t3.payprice * t3.goodsnum) as total_money,</span><br><span class="line">  count(distinct t3.orderid) as total_cnt</span><br><span class="line">from</span><br><span class="line">  tmp_goods_cat t1</span><br><span class="line">left join itheima_goods t2</span><br><span class="line">  on t1.cat_id_l3 = t2.goodscatid</span><br><span class="line">left join itheima_order_goods t3</span><br><span class="line">  on t2.goodsid = t3.goodsid</span><br><span class="line">where</span><br><span class="line">  substring(t3.createtime, 1, 10) = &#x27;2019-09-05&#x27;</span><br><span class="line">group by</span><br><span class="line">  t1.cat_name_l1;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">-- 创建索引</span><br><span class="line">create unique index idx_goods_cat3 on tmp_goods_cat(cat_id_l3);</span><br><span class="line">create unique index idx_itheima_goods on itheima_goods(goodsid);    </span><br><span class="line">create index idx_itheima__order_goods on itheima_order_goods(goodsid);  </span><br><span class="line">-- 可以看到添加索引之后，查询速度明显提高了很多。</span><br></pre></td></tr></table></figure>
<p>索引的优点</p>
<ul>
<li>大大加快数据的查询速度</li>
<li>使用分组和排序进行数据查询时，可以显著减少查询时分组和排序的时间</li>
<li>创建唯一索引，能够保证数据库表中每一行数据的唯一性</li>
<li>在实现数据的参考完整性方面，可以加速表和表之间的连接</li>
</ul>
<p>索引的缺点</p>
<ul>
<li>创建索引和维护索引需要消耗时间，并且随着数据量的增加，时间也会增加</li>
<li>索引需要占据磁盘空间</li>
<li>对数据表中的数据进行增加，修改，删除时，索引也要动态的维护，降低了维护的速度</li>
</ul>
<p>创建索引的原则</p>
<ul>
<li>更新频繁的列不应设置索引</li>
<li>数据量小的表不要使用索引（毕竟总共2页的文档，还要目录吗？）</li>
<li>重复数据多的字段不应设为索引（比如性别，只有男和女，一般来说：重复的数据超过百分之15就不该建索引）</li>
<li>首先应该考虑对where 和 order by 涉及的列上建立索引</li>
</ul>
<p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。</p>
<p>这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。</p>
<p>换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数</p>
<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><p>数据库存储引擎是数据库底层软件组织，数据库管理系统（DBMS）使用数据引擎进行创建、查询、更新和删除数据。</p>
<p>不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能。现在许多不同的数据库管理系统都支持多种不同的数据引擎。MySQL的核心就是存储引擎。</p>
<p>用户可以根据不同的需求为数据表选择不同的存储引擎</p>
<p>可以使用 SHOW ENGINES 命令 可以查看Mysql的所有执行引擎，默认的执行引擎是innoDB 支持事务，行级锁定和外键。</p>
<p>分类：</p>
<ul>
<li><strong>MyISAM</strong>:  Mysql 5.5之前的默认数据库引擎，最为常用。拥有较高的插入，查询速度，但不支持事务</li>
<li><strong>InnoDB</strong>: 事务型速记的首选引擎，支持ACID事务，支持行级锁定，MySQL5.5成为默认数据库引擎</li>
<li><strong>Memory</strong> : 所有数据置于内存的存储引擎，拥有极高的插入，更新和查询效率。但是会占用和数据量成正比的内存空间。并且其内容会在MYSQL重新启动是会丢失</li>
<li><strong>Archive</strong> : •非常适合存储大量的独立的，作为历史记录的数据。因为它们不经常被读取。Archive 拥有高效的插入速度，但其对查询的支持相对较差</li>
<li><strong>Federated</strong> : 将不同的 MySQL 服务器联合起来，逻辑上组成一个完整的数据库。非常适合分布式应用</li>
<li><strong>CSV</strong> ：逻辑上由逗号分割数据的存储引擎。它会在数据库子目录里为每个数据表创建一个 .csv 文件。这是一种普通文本文件，每个数据行占用一个文本行。CSV 存储引擎不支持索引。</li>
<li><strong>BlackHole</strong>： 黑洞引擎，写入的任何数据都会消失，一般用于记录 binlog 做复制的中继</li>
<li><strong>ERFORMANCE_SCHEMA</strong> : 存储引擎该引擎主要用于收集数据库服务器性能参数。</li>
<li><strong>Mrg_Myisam Merge</strong> : 存储引擎，是一组MyIsam的组合，也就是说，他将MyIsam引擎的多个表聚合起来，但是他的内部没有数据，真正的数据依然是MyIsam引擎的表中，但是可以直接进行查询、删除更新等操作。</li>
</ul>
<p><img src="../../../images/image-20230613094646775.png" alt="image-20230613094646775"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询当前数据库支持的存储引擎：</span><br><span class="line">show engines;</span><br><span class="line"> </span><br><span class="line">-- 查看当前的默认存储引擎：</span><br><span class="line">show variables like ‘%storage_engine%’;</span><br><span class="line"></span><br><span class="line">-- 查看某个表用了什么引擎(在显示结果里参数engine后面的就表示该表当前用的存储引擎): </span><br><span class="line">show create table student; </span><br><span class="line"> </span><br><span class="line">-- 创建新表时指定存储引擎：</span><br><span class="line">create table(...) engine=MyISAM;</span><br><span class="line"> </span><br><span class="line">-- 修改数据库引擎</span><br><span class="line">alter table student engine = INNODB;</span><br><span class="line">alter table student engine = MyISAM;</span><br><span class="line"></span><br><span class="line">-- 修改MySQL默认存储引擎方法</span><br><span class="line">1. 关闭mysql服务 </span><br><span class="line">2. 找到mysql安装目录下的my.ini文件： </span><br><span class="line">3. 找到default-storage-engine=INNODB 改为目标引擎，</span><br><span class="line">   如：default-storage-engine=MYISAM </span><br><span class="line">4. 启动mysql服务</span><br></pre></td></tr></table></figure>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>在MySQL中的事务（Transaction）是由存储引擎实现的，在MySQL中，只有InnoDB存储引擎才支持事务。</p>
<p>事务处理可以用来维护数据库的完整性，保证成批的 SQL 语句要么全部执行，要么全部不执行。</p>
<p>事务用来管理 DDL、DML、DCL 操作，比如 insert,update,delete 语句，默认是自动提交的。</p>
<p>MySQL的事务操作主要有以下三种</p>
<ul>
<li>开启事务：Start Transaction<ul>
<li>任何一条DML语句(insert、update、delete)执行，标志事务的开启</li>
<li>命令：BEGIN 或 START TRANSACTION</li>
</ul>
</li>
<li>提交事务：Commit Transaction<ul>
<li>成功的结束，将所有的DML语句操作历史记录和底层硬盘数据来一次同步</li>
<li>命令：COMMIT</li>
</ul>
</li>
<li>回滚事务：Rollback Transaction<ul>
<li>失败的结束，将所有的DML语句操作历史记录全部清空</li>
<li>命令：ROLLBACK </li>
</ul>
</li>
</ul>
<p>之前的所有SQL操作其实也有事务，只是MySQL自动帮我们完成的，每执行一条SQL时MySQL就帮我们自动提交事务，因此如果想要手动控制事务，则必须关闭MySQL的事务自动提交。</p>
<p>在MySQL中直接用 SET 来改变 MySQL 的自动提交模式:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set autocommit=0 禁止自动提交 </span><br><span class="line">set autocommit=1 开启自动提交 </span><br><span class="line">create database if not exists mydb12_transcation;</span><br><span class="line">use mydb12_transcation;</span><br><span class="line">-- 创建账户表</span><br><span class="line">create table account(</span><br><span class="line">    id int primary key, -- 账户id</span><br><span class="line">    name varchar(20), -- 账户名</span><br><span class="line">    money double -- 金额</span><br><span class="line">);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">--  插入数据</span><br><span class="line">insert into account values(1,&#x27;zhangsan&#x27;,1000);</span><br><span class="line">insert into account values(2,&#x27;lisi&#x27;,1000);</span><br><span class="line"></span><br><span class="line">-- 设置MySQL的事务为手动提交(关闭自动提交)</span><br><span class="line">select @@autocommit;</span><br><span class="line">set autocommit = 0;</span><br><span class="line"> </span><br><span class="line">-- 模拟账户转账</span><br><span class="line">-- 开启事务 </span><br><span class="line">begin;</span><br><span class="line">update account set money = money - 200 where name = &#x27;zhangsan&#x27;;</span><br><span class="line">update account set money = money + 200 where name = &#x27;lisi&#x27;;</span><br><span class="line">-- 提交事务</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line">-- 如果转账中的任何一条出现问题，则回滚事务</span><br><span class="line">rollback;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><p>ACID：Atomicity，Consistency，Isolation，Durability </p>
<p><img src="../../../images/image-20230613114954736.png" alt="image-20230613114954736"></p>
<h2 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h2><p>Mysql的默认隔离级别是Repeatable read。</p>
<p><img src="../../../images/image-20230613115234289.png" alt="image-20230613115234289"></p>
<ul>
<li>读未提交(Read uncommitted)<ul>
<li>一个事务可以读取另一个未提交事务的数据，最低级别，任何情况都无法保证,会造成脏读。</li>
<li>读取未提交的数据，也称为脏读(dirty read)</li>
</ul>
</li>
<li>读已提交(Read committed)<ul>
<li>一个事务要等另一个事务提交后才能读取数据，可避免脏读的发生，会造成不可重复读。</li>
<li>大多数数据库系统的默认隔离级别是READ COMMITTED（但MySQL不是）</li>
<li>不可重复读(nonrepeatable read)，这意味着同一事务中两次执行相同语句，可能会看到不同的数据结果。</li>
</ul>
</li>
<li>可重复读(Repeatable read)<ul>
<li>就是在开始读取数据（事务开启）时，不再允许修改操作，可避免脏读、不可重复读的发生，但是会造成幻读。</li>
<li>幻读，指的是当某个事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行(phantom row)</li>
<li>REPEATABLE READ是MySQL默认的事务隔离级别</li>
</ul>
</li>
<li>串行(Serializable)<ul>
<li>是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。</li>
</ul>
</li>
</ul>
<p><img src="../../../images/image-20230614111107049.png" alt="image-20230614111107049"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查看隔离级别 </span><br><span class="line">show variables like &#x27;%isolation%&#x27;; </span><br><span class="line"></span><br><span class="line">-- 设置隔离级别</span><br><span class="line">/*</span><br><span class="line">set session transaction isolation level 级别字符串</span><br><span class="line">级别字符串：read uncommitted、read committed、repeatable read、serializable</span><br><span class="line">*/</span><br><span class="line">-- 设置read uncommitted</span><br><span class="line">set session transaction isolation level read uncommitted;</span><br><span class="line"> </span><br><span class="line">-- 设置read committed</span><br><span class="line">set session transaction isolation level read committed;</span><br><span class="line"> </span><br><span class="line">-- 设置repeatable read</span><br><span class="line">set session transaction isolation level repeatable read;</span><br><span class="line"> </span><br><span class="line">-- 设置serializable</span><br><span class="line">set session transaction isolation level serializable;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>
